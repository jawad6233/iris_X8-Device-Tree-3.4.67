From ac3ba32634bf2ddbc4efb7d60709ec10f69bceef Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sat, 30 Jul 2016 14:24:03 +0200
Subject: [PATCH] Revert "Fix service permissions"

This reverts commit e58c35b3b0556d2f7cfbfa1254ed4dd2a0ee05e6.
---
 rootdir/init.rc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 4c81acccbf..9b07e6a65e 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -653,7 +653,7 @@ service debuggerd64 /system/bin/debuggerd64
 
 service surfaceflinger /system/bin/surfaceflinger
     class core
-    user root
+    user system
     group graphics drmrpc
     onrestart restart zygote
 
@@ -664,7 +664,7 @@ service drm /system/bin/drmserver
 
 service media /system/bin/mediaserver
     class main
-    user root
+    user media
     group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm qcom_diag
     ioprio rt 4
 
 
From cec4ac632e6fee4466337a638b2cc56679524478 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Thu, 14 Apr 2016 14:10:53 +0200
Subject: [PATCH] Implement fakeiccid

Change-Id: I63789736383802893f49c1ebe3dcf0217cd582f3
---
 .../com/android/internal/telephony/SubscriptionInfoUpdater.java    | 2 +-
 src/java/com/android/internal/telephony/uicc/IccConstants.java     | 3 +++
 src/java/com/android/internal/telephony/uicc/RuimRecords.java      | 7 ++++---
 src/java/com/android/internal/telephony/uicc/SIMRecords.java       | 7 ++++---
 4 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 01ee3a752e..fc22d6a37e 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -290,7 +290,7 @@ public void handleMessage(Message msg) {
                         mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                     }
                 } else {
-                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
+                    mIccId[slotId] = IccConstants.FAKE_ICCID;
                     logd("Query IccId fail: " + ar.exception);
                 }
                 logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
diff --git a/src/java/com/android/internal/telephony/uicc/IccConstants.java b/src/java/com/android/internal/telephony/uicc/IccConstants.java
index 90e6b46464..5944d3b4de 100644
--- a/src/java/com/android/internal/telephony/uicc/IccConstants.java
+++ b/src/java/com/android/internal/telephony/uicc/IccConstants.java
@@ -102,4 +102,7 @@
 
     //UICC access
     static final String DF_ADF = "7FFF";
+
+    // Fake ICCID
+    static final String FAKE_ICCID = "00000000000001";
 }
diff --git a/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index d348c8125e..8e5f4ab67d 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -690,10 +690,11 @@ public void handleMessage(Message msg) {
                 data = (byte[])ar.result;
 
                 if (ar.exception != null) {
-                    break;
+                    mIccId = FAKE_ICCID;
+                }
+                else {
+                    mIccId = IccUtils.bcdToString(data, 0, data.length);
                 }
-
-                mIccId = IccUtils.bcdToString(data, 0, data.length);
 
                 log("iccid: " + mIccId);
 
diff --git a/src/java/com/android/internal/telephony/uicc/SIMRecords.java b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
index 1ac262be0a..e8583a3f0d 100644
--- a/src/java/com/android/internal/telephony/uicc/SIMRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
@@ -874,10 +874,11 @@ public void handleMessage(Message msg) {
                 data = (byte[])ar.result;
 
                 if (ar.exception != null) {
-                    break;
+                    mIccId = FAKE_ICCID;
+                }
+                else {
+                    mIccId = IccUtils.bcdToString(data, 0, data.length);
                 }
-
-                mIccId = IccUtils.bcdToString(data, 0, data.length);
 
                 log("iccid: " + mIccId);
 
 
From 4e5d695cfe1ecb5deae9b30c2eecdfb8b250da35 Mon Sep 17 00:00:00 2001
From: "chao.bi" <chao.bi@intel.com>
Date: Wed, 30 Mar 2016 21:17:08 +0800
Subject: [PATCH 01/92] Fix bug in CallManager unregisterForPhoneStates()

In this function, it asserts the handler pointer by mistake,
so it should stop&release related resources but actually not.
Therefore, when the Phone instance is registerred again, it
will hit mess due to old resources are not cleared. One example
of issue is for IMS Phone: when enter/exit flight mode, IMS
Phone instance will be unregistered and registered again, but
IMS phone registration will fail due to this bug, thus blocks IMS
functions.

Change-Id: I84ff4dcdddf6a8b0d52b5f3bec4ced008cc79fe3
Signed-off-by: chao.bi <chao.bi@intel.com>
Signed-off-by: Zhiquan Liu <zhiquan.liu@intel.com>
---
 src/java/com/android/internal/telephony/CallManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/CallManager.java b/src/java/com/android/internal/telephony/CallManager.java
index 2e975186a4..72a24e27fa 100644
--- a/src/java/com/android/internal/telephony/CallManager.java
+++ b/src/java/com/android/internal/telephony/CallManager.java
@@ -686,7 +686,7 @@ private void registerForPhoneStates(Phone phone) {
     private void unregisterForPhoneStates(Phone phone) {
         // Make sure that we clean up our map of handlers to Phones.
         CallManagerHandler handler = mHandlerMap.get(phone);
-        if (handler != null) {
+        if (handler == null) {
             Rlog.e(LOG_TAG, "Could not find Phone handler for unregistration");
             return;
         }

From 02834f0de12631b3ef95b1cec18fd5b43932dada Mon Sep 17 00:00:00 2001
From: Abhishek G <agilra@cyngn.com>
Date: Tue, 3 May 2016 18:20:12 -0700
Subject: [PATCH 02/92] Single digit MMI codes cause CTS to fail

Single digit MMI codes are invalid. These result in a notification
which interferes with UI tests during CTS. Turning this notification
into a toast message for when a single digit MMI code is dialed from
idle. Note that single digit codes are valid from within a call.

Change-Id: I9aa239d38573d070c9b7a8f86424a99162ddd57e
Issue-Id: FEIJ-142
---
 src/java/com/android/internal/telephony/gsm/GsmMmiCode.java | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
index 3e460cb06f..1620bd05a7 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
@@ -31,6 +31,7 @@
 import android.text.TextUtils;
 import android.telephony.Rlog;
 import android.util.Log;
+import android.widget.Toast;
 
 import static com.android.internal.telephony.CommandsInterface.*;
 import com.android.internal.telephony.gsm.SsData;
@@ -1128,6 +1129,10 @@ void sendUssd(String ussdMessage) {
                             LOG_TAG,
                             mContext.getText(com.android.internal.R.string.mmiError).toString()
                             );
+                            Toast.makeText(
+                                mContext,
+                                mContext.getText(com.android.internal.R.string.mmiError).toString(),
+                                Toast.LENGTH_SHORT).show();
                     } else {
                         mMessage = getErrorMessage(ar);
                     }

From 2308fc2d7e6a9fda0aed7e63b47e035b0235b63f Mon Sep 17 00:00:00 2001
From: Ravi Banuri <ravibanuri@codeaurora.org>
Date: Wed, 20 Jan 2016 21:23:51 +0530
Subject: [PATCH 03/92] Add new networktypes in sim status

Make changes in CarrierAppUtils file to get carrier ID

Issue: PAELLA-223
CRs-Fixed: 957527

Change-Id: Iee6be0e9b2220213f443287efd01c47ae79619b0
---
 .../internal/telephony/CarrierAppUtils.java        | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/java/com/android/internal/telephony/CarrierAppUtils.java b/src/java/com/android/internal/telephony/CarrierAppUtils.java
index 45425d0ec5..f49e925e9a 100644
--- a/src/java/com/android/internal/telephony/CarrierAppUtils.java
+++ b/src/java/com/android/internal/telephony/CarrierAppUtils.java
@@ -21,14 +21,18 @@
 import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.telephony.TelephonyManager;
 import android.util.Slog;
 
 import com.android.internal.annotations.VisibleForTesting;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Utilities for handling carrier applications.
@@ -39,6 +43,15 @@
 
     private static final boolean DEBUG = false; // STOPSHIP if true
 
+    public static enum CARRIER {
+        TELEPHONY_CARRIER_ONE
+    }
+
+    private static final Map<String, CARRIER> mCarriersMap = Collections.unmodifiableMap
+      (new HashMap<String, CARRIER>() {{
+        put("405854", CARRIER.TELEPHONY_CARRIER_ONE);
+    }});
+
     private CarrierAppUtils() {}
 
     /**
@@ -253,4 +266,13 @@ public static void disableCarrierAppsUntilPrivileged(String callingPackage,
         }
         return apps;
     }
+
+    public static CARRIER getCarrierId() {
+        String property = SystemProperties.get("persist.radio.atel.carrier");
+        if (mCarriersMap.containsKey(property)) {
+            return mCarriersMap.get(property);
+        } else {
+            return null;
+        }
+    }
 }

From e638e4759993872bb4fba04491793ac20a5f06d2 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Tue, 3 May 2016 11:57:59 -0700
Subject: [PATCH 04/92] SubscriptionController: don't lock sms prompt state

When sending an MMS, subscription infos will be rebuilt, so at one point
we _could_ have 1 sim and then set the prompt enabled to false, then on
the next pass we wouldn't re-enable it, potentially locking the default
SMS sub to whatever sub gets activated first.

Ticket: CYNGNOS-2570

Change-Id: Id5d3d0593f48f2702fc27485905351fbefb970c7
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 src/java/com/android/internal/telephony/SubscriptionController.java | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 6cf7b7ea79..0767b106e5 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -838,9 +838,7 @@ public int addSubInfoRecord(String iccId, int slotId) {
 
             if (DBG) logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
 
-            if (sSlotIdxToSubId.size() <= 1) {
-                PhoneFactory.setSMSPromptEnabled(false);
-            }
+            PhoneFactory.setSMSPromptEnabled(sSlotIdxToSubId.size() > 1);
 
         } finally {
             Binder.restoreCallingIdentity(identity);

From 889e4706913c9521a3c760f406d6ddec958c678e Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Thu, 5 May 2016 15:35:46 -0700
Subject: [PATCH 05/92] Revert "SubscriptionController: don't lock sms prompt
 state"

This isn't the correct way to do this, we end up resetting SMS sims to
"Always ask" on every data sim change.

Ticket: CYNGNOS-2570

This reverts commit e638e4759993872bb4fba04491793ac20a5f06d2.

Change-Id: If797b56c1e16af1c8292ba9093df8cc823fd5903
---
 src/java/com/android/internal/telephony/SubscriptionController.java | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 0767b106e5..6cf7b7ea79 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -838,7 +838,9 @@ public int addSubInfoRecord(String iccId, int slotId) {
 
             if (DBG) logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
 
-            PhoneFactory.setSMSPromptEnabled(sSlotIdxToSubId.size() > 1);
+            if (sSlotIdxToSubId.size() <= 1) {
+                PhoneFactory.setSMSPromptEnabled(false);
+            }
 
         } finally {
             Binder.restoreCallingIdentity(identity);

From f13c3875a7deb9fc08b4c9f9d9165d6990c0d980 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Thu, 5 May 2016 16:21:11 -0700
Subject: [PATCH 06/92] SubscriptionController: properly detect when MSIM has 1
 SIM

We cannot use sSlotIdxToSubId to determine when to turn the SIM dialog
off, because when subscription information gets reloaded (on data change
for instance), we may add one, then disable SMS prompt, then add the
other, which is incorrect. Query the total number of SIMs from the info
updater.

Ticket: CYNGNOS-2185, CYNGNOS-2570

Change-Id: Iab1225c83b508e055d8a8de55c1e21e2aa153ca5
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../com/android/internal/telephony/SubscriptionController.java     | 2 +-
 .../com/android/internal/telephony/SubscriptionInfoUpdater.java    | 7 +++++++
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 6cf7b7ea79..7eae733d46 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -838,7 +838,7 @@ public int addSubInfoRecord(String iccId, int slotId) {
 
             if (DBG) logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
 
-            if (sSlotIdxToSubId.size() <= 1) {
+            if (PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount() <= 1) {
                 PhoneFactory.setSMSPromptEnabled(false);
             }
 
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 01ee3a752e..c95a143871 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -113,6 +113,7 @@
     private int mCurrentlyActiveUserId;
     private CarrierServiceBindHelper mCarrierServiceBindHelper;
     private boolean mIsShutdown;
+    private int mCurrentSimCount;
 
     public SubscriptionInfoUpdater(Context context, Phone[] phoneProxy, CommandsInterface[] ci) {
         logd("Constructor invoked");
@@ -723,6 +724,8 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             }
         }
 
+        mCurrentSimCount = insertedSimCount;
+
         if (!mIsShutdown && insertedSimCount == 1) {
             SubscriptionInfo sir = subInfos.get(0);
             int subId = sir.getSubscriptionId();
@@ -738,6 +741,10 @@ synchronized protected void updateSubscriptionInfoByIccId() {
         logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
     }
 
+    protected int getInsertedSimCount() {
+        return mCurrentSimCount;
+    }
+
     private boolean isNewSim(String iccId, String[] oldIccId) {
         boolean newSim = true;
         for(int i = 0; i < PROJECT_SIM_NUM; i++) {

From d1cf007e52eae5cea1e52dfe8bca049422eb6611 Mon Sep 17 00:00:00 2001
From: Deepak Kundra <deepakkundra@gmail.com>
Date: Fri, 6 May 2016 10:55:06 +0800
Subject: [PATCH 07/92] RF cutback feature for SAR

Issue-id:FEIJ-350

Change-Id: I1da11d6ac50e8c8c1ec77208f93536403d2132bb
---
 .../com/android/internal/telephony/CommandsInterface.java |  8 ++++++++
 src/java/com/android/internal/telephony/Phone.java        |  6 ++++++
 src/java/com/android/internal/telephony/PhoneBase.java    |  5 +++++
 src/java/com/android/internal/telephony/PhoneProxy.java   |  5 +++++
 src/java/com/android/internal/telephony/RIL.java          | 15 +++++++++++++++
 .../telephony/imsphone/ImsPhoneCommandInterface.java      |  4 ++++
 .../internal/telephony/sip/SipCommandInterface.java       |  4 ++++
 .../internal/telephony/test/SimulatedCommands.java        |  5 +++++
 8 files changed, 52 insertions(+)

diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 6e3b88c50e..b7c68acddc 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -2028,6 +2028,14 @@ public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2
     public void getModemActivityInfo(Message result);
 
     /**
+     *
+     * Set MAX transmit power state
+     *
+     * @param response Callback message contains the status from modem
+     */
+     public void setMaxTransmitPower(int state, Message response);
+
+    /**
      * Request to update the current local call hold state.
      * @param lchStatus, true if call is in lch state
      */
diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index 88c2642930..b5152e658b 100755
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -2149,6 +2149,12 @@ public boolean setRoamingOverride(List<String> gsmRoamingList,
      */
     public void getModemActivityInfo(Message response);
 
+    /**
+     * Set MAX transmit power state
+     */
+    public void setMaxTransmitPower(int state, Message response);
+
+
     /** Request to update the current local call hold state.
      * @param lchStatus, true if call is in lch state
      */
diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index 537e6a3653..c238f54017 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -2728,6 +2728,11 @@ public void getModemActivityInfo(Message response)  {
         mCi.getModemActivityInfo(response);
     }
 
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+        mCi.setMaxTransmitPower(state, response);
+    }
+
     /**
      * Starts LCE service after radio becomes available.
      * LCE service state may get destroyed on the modem when radio becomes unavailable.
diff --git a/src/java/com/android/internal/telephony/PhoneProxy.java b/src/java/com/android/internal/telephony/PhoneProxy.java
index 63bed7f8ac..f8172e414e 100644
--- a/src/java/com/android/internal/telephony/PhoneProxy.java
+++ b/src/java/com/android/internal/telephony/PhoneProxy.java
@@ -1671,6 +1671,11 @@ public void getModemActivityInfo(Message response)  {
         mActivePhone.getModemActivityInfo(response);
     }
 
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+        mActivePhone.setMaxTransmitPower(state, response);
+    }
+
     /**
      * @return true if we are in the emergency call back mode. This is a period where
      * the phone should be using as little power as possible and be ready to receive an
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 6a38927e87..deaf6691c2 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -2832,6 +2832,8 @@ protected RILRequest findAndRemoveRequestFromList(int serial) {
             case RIL_REQUEST_STOP_LCE: ret = responseLceStatus(p); break;
             case RIL_REQUEST_PULL_LCEDATA: ret = responseLceData(p); break;
             case RIL_REQUEST_GET_ACTIVITY_INFO: ret = responseActivityData(p); break;
+            case RIL_REQUEST_SET_MAX_TRANSMIT_POWER: ret = responseVoid(p); break;
+
             default:
                 throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
             //break;
@@ -4455,6 +4457,7 @@ protected Object responseActivityData(Parcel p) {
             case RIL_REQUEST_STOP_LCE: return "RIL_REQUEST_STOP_LCE";
             case RIL_REQUEST_PULL_LCEDATA: return "RIL_REQUEST_PULL_LCEDATA";
             case RIL_REQUEST_GET_ACTIVITY_INFO: return "RIL_REQUEST_GET_ACTIVITY_INFO";
+            case RIL_REQUEST_SET_MAX_TRANSMIT_POWER: return "RIL_REQUEST_SET_MAX_TRANSMIT_POWER";
             default: return "<unknown request>";
         }
     }
@@ -5152,4 +5155,16 @@ public void getModemActivityInfo(Message response) {
         }
         send(rr);
     }
+
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_MAX_TRANSMIT_POWER, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " state = " + state);
+        }
+
+        rr.mParcel.writeInt(state);
+        send(rr);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
index 037fde19ee..aab59875ad 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
@@ -611,5 +611,9 @@ public void pullLceData(Message result) {
     public void getModemActivityInfo(Message result) {
     }
 
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }
diff --git a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 7c73c9f6a0..6feb27270b 100644
--- a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -609,5 +609,9 @@ public void pullLceData(Message result) {
     public void getModemActivityInfo(Message result) {
     }
 
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 0284671142..6708bcefff 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1793,5 +1793,10 @@ public void getModemActivityInfo(Message result) {
         unimplemented(result);
     }
 
+    @Override
+    public void setMaxTransmitPower(int state, Message response) {
+        unimplemented(response);
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }

From 7b0643335505c1114c251661668d843989f88e26 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Mon, 9 May 2016 08:52:42 -0700
Subject: [PATCH 08/92] SubscriptionController: load all subs before setting
 defaults

Switch the whole class to use the new inserted SIM logic added in
change id Iab1225c83b508e055d8a8de55c1e21e2aa153ca5. The previous patch
fixed scenarios going from two sims to one, but going from one to two
(or switching between two sims) is still not working right as the
addSubInfoRecord() still used getActiveSubInfoCountMax() to determine
the number of SIMS.

 - Update getActiveSubInfoCountMax() to return the correct number of SIMs.

 - Furthermore, we need to _only_ update our subscription defaults if we
   are sure we are not in the middle of an update.

 - Let the subscription controller set defaults for 1 SIM device after
   we're done loading

Change-Id: I28eefaff61ae7c75732641465ca59eb67cf3e198
Ticket: CYNGNOS-2185, CYNGNOS-2570
---
 .../internal/telephony/SubscriptionController.java | 32 ++++++--------
 .../telephony/SubscriptionInfoUpdater.java         | 50 +++++++++++-----------
 .../internal/telephony/UiccSmsController.java      |  5 +++
 3 files changed, 41 insertions(+), 46 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 7eae733d46..d40cf97433 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -187,7 +187,7 @@ protected SubscriptionController(Context c) {
     }
 
     private boolean isSubInfoReady() {
-        return sSlotIdxToSubId.size() > 0;
+        return sSlotIdxToSubId.size() == getActiveSubInfoCountMax();
     }
 
     private SubscriptionController(Phone phone) {
@@ -663,7 +663,11 @@ public int getAllSubInfoCount(String callingPackage) {
     @Override
     public int getActiveSubInfoCountMax() {
         // FIXME: This valid now but change to use TelephonyDevController in the future
-        return mTelephonyManager.getSimCount();
+        if (PhoneFactory.getSubscriptionInfoUpdater() != null) {
+            return PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount();
+        } else {
+            return 0;
+        }
     }
 
     /**
@@ -762,6 +766,10 @@ public int addSubInfoRecord(String iccId, int slotId) {
                                         + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
                             }
 
+                            if (!isSubInfoReady()) {
+                                continue;
+                            }
+
                             // Set the default sub if not set or if single sim device
                             // Also set default sub, if current default subId is not active
                             if (!SubscriptionManager.isValidSubscriptionId(defaultSubId)
@@ -769,7 +777,8 @@ public int addSubInfoRecord(String iccId, int slotId) {
                                 setDefaultFallbackSubId(subId);
                             }
                             // If single sim device, set this subscription as the default for everything
-                            if (subIdCountMax == 1) {
+                            if (subIdCountMax == 1
+                                    && TelephonyManager.getDefault().getSimCount() == 1) {
                                 if (DBG) {
                                     logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
                                 }
@@ -777,19 +786,6 @@ public int addSubInfoRecord(String iccId, int slotId) {
                                 setDefaultSmsSubId(subId);
                                 setDefaultVoiceSubId(subId);
                             }
-
-                            // FIXME: Workaround the scenario where default sms subid is not
-                            // being set externally
-                            // CYNGNOS-2185
-                            int phoneId = SubscriptionController.getInstance().getPhoneId(
-                                    getDefaultSmsSubId());
-                            if (phoneId < 0 || phoneId >= TelephonyManager.getDefault()
-                                    .getPhoneCount()) {
-                                Rlog.i(LOG_TAG, "Subscription is invalid. Set default to " + subId);
-                                setDefaultSmsSubId(subId);
-                                PhoneFactory.setSMSPromptEnabled(subIdCountMax > 1);
-                            }
-
                         } else {
                             if (DBG) {
                                 logdl("[addSubInfoRecord] currentSubId != null"
@@ -838,10 +834,6 @@ public int addSubInfoRecord(String iccId, int slotId) {
 
             if (DBG) logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
 
-            if (PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount() <= 1) {
-                PhoneFactory.setSMSPromptEnabled(false);
-            }
-
         } finally {
             Binder.restoreCallingIdentity(identity);
         }
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index c95a143871..5114e5a2f4 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -73,6 +73,9 @@
     private static final int EVENT_SIM_IO_ERROR = 6;
     private static final int EVENT_SIM_UNKNOWN = 7;
     private static final int EVENT_SET_PREFERRED_NW_MODE = 8;
+    private static final int EVENT_UPDATE_INSERTED_SIM_COUNT = 9;
+
+    private static final int DELAY_MILLIS = 500;
 
     private static final String ICCID_STRING_FOR_NO_SIM = "";
     private static final String ICCID_STRING_FOR_NV = "DUMMY_NV_ID";
@@ -113,7 +116,7 @@
     private int mCurrentlyActiveUserId;
     private CarrierServiceBindHelper mCarrierServiceBindHelper;
     private boolean mIsShutdown;
-    private int mCurrentSimCount;
+    private int mCurrentSimCount = 0;
 
     public SubscriptionInfoUpdater(Context context, Phone[] phoneProxy, CommandsInterface[] ci) {
         logd("Constructor invoked");
@@ -203,6 +206,9 @@ public void onReceive(Context context, Intent intent) {
             String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
             logd("simStatus: " + simStatus);
 
+            removeMessages(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId);
+            sendMessageDelayed(obtainMessage(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId), DELAY_MILLIS);
+
             if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
                 if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)) {
                     sendMessage(obtainMessage(EVENT_SIM_ABSENT, slotId, -1));
@@ -295,9 +301,6 @@ public void handleMessage(Message msg) {
                     logd("Query IccId fail: " + ar.exception);
                 }
                 logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
-                if (isAllIccIdQueryDone()) {
-                    updateSubscriptionInfoByIccId();
-                }
                 broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED,
                                          uObj.reason);
                 if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
@@ -346,6 +349,13 @@ public void handleMessage(Message msg) {
                 setPreferredNwModeForSlot(mode.slotId, mode.subId, mode.networkType, null);
                 break;
 
+            case EVENT_UPDATE_INSERTED_SIM_COUNT:
+                if (isAllIccIdQueryDone() && !hasMessages(EVENT_UPDATE_INSERTED_SIM_COUNT)) {
+                    updateSubscriptionInfoByIccId();
+                    logd("update inserted sim count, current sim count: " + mCurrentSimCount);
+                }
+                break;
+
             default:
                 logd("Unknown msg:" + msg.what);
         }
@@ -405,10 +415,6 @@ private void handleSimLoaded(int slotId) {
         }
         mIccId[slotId] = records.getIccId();
 
-        if (isAllIccIdQueryDone()) {
-            updateSubscriptionInfoByIccId();
-        }
-
         int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         int[] subIds = SubscriptionController.getInstance().getSubId(slotId);
         if (subIds != null) {   // Why an array?
@@ -462,7 +468,7 @@ private void handleSimLoaded(int slotId) {
                     PreferenceManager.getDefaultSharedPreferences(mContext);
             int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
 
-            if (storedSubId != subId) {
+            if (storedSubId != subId && storedSubId != -1) {
                 setDefaultDataSubNetworkType(slotId, subId);
                 // Update stored subId
                 SharedPreferences.Editor editor = sp.edit();
@@ -571,19 +577,15 @@ protected void handleSimAbsent(int slotId) {
             logd("SIM" + (slotId + 1) + " hot plug out");
         }
         mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
-        if (isAllIccIdQueryDone()) {
-            updateSubscriptionInfoByIccId();
-        }
         updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
     }
 
     public void updateSubIdForNV(int slotId) {
         mIccId[slotId] = ICCID_STRING_FOR_NV;
-        logd("[updateSubIdForNV]+ Start");
-        if (isAllIccIdQueryDone()) {
-            logd("[updateSubIdForNV]+ updating");
-            updateSubscriptionInfoByIccId();
-        }
+        logd("[updateSubIdForNV]+ scheduled");
+        removeMessages(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId);
+        sendMessageDelayed(obtainMessage(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId),
+                DELAY_MILLIS);
     }
 
     /**
@@ -607,6 +609,7 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             }
         }
         logd("insertedSimCount = " + insertedSimCount);
+        mCurrentSimCount = insertedSimCount;
 
         int index = 0;
         for (int i = 0; i < PROJECT_SIM_NUM; i++) {
@@ -724,15 +727,7 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             }
         }
 
-        mCurrentSimCount = insertedSimCount;
-
-        if (!mIsShutdown && insertedSimCount == 1) {
-            SubscriptionInfo sir = subInfos.get(0);
-            int subId = sir.getSubscriptionId();
-            mSubscriptionManager.setDefaultDataSubId(subId);
-            mSubscriptionManager.setDefaultVoiceSubId(subId);
-            mSubscriptionManager.setDefaultSmsSubId(subId);
-        } else {
+        if (!mIsShutdown && insertedSimCount > 1) {
             // Ensure the modems are mapped correctly
             mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubId());
         }
@@ -742,6 +737,9 @@ synchronized protected void updateSubscriptionInfoByIccId() {
     }
 
     protected int getInsertedSimCount() {
+        if (!isAllIccIdQueryDone()) {
+            return 0;
+        }
         return mCurrentSimCount;
     }
 
diff --git a/src/java/com/android/internal/telephony/UiccSmsController.java b/src/java/com/android/internal/telephony/UiccSmsController.java
index 7dd9e58495..7dcdd544a1 100644
--- a/src/java/com/android/internal/telephony/UiccSmsController.java
+++ b/src/java/com/android/internal/telephony/UiccSmsController.java
@@ -302,6 +302,11 @@ public boolean isSmsSimPickActivityNeeded(int subId) {
             Binder.restoreCallingIdentity(identity);
         }
 
+        if (isSMSPromptEnabled()) {
+            // we will make the user pick
+            return false;
+        }
+
         if (subInfoList != null) {
             final int subInfoLength = subInfoList.size();
 

From 46a6b735514259114f0b6859b3ac3644cad84f7a Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Mon, 16 May 2016 11:15:26 -0700
Subject: [PATCH 09/92] SubscriptionController: fix subscription updating

We need to only repost messages on events we have handled, not
prematurely posting them for every single eveng incoming.

Furthermore, getMaxActive should return the MAX, not the current max.

The previous fixed dual sim insertion and removal ONLY if there were two
sims, but switching from two to one would break.

Ticket: CYNGNOS-2185, CYNGNOS-2570

Change-Id: I5b829662b466f609cd22adfa7d3b754757258463
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../internal/telephony/SubscriptionController.java | 18 +++++-----
 .../telephony/SubscriptionInfoUpdater.java         | 38 +++++++++++++---------
 2 files changed, 31 insertions(+), 25 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index d40cf97433..04322654e9 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -187,7 +187,8 @@ protected SubscriptionController(Context c) {
     }
 
     private boolean isSubInfoReady() {
-        return sSlotIdxToSubId.size() == getActiveSubInfoCountMax();
+        final SubscriptionInfoUpdater subUpdater = PhoneFactory.getSubscriptionInfoUpdater();
+        return subUpdater != null && sSlotIdxToSubId.size() == subUpdater.getInsertedSimCount();
     }
 
     private SubscriptionController(Phone phone) {
@@ -663,11 +664,7 @@ public int getAllSubInfoCount(String callingPackage) {
     @Override
     public int getActiveSubInfoCountMax() {
         // FIXME: This valid now but change to use TelephonyDevController in the future
-        if (PhoneFactory.getSubscriptionInfoUpdater() != null) {
-            return PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount();
-        } else {
-            return 0;
-        }
+        return TelephonyManager.getDefault().getSimCount();
     }
 
     /**
@@ -757,13 +754,14 @@ public int addSubInfoRecord(String iccId, int slotId) {
                             // may not be true, for instance with multiple subs per slot.
                             // But is true at the moment.
                             sSlotIdxToSubId.put(slotId, subId);
-                            int subIdCountMax = getActiveSubInfoCountMax();
+                            int simCount = PhoneFactory.getSubscriptionInfoUpdater()
+                                    .getInsertedSimCount();
                             int defaultSubId = getDefaultSubId();
                             if (DBG) {
                                 logdl("[addSubInfoRecord]"
                                         + " sSlotIdxToSubId.size=" + sSlotIdxToSubId.size()
                                         + " slotId=" + slotId + " subId=" + subId
-                                        + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
+                                        + " defaultSubId=" + defaultSubId + " simCount=" + simCount);
                             }
 
                             if (!isSubInfoReady()) {
@@ -773,11 +771,11 @@ public int addSubInfoRecord(String iccId, int slotId) {
                             // Set the default sub if not set or if single sim device
                             // Also set default sub, if current default subId is not active
                             if (!SubscriptionManager.isValidSubscriptionId(defaultSubId)
-                                    || subIdCountMax == 1 || (!isActiveSubId(defaultSubId))) {
+                                    || simCount == 1 || (!isActiveSubId(defaultSubId))) {
                                 setDefaultFallbackSubId(subId);
                             }
                             // If single sim device, set this subscription as the default for everything
-                            if (subIdCountMax == 1
+                            if (simCount == 1
                                     && TelephonyManager.getDefault().getSimCount() == 1) {
                                 if (DBG) {
                                     logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 5114e5a2f4..9068edaffd 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -206,9 +206,6 @@ public void onReceive(Context context, Intent intent) {
             String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
             logd("simStatus: " + simStatus);
 
-            removeMessages(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId);
-            sendMessageDelayed(obtainMessage(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId), DELAY_MILLIS);
-
             if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
                 if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)) {
                     sendMessage(obtainMessage(EVENT_SIM_ABSENT, slotId, -1));
@@ -301,6 +298,7 @@ public void handleMessage(Message msg) {
                     logd("Query IccId fail: " + ar.exception);
                 }
                 logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
+                update(slotId);
                 broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED,
                                          uObj.reason);
                 if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
@@ -377,7 +375,6 @@ private void handleSimLocked(int slotId, String reason) {
             mIccId[slotId] = null;
         }
 
-
         IccFileHandler fileHandler = mPhone[slotId].getIccCard() == null ? null :
                 mPhone[slotId].getIccCard().getIccFileHandler();
 
@@ -396,6 +393,14 @@ private void handleSimLocked(int slotId, String reason) {
         } else {
             logd("sFh[" + slotId + "] is null, ignore");
         }
+        update(slotId);
+    }
+
+    private void update(int slotId) {
+        sendMessageDelayed(obtainMessage(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId), DELAY_MILLIS);
+        if (isAllIccIdQueryDone()) {
+            updateSubscriptionInfoByIccId();
+        }
     }
 
     private void handleSimLoaded(int slotId) {
@@ -414,6 +419,7 @@ private void handleSimLoaded(int slotId) {
             return;
         }
         mIccId[slotId] = records.getIccId();
+        update(slotId);
 
         int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
         int[] subIds = SubscriptionController.getInstance().getSubId(slotId);
@@ -577,15 +583,14 @@ protected void handleSimAbsent(int slotId) {
             logd("SIM" + (slotId + 1) + " hot plug out");
         }
         mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
+        update(slotId);
         updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
     }
 
     public void updateSubIdForNV(int slotId) {
         mIccId[slotId] = ICCID_STRING_FOR_NV;
         logd("[updateSubIdForNV]+ scheduled");
-        removeMessages(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId);
-        sendMessageDelayed(obtainMessage(EVENT_UPDATE_INSERTED_SIM_COUNT, slotId),
-                DELAY_MILLIS);
+        update(slotId);
     }
 
     /**
@@ -595,7 +600,11 @@ public void updateSubIdForNV(int slotId) {
     synchronized protected void updateSubscriptionInfoByIccId() {
         logd("updateSubscriptionInfoByIccId:+ Start");
 
-        mSubscriptionManager.clearSubscriptionInfo();
+        // only update external state if we have no pending updates pending
+        boolean update = !hasMessages(EVENT_UPDATE_INSERTED_SIM_COUNT);
+        if (update) {
+            mSubscriptionManager.clearSubscriptionInfo();
+        }
 
         for (int i = 0; i < PROJECT_SIM_NUM; i++) {
             mInsertSimState[i] = SIM_NOT_CHANGE;
@@ -670,13 +679,13 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             if (mInsertSimState[i] == SIM_NOT_INSERT) {
                 logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
             } else {
-                if (mInsertSimState[i] > 0) {
+                if (mInsertSimState[i] > 0 && update) {
                     //some special SIMs may have the same IccIds, add suffix to distinguish them
                     //FIXME: addSubInfoRecord can return an error.
                     mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i]
                             + Integer.toString(mInsertSimState[i]), i);
                     logd("SUB" + (i + 1) + " has invalid IccId");
-                } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/ {
+                } else if (update)/*if (sInsertSimState[i] != SIM_NOT_INSERT)*/ {
                     mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
                 }
                 if (isNewSim(mIccId[i], oldIccId)) {
@@ -727,19 +736,18 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             }
         }
 
-        if (!mIsShutdown && insertedSimCount > 1) {
+        if (!mIsShutdown && insertedSimCount > 1 && update) {
             // Ensure the modems are mapped correctly
             mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubId());
         }
 
-        SubscriptionController.getInstance().notifySubscriptionInfoChanged();
+        if (update) {
+            SubscriptionController.getInstance().notifySubscriptionInfoChanged();
+        }
         logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
     }
 
     protected int getInsertedSimCount() {
-        if (!isAllIccIdQueryDone()) {
-            return 0;
-        }
         return mCurrentSimCount;
     }
 

From aa6e4665368a0fe088f4485a150f07257ac7f793 Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Thu, 3 Dec 2015 21:51:33 +0530
Subject: [PATCH 10/92] Fix pdn cleanup issue due to apn change

Whenever there is an apn change event, instead of cleaning up
all active pdn's, deactivate only that pdn whose apn is affected.

Use api cleanUpConnectionsOnUpdatedApns for pdn cleanup when
processing apn change event.

Ref: KIPPER-707, KIPPER-698
Change-Id: I50d1bb9248fd248f33a60f02424131f40d960e8a
CRs-Fixed: 932516
---
 .../android/internal/telephony/dataconnection/DcTracker.java  | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 0c0c7d1208..5da74a6d66 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -1440,10 +1440,12 @@ protected void tryRestartDataConnections(String reason) {
         if (DBG) log("tryRestartDataConnections: createAllApnList and cleanUpAllConnections");
         createAllApnList();
         setInitialAttachApn();
-        cleanUpConnectionsOnUpdatedApns(!isDisconnected);
-
+        if (reason.equalsIgnoreCase(Phone.REASON_APN_CHANGED)) {
+            cleanUpConnectionsOnUpdatedApns(!isDisconnected);
+        } else {
+            cleanUpAllConnections(!isDisconnected, reason);
+        }
         // FIXME: See bug 17426028 maybe no conditional is needed.
-        cleanUpAllConnections(!isDisconnected, reason);
         setupDataOnConnectableApns(reason);
     }
 
@@ -1686,7 +1688,8 @@ private void applyNewState(ApnContext apnContext, boolean enabled, boolean met)
                 // can declare the DUN APN sharable by default traffic, thus still satisfying
                 // those requests and not torn down organically.
                 if ((apnContext.getApnType() == PhoneConstants.APN_TYPE_DUN && teardownForDun())
-                        || apnContext.getState() != DctConstants.State.CONNECTED) {
+                        || apnContext.getState() != DctConstants.State.CONNECTED
+                        || mPhone.getSubId() != SubscriptionManager.getDefaultDataSubId() ) {
                     cleanup = true;
                 } else {
                     cleanup = false;

From 4f27bf9cb9852e05c81e0c51f056c82381949b73 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Tue, 17 May 2016 17:14:44 -0700
Subject: [PATCH 11/92] SubscriptionInfoUpdater: improved sim swap

We now keep track of the last number of inserted SIMs updated for. So
when the number of SIMs has changed we do the following:

 1 sim: Clear stale defaults
        Disable SMS prompt, SMS app will default to current sim
        Disable data if the SIM left in the tray is not the one chosen

 m sim: Enable SMS prompt if we don't have a valid default (aka always
        ask)

Furthermore, when we detect the device is an MSIM device and there is
only one active sub, return the active sub to the UI layers (so SIM
selection screen displays proper, grayed out, current settings).

Ticket: CYNGNOS-2185, CYNGNOS-2570

Change-Id: Ib1b4f4d87640e4b20722295304c58dff7dbeecbb
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../internal/telephony/SubscriptionController.java | 26 +++++++-
 .../telephony/SubscriptionInfoUpdater.java         | 69 +++++++++++++++++++---
 .../internal/telephony/UiccSmsController.java      | 17 ++++--
 3 files changed, 97 insertions(+), 15 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 04322654e9..c1f99b921f 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -191,6 +191,12 @@ private boolean isSubInfoReady() {
         return subUpdater != null && sSlotIdxToSubId.size() == subUpdater.getInsertedSimCount();
     }
 
+    private boolean isSingleSimActiveOnMSIM() {
+        final SubscriptionInfoUpdater subUpdater = PhoneFactory.getSubscriptionInfoUpdater();
+        return subUpdater != null && subUpdater.getInsertedSimCount() == 1
+                && getActiveSubInfoCountMax() > 1;
+    }
+
     private SubscriptionController(Phone phone) {
         mContext = phone.getContext();
         mCM = CallManager.getInstance();
@@ -1368,6 +1374,10 @@ private void broadcastDefaultSmsSubIdChanged(int subId) {
 
     @Override
     public int getDefaultSmsSubId() {
+        if (isSingleSimActiveOnMSIM()) {
+            if (VDBG) logd("[getDefaultSmsSubId] overridden to current single active sim");
+            return mDefaultFallbackSubId;
+        }
         int subId = Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.MULTI_SIM_SMS_SUBSCRIPTION,
                 SubscriptionManager.INVALID_SUBSCRIPTION_ID);
@@ -1399,6 +1409,10 @@ private void broadcastDefaultVoiceSubIdChanged(int subId) {
 
     @Override
     public int getDefaultVoiceSubId() {
+        if (isSingleSimActiveOnMSIM()) {
+            if (VDBG) logd("[getDefaultVoiceSubId] overridden to current single active sim");
+            return mDefaultFallbackSubId;
+        }
         int subId = Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.MULTI_SIM_VOICE_CALL_SUBSCRIPTION,
                 SubscriptionManager.INVALID_SUBSCRIPTION_ID);
@@ -1408,6 +1422,10 @@ public int getDefaultVoiceSubId() {
 
     @Override
     public int getDefaultDataSubId() {
+        if (isSingleSimActiveOnMSIM()) {
+            if (VDBG) logd("[getDefaultDataSubId] overridden to current single active sim");
+            return mDefaultFallbackSubId;
+        }
         int subId = Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION,
                 SubscriptionManager.INVALID_SUBSCRIPTION_ID);
@@ -1466,8 +1484,10 @@ public void setDefaultDataSubId(int subId) {
         // FIXME is this still needed?
         updateAllDataConnectionTrackers();
 
-        Settings.Global.putInt(mContext.getContentResolver(),
-                Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, subId);
+        if (!isSingleSimActiveOnMSIM()) {
+            Settings.Global.putInt(mContext.getContentResolver(),
+                    Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, subId);
+        }
         broadcastDefaultDataSubIdChanged(subId);
     }
 
@@ -1509,7 +1529,7 @@ protected void setDefaultFallbackSubId(int subId) {
         if (SubscriptionManager.isValidSubscriptionId(subId)) {
             int phoneId = getPhoneId(subId);
             if (phoneId >= 0 && (phoneId < mTelephonyManager.getPhoneCount()
-                    || mTelephonyManager.getSimCount() == 1)) {
+                    || isSingleSimActiveOnMSIM())) {
                 if (DBG) logdl("[setDefaultFallbackSubId] set mDefaultFallbackSubId=" + subId);
                 mDefaultFallbackSubId = subId;
                 // Update MCC MNC device configuration information
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 9068edaffd..9a27beba86 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -34,7 +34,6 @@
 import android.os.Message;
 import android.os.RemoteException;
 import android.os.ServiceManager;
-import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.preference.PreferenceManager;
 import android.provider.Settings;
@@ -54,6 +53,7 @@
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.util.BitSet;
 import java.util.List;
 
 /**
@@ -104,6 +104,8 @@
 
     // Key used to read/write the current IMSI. Updated on SIM_STATE_CHANGED - LOADED.
     public static final String CURR_SUBID = "curr_subid";
+    // Key used to determine if the number of sims in the device has changed
+    private static final String PREF_LAST_SEEN_SIM_COUNT = "previous_update_sim_count";
 
     private static Phone[] mPhone;
     private CommandsInterface[] mCommandsInterfaces;
@@ -117,6 +119,7 @@
     private CarrierServiceBindHelper mCarrierServiceBindHelper;
     private boolean mIsShutdown;
     private int mCurrentSimCount = 0;
+    private BitSet mLockedSims = new BitSet(PROJECT_SIM_NUM);
 
     public SubscriptionInfoUpdater(Context context, Phone[] phoneProxy, CommandsInterface[] ci) {
         logd("Constructor invoked");
@@ -227,6 +230,16 @@ public void onReceive(Context context, Intent intent) {
                     logd("Ignoring simStatus: " + simStatus);
                 }
             }
+
+            if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(simStatus)) {
+                mLockedSims.set(slotId);
+                update(slotId);
+            } else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simStatus)
+                    || IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(simStatus)) {
+                mLockedSims.clear(slotId);
+                update(slotId);
+            }
+
             logd("[Receiver]-");
         }
     };
@@ -348,6 +361,7 @@ public void handleMessage(Message msg) {
                 break;
 
             case EVENT_UPDATE_INSERTED_SIM_COUNT:
+                logd("EVENT_UPDATE_INSERTED_SIM_COUNT: locked sims: " + mLockedSims.cardinality());
                 if (isAllIccIdQueryDone() && !hasMessages(EVENT_UPDATE_INSERTED_SIM_COUNT)) {
                     updateSubscriptionInfoByIccId();
                     logd("update inserted sim count, current sim count: " + mCurrentSimCount);
@@ -474,7 +488,7 @@ private void handleSimLoaded(int slotId) {
                     PreferenceManager.getDefaultSharedPreferences(mContext);
             int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
 
-            if (storedSubId != subId && storedSubId != -1) {
+            if (storedSubId != subId) {
                 setDefaultDataSubNetworkType(slotId, subId);
                 // Update stored subId
                 SharedPreferences.Editor editor = sp.edit();
@@ -736,17 +750,58 @@ synchronized protected void updateSubscriptionInfoByIccId() {
             }
         }
 
-        if (!mIsShutdown && insertedSimCount > 1 && update) {
-            // Ensure the modems are mapped correctly
-            mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubId());
-        }
+        if (update && !mIsShutdown && mLockedSims.cardinality() == 0) {
+            final int previousUpdateSimCount = previousUpdateSimCount();
+            if (previousUpdateSimCount != insertedSimCount) {
+                logd("number of sims changed, resetting sms prompt, old sim count: "
+                        + previousUpdateSimCount);
+                if (insertedSimCount == 1 && PROJECT_SIM_NUM > 1) {
+                    // 1 sim, msim device: clear stale defaults (doesn't clear inactive subs)
+                    mSubscriptionManager.clearDefaultsForInactiveSubIds();
+
+                    // then disable sms prompt (sms app will default to inserted sim)
+                    PhoneFactory.setSMSPromptEnabled(false); // can't prompt for 1 sim
+
+                    // finally, disable data if this single sim isn't our our selected data sim previously
+                    int realStoredDataSub = Settings.Global.getInt(mContext.getContentResolver(),
+                            Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION,
+                            SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+                    if (realStoredDataSub != SubscriptionManager.getDefaultDataSubId()) {
+                        PhoneFactory.getDefaultPhone().setDataEnabled(false);
+                    }
 
-        if (update) {
+                } else if (insertedSimCount > 1) {
+                    // we now have multiple sims, maybe enable the SMS prompt if no valid
+                    // sub is ready to handle SMS
+                    PhoneFactory.setSMSPromptEnabled(!SubscriptionManager.isValidSubscriptionId(
+                            SubscriptionManager.getDefaultSmsSubId()));
+                }
+                setPreviousUpdateSimCount(insertedSimCount);
+            }
+            // Ensure the modems are mapped correctly
+            // will not override MSIM settings with 1 sim in the device.
+            mSubscriptionManager.setDefaultDataSubId(SubscriptionManager.getDefaultDataSubId());
+            SubscriptionController.getInstance().notifySubscriptionInfoChanged();
+        } else if (update && !mIsShutdown) {
+            // we have locked sims, need to update so we can unlock them
             SubscriptionController.getInstance().notifySubscriptionInfoChanged();
         }
         logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
     }
 
+    private int previousUpdateSimCount() {
+        return PreferenceManager.getDefaultSharedPreferences(mContext)
+                .getInt(PREF_LAST_SEEN_SIM_COUNT, 0);
+    }
+
+    private void setPreviousUpdateSimCount(int simCount) {
+        PreferenceManager.getDefaultSharedPreferences(mContext)
+                .edit()
+                .putInt(PREF_LAST_SEEN_SIM_COUNT, simCount)
+                .apply();
+    }
+
     protected int getInsertedSimCount() {
         return mCurrentSimCount;
     }
diff --git a/src/java/com/android/internal/telephony/UiccSmsController.java b/src/java/com/android/internal/telephony/UiccSmsController.java
index 7dcdd544a1..7d17d441bf 100644
--- a/src/java/com/android/internal/telephony/UiccSmsController.java
+++ b/src/java/com/android/internal/telephony/UiccSmsController.java
@@ -291,6 +291,12 @@ public boolean isImsSmsSupportedForSubscriber(int subId) {
 
     @Override
     public boolean isSmsSimPickActivityNeeded(int subId) {
+        if (!isSMSPromptEnabled()) {
+            Rlog.d(LOG_TAG, "isSmsSimPickActivityNeeded: false, sms prompt disabled.");
+            // user knows best
+            return false;
+        }
+
         final Context context = ActivityThread.currentApplication().getApplicationContext();
         TelephonyManager telephonyManager =
                 (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
@@ -302,11 +308,6 @@ public boolean isSmsSimPickActivityNeeded(int subId) {
             Binder.restoreCallingIdentity(identity);
         }
 
-        if (isSMSPromptEnabled()) {
-            // we will make the user pick
-            return false;
-        }
-
         if (subInfoList != null) {
             final int subInfoLength = subInfoList.size();
 
@@ -320,6 +321,12 @@ public boolean isSmsSimPickActivityNeeded(int subId) {
 
             // If reached here and multiple SIMs and subs present, sms sim pick activity is needed
             if (subInfoLength > 0 && telephonyManager.getSimCount() > 1) {
+                final SubscriptionInfoUpdater subscriptionInfoUpdater
+                        = PhoneFactory.getSubscriptionInfoUpdater();
+                if (subscriptionInfoUpdater != null) {
+                    // use the *real* inserted sim count if we can
+                    return subscriptionInfoUpdater.getInsertedSimCount() > 1;
+                }
                 return true;
             }
         }

From 15372b2c9d46179c41ec2453491d84a9e30f4786 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Thu, 19 May 2016 15:26:41 -0700
Subject: [PATCH 12/92] Add ContentObserver when sms sent limit changed

When SMS message limit is changed in settings, it will only takes
effect after restart the phone.
Add ContentObserver to listen for SMS message limit changes.

FEIJ-716

Change-Id: I1a2294f5b3b1e3e55692e563cefbaa154cdb7194
---
 .../internal/telephony/SmsUsageMonitor.java        | 44 +++++++++++++---------
 1 file changed, 26 insertions(+), 18 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SmsUsageMonitor.java b/src/java/com/android/internal/telephony/SmsUsageMonitor.java
index 73e9a42194..941c51a58e 100644
--- a/src/java/com/android/internal/telephony/SmsUsageMonitor.java
+++ b/src/java/com/android/internal/telephony/SmsUsageMonitor.java
@@ -49,6 +49,7 @@
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
@@ -108,8 +109,8 @@ public static int mergeShortCodeCategories(int type1, int type2) {
     /** Premium SMS permission when the owner has allowed the app to send premium SMS. */
     public static final int PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW = 3;
 
-    private final int mCheckPeriod;
-    private final int mMaxAllowed;
+    private final AtomicInteger mCheckPeriod = new AtomicInteger(0);
+    private final AtomicInteger mMaxAllowed = new AtomicInteger(0);
 
     private final HashMap<String, ArrayList<Long>> mSmsStamp =
             new HashMap<String, ArrayList<Long>>();
@@ -226,11 +227,16 @@ int getNumberCategory(String phoneNumber) {
     private static class SettingsObserver extends ContentObserver {
         private final Context mContext;
         private final AtomicBoolean mEnabled;
+        private final AtomicInteger mLimit;
+        private final AtomicInteger mPeriod;
 
-        SettingsObserver(Handler handler, Context context, AtomicBoolean enabled) {
+        SettingsObserver(Handler handler, Context context, AtomicBoolean enabled,
+                AtomicInteger limit, AtomicInteger period) {
             super(handler);
             mContext = context;
             mEnabled = enabled;
+            mLimit = limit;
+            mPeriod = period;
             onChange(false);
         }
 
@@ -238,15 +244,25 @@ int getNumberCategory(String phoneNumber) {
         public void onChange(boolean selfChange) {
             mEnabled.set(Settings.Global.getInt(mContext.getContentResolver(),
                     Settings.Global.SMS_SHORT_CODE_CONFIRMATION, 1) != 0);
+            mLimit.set(Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT, DEFAULT_SMS_MAX_COUNT));
+            mPeriod.set(Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS, DEFAULT_SMS_CHECK_PERIOD));
         }
     }
 
     private static class SettingsObserverHandler extends Handler {
-        SettingsObserverHandler(Context context, AtomicBoolean enabled) {
+        SettingsObserverHandler(Context context, AtomicBoolean enabled, AtomicInteger limit,
+                AtomicInteger period) {
             ContentResolver resolver = context.getContentResolver();
-            ContentObserver globalObserver = new SettingsObserver(this, context, enabled);
+            ContentObserver globalObserver = new SettingsObserver(this, context, enabled, limit,
+                    period);
             resolver.registerContentObserver(Settings.Global.getUriFor(
                     Settings.Global.SMS_SHORT_CODE_CONFIRMATION), false, globalObserver);
+            resolver.registerContentObserver(Settings.Global.getUriFor(
+                    Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT), false, globalObserver);
+            resolver.registerContentObserver(Settings.Global.getUriFor(
+                    Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS), false, globalObserver);
         }
     }
 
@@ -256,17 +272,9 @@ public void onChange(boolean selfChange) {
      */
     public SmsUsageMonitor(Context context) {
         mContext = context;
-        ContentResolver resolver = context.getContentResolver();
-
-        mMaxAllowed = Settings.Global.getInt(resolver,
-                Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT,
-                DEFAULT_SMS_MAX_COUNT);
-
-        mCheckPeriod = Settings.Global.getInt(resolver,
-                Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS,
-                DEFAULT_SMS_CHECK_PERIOD);
 
-        mSettingsObserverHandler = new SettingsObserverHandler(mContext, mCheckEnabled);
+        mSettingsObserverHandler = new SettingsObserverHandler(mContext, mCheckEnabled,
+                mMaxAllowed, mCheckPeriod);
 
         loadPremiumSmsPolicyDb();
     }
@@ -611,7 +619,7 @@ private static void checkCallerIsSystemOrPhoneApp() {
      * to send messages and then uninstalled.
      */
     private void removeExpiredTimestamps() {
-        long beginCheckPeriod = System.currentTimeMillis() - mCheckPeriod;
+        long beginCheckPeriod = System.currentTimeMillis() - mCheckPeriod.get();
 
         synchronized (mSmsStamp) {
             Iterator<Map.Entry<String, ArrayList<Long>>> iter = mSmsStamp.entrySet().iterator();
@@ -627,7 +635,7 @@ private void removeExpiredTimestamps() {
 
     private boolean isUnderLimit(ArrayList<Long> sent, int smsWaiting) {
         Long ct = System.currentTimeMillis();
-        long beginCheckPeriod = ct - mCheckPeriod;
+        long beginCheckPeriod = ct - mCheckPeriod.get();
 
         if (VDBG) log("SMS send size=" + sent.size() + " time=" + ct);
 
@@ -635,7 +643,7 @@ private boolean isUnderLimit(ArrayList<Long> sent, int smsWaiting) {
             sent.remove(0);
         }
 
-        if ((sent.size() + smsWaiting) <= mMaxAllowed) {
+        if ((sent.size() + smsWaiting) <= mMaxAllowed.get()) {
             for (int i = 0; i < smsWaiting; i++ ) {
                 sent.add(ct);
             }

From 8d38569e4eac7e0aaaa6f31924758a6087fe1f5e Mon Sep 17 00:00:00 2001
From: Suresh Kumar Sugguna <sureshk@codeaurora.org>
Date: Mon, 7 Dec 2015 15:36:12 +0530
Subject: [PATCH 13/92] IMS: During SRVCC, mark dropped incoming call as missed
 call

During SRVCC, if an incoming call is dropped / ended,
then identify that call as a missed call.

Change-Id: I59256e770207a4acb5b16f8eaf5d981634321a05
CRs-Fixed: 948003
---
 .../com/android/internal/telephony/cdma/CdmaCallTracker.java     | 9 +++++++--
 src/java/com/android/internal/telephony/gsm/GsmCallTracker.java  | 9 +++++++--
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
index c7bff3952b..b3ab17b8c2 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
@@ -760,8 +760,13 @@ public void unregisterForCallWaiting(Handler h) {
         for (Iterator<Connection> it = mHandoverConnections.iterator();
                 it.hasNext();) {
             Connection hoConnection = it.next();
-            log("handlePollCalls - disconnect hoConn= " + hoConnection);
-            ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.NOT_VALID);
+            log("handlePollCalls - disconnect hoConn= " + hoConnection +
+                    " hoConn.State= " + hoConnection.getState());
+            if (hoConnection.getState().isRinging()) {
+                ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.INCOMING_MISSED);
+            } else {
+                ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.NOT_VALID);
+            }
             it.remove();
         }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
index 42b1a16b7a..6fe5604a0d 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
@@ -655,8 +655,13 @@ public void unregisterForVoiceCallEnded(Handler h) {
         for (Iterator<Connection> it = mHandoverConnections.iterator();
                 it.hasNext();) {
             Connection hoConnection = it.next();
-            log("handlePollCalls - disconnect hoConn= " + hoConnection);
-            ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.NOT_VALID);
+            log("handlePollCalls - disconnect hoConn= " + hoConnection +
+                    " hoConn.State= " + hoConnection.getState());
+            if (hoConnection.getState().isRinging()) {
+                ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.INCOMING_MISSED);
+            } else {
+                ((ImsPhoneConnection)hoConnection).onDisconnect(DisconnectCause.NOT_VALID);
+            }
             it.remove();
         }
 

From 4b927d1b9621202285a82d0158f323549f35a950 Mon Sep 17 00:00:00 2001
From: Suresh Kumar Sugguna <sureshk@codeaurora.org>
Date: Mon, 30 Nov 2015 16:55:44 +0530
Subject: [PATCH 14/92] IMS: handle exception for an invalid service class

When an invalid service class is dialed via MMI code,
catch the runtime exception and return as unsupported.

Change-Id: I5f6911da30fc0300e7324e81f2d5dcb4ce1ae20a
CRs-Fixed: 945027
---
 .../internal/telephony/imsphone/ImsPhoneMmiCode.java       | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
index 34b2037672..1549983c46 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
@@ -698,12 +698,16 @@ else if (isServiceCodeCallForwarding(mSc)
                 || (mSc != null && mSc.equals(SC_BS_MT))
                 || (mSc != null && mSc.equals(SC_BAICa))) {
 
-            int serviceClass = siToServiceClass(mSib);
-            if (serviceClass != SERVICE_CLASS_NONE
-                    && serviceClass != SERVICE_CLASS_VOICE) {
-                return false;
+            try {
+                int serviceClass = siToServiceClass(mSib);
+                if (serviceClass != SERVICE_CLASS_NONE
+                        && serviceClass != SERVICE_CLASS_VOICE) {
+                    return false;
+                }
+                return true;
+            } catch (RuntimeException exc) {
+                Rlog.d(LOG_TAG, "Invalid service class " + exc);
             }
-            return true;
         } else if (isPinPukCommand()
                 || (mSc != null
                     && (mSc.equals(SC_PWD) || mSc.equals(SC_CLIP) || mSc.equals(SC_CLIR)))) {

From ff4a806ad151db564b8efa5f367acfd33160ae85 Mon Sep 17 00:00:00 2001
From: Suresh Kumar Sugguna <sureshk@codeaurora.org>
Date: Mon, 31 Aug 2015 12:21:17 +0530
Subject: [PATCH 15/92] IMS: Call forward options with service class support

Added support to pass service class along with
call forwarding requests.

Change-Id: I79311d76f30bc56659962f78f603968728d5752b
CRs-Fixed: 901774
---
 src/java/com/android/internal/telephony/Phone.java | 43 ++++++++++++++++
 .../com/android/internal/telephony/PhoneBase.java  | 60 ++++++++++++++++++++++
 .../com/android/internal/telephony/PhoneProxy.java | 16 ++++++
 .../android/internal/telephony/gsm/GSMPhone.java   | 47 +++++++++++++++--
 .../internal/telephony/imsphone/ImsPhone.java      | 40 +++++++++++++--
 .../telephony/imsphone/ImsPhoneMmiCode.java        |  1 +
 6 files changed, 201 insertions(+), 6 deletions(-)

diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index b5152e658b..667f5e18dd 100755
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -2164,4 +2164,47 @@ public boolean setRoamingOverride(List<String> gsmRoamingList,
      * Set boolean broadcastEmergencyCallStateChanges
      */
     public void setBroadcastEmergencyCallStateChanges(boolean broadcast);
+
+    /**
+     * getCallForwardingOption
+     * gets a call forwarding option. The return value of
+     * ((AsyncResult)onComplete.obj) is an array of CallForwardInfo.
+     *
+     * @param commandInterfaceCFReason is one of the valid call forwarding
+     *        CF_REASONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param commandInterfaceServiceClass is one of the valid supplementary
+     *        service class SERVICE_CLASS_* as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param onComplete a callback message when the action is completed.
+     *        @see com.android.internal.telephony.CallForwardInfo for details.
+     */
+    void getCallForwardingOption(int commandInterfaceCFReason,
+                                 int commandInterfaceServiceClass,
+                                 Message onComplete);
+
+    /**
+     * setCallForwardingOption
+     * sets a call forwarding option.
+     *
+     * @param commandInterfaceCFReason is one of the valid call forwarding
+     *        CF_REASONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param commandInterfaceCFAction is one of the valid call forwarding
+     *        CF_ACTIONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param dialingNumber is the target phone number to forward calls to
+     * @param commandInterfaceServiceClass is one of the valid supplementary
+     *        service class SERVICE_CLASS_* as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param timerSeconds is used by CFNRy to indicate the timeout before
+     *        forwarding is attempted.
+     * @param onComplete a callback message when the action is completed.
+     */
+    void setCallForwardingOption(int commandInterfaceCFReason,
+                                 int commandInterfaceCFAction,
+                                 String dialingNumber,
+                                 int commandInterfaceServiceClass,
+                                 int timerSeconds,
+                                 Message onComplete);
 }
diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index c238f54017..2351ccbc09 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -212,6 +212,8 @@ public void onReceive(Context context, Intent intent) {
     public static final String VM_SIM_IMSI = "vm_sim_imsi_key";
     // Key used to read/write if Call Forwarding is enabled
     public static final String CF_ENABLED = "cf_enabled_key";
+    // Key used to read/write if Video Call Forwarding is enabled
+    public static final String CF_ENABLED_VIDEO = "cf_enabled_key_video";
 
     // Key used to read/write "disable DNS server check" pref (used for testing)
     public static final String DNS_SERVER_CHECK_DISABLED_KEY = "dns_server_check_disabled_key";
@@ -1590,6 +1592,51 @@ public boolean getCallForwardingPreference() {
         return cf;
     }
 
+    /**
+     * This method stores the CF_ENABLED_VIDEO flag in preferences
+     * @param enabled
+     */
+    public void setVideoCallForwardingPreference(boolean enabled) {
+        Rlog.d(LOG_TAG, "Set video call forwarding info to preferences");
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
+        SharedPreferences.Editor edit = sp.edit();
+        edit.putBoolean(CF_ENABLED_VIDEO + getSubId(), enabled);
+        edit.commit();
+
+        // set the sim imsi to be able to track when the sim card is changed.
+        setSimImsi(getSubscriberId());
+    }
+
+    /**
+     * This method gets Video Call Forwarding enabled/disabled from preferences
+     */
+    public boolean getVideoCallForwardingPreference() {
+        Rlog.d(LOG_TAG, "Get video call forwarding info from preferences");
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
+        boolean cf = false;
+        if (TelephonyManager.getDefault().isMultiSimEnabled()) {
+            if (!sp.contains(CF_ENABLED_VIDEO + getSubId()) &&
+                    sp.contains(CF_ENABLED_VIDEO + mPhoneId)) {
+                cf = sp.getBoolean(CF_ENABLED_VIDEO + mPhoneId, false);
+                setVideoCallForwardingPreference(cf);
+                SharedPreferences.Editor edit = sp.edit();
+                edit.remove(CF_ENABLED_VIDEO + mPhoneId);
+                edit.commit();
+            }
+        } else {
+            if (!sp.contains(CF_ENABLED_VIDEO + getSubId()) && sp.contains(CF_ENABLED_VIDEO)) {
+                cf = sp.getBoolean(CF_ENABLED_VIDEO, false);
+                setVideoCallForwardingPreference(cf);
+                SharedPreferences.Editor edit = sp.edit();
+                edit.remove(CF_ENABLED_VIDEO);
+                edit.commit();
+            }
+        }
+        cf = sp.getBoolean(CF_ENABLED_VIDEO + getSubId(), false);
+        return cf;
+    }
+
     public String getSimImsi() {
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
         boolean needMigration = false;
@@ -2785,6 +2832,19 @@ public void setBroadcastEmergencyCallStateChanges(boolean broadcast) {
         mBroadcastEmergencyCallStateChanges = broadcast;
     }
 
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        logUnexpectedCdmaMethodCall("getCallForwardingOption with Serviceclass");
+    }
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceCFAction, String dialingNumber,
+            int commandInterfaceServiceClass, int timerSeconds, Message onComplete) {
+        logUnexpectedCdmaMethodCall("setCallForwardingOption with Serviceclass");
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("PhoneBase: subId=" + getSubId());
         pw.println(" mPhoneId=" + mPhoneId);
diff --git a/src/java/com/android/internal/telephony/PhoneProxy.java b/src/java/com/android/internal/telephony/PhoneProxy.java
index f8172e414e..54a567c7e5 100644
--- a/src/java/com/android/internal/telephony/PhoneProxy.java
+++ b/src/java/com/android/internal/telephony/PhoneProxy.java
@@ -1699,6 +1699,22 @@ public void setBroadcastEmergencyCallStateChanges(boolean broadcast) {
         mActivePhone.setBroadcastEmergencyCallStateChanges(broadcast);
     }
 
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        mActivePhone.getCallForwardingOption(commandInterfaceCFReason,
+                commandInterfaceServiceClass, onComplete);
+    }
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceCFAction, String dialingNumber,
+            int commandInterfaceServiceClass, int timerSeconds, Message onComplete) {
+        mActivePhone.setCallForwardingOption(commandInterfaceCFReason,
+                commandInterfaceCFAction, dialingNumber,
+                commandInterfaceServiceClass, timerSeconds, onComplete);
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         try {
             ((PhoneBase)mActivePhone).dump(fd, pw, args);
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 82ae9f49d4..8c6c9bad7b 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -335,7 +335,7 @@ public boolean getCallForwardingIndicator() {
         } else {
             cf = getCallForwardingPreference();
         }
-        return cf;
+        return cf || getVideoCallForwardingPreference();
     }
 
     @Override
@@ -1238,9 +1238,47 @@ public void getCallForwardingOption(int commandInterfaceCFReason, Message onComp
     }
 
     @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        ImsPhone imsPhone = mImsPhone;
+        if ((imsPhone != null)
+                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE
+                || imsPhone.isUtEnabled())) {
+            imsPhone.getCallForwardingOption(commandInterfaceCFReason,
+                    commandInterfaceServiceClass, onComplete);
+            return;
+        }
+
+        if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+            if (LOCAL_DEBUG) Rlog.d(LOG_TAG, "requesting call forwarding query.");
+            Message resp;
+            if (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL) {
+                resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+            } else {
+                resp = onComplete;
+            }
+            mCi.queryCallForwardStatus(commandInterfaceCFReason,
+                    commandInterfaceServiceClass, null, resp);
+        }
+    }
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFAction,
+            int commandInterfaceCFReason,
+            String dialingNumber,
+            int timerSeconds,
+            Message onComplete) {
+        setCallForwardingOption(commandInterfaceCFAction,
+                commandInterfaceCFReason, dialingNumber,
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                timerSeconds, onComplete);
+    }
+
+    @Override
     public void setCallForwardingOption(int commandInterfaceCFAction,
             int commandInterfaceCFReason,
             String dialingNumber,
+            int commandInterfaceServiceClass,
             int timerSeconds,
             Message onComplete) {
         ImsPhone imsPhone = mImsPhone;
@@ -1248,7 +1286,8 @@ public void setCallForwardingOption(int commandInterfaceCFAction,
                 && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
                 || imsPhone.isUtEnabled())) {
             imsPhone.setCallForwardingOption(commandInterfaceCFAction,
-                    commandInterfaceCFReason, dialingNumber, timerSeconds, onComplete);
+                    commandInterfaceCFReason, dialingNumber,
+                    commandInterfaceServiceClass, timerSeconds, onComplete);
             return;
         }
 
@@ -1265,7 +1304,7 @@ public void setCallForwardingOption(int commandInterfaceCFAction,
             }
             mCi.setCallForward(commandInterfaceCFAction,
                     commandInterfaceCFReason,
-                    CommandsInterface.SERVICE_CLASS_VOICE,
+                    commandInterfaceServiceClass,
                     dialingNumber,
                     timerSeconds,
                     resp);
@@ -1562,6 +1601,8 @@ public void handleMessage (Message msg) {
                     storeVoiceMailNumber(null);
                     setCallForwardingPreference(false);
                     setVmSimImsi(null);
+                    setVideoCallForwardingPreference(false);
+                    setSimImsi(null);
                     SubscriptionController controller =
                             SubscriptionController.getInstance();
                     controller.removeStaleSubPreferences(CF_ENABLED);
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index 822b6b4ea6..e3226fe840 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -71,6 +71,8 @@
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_NOT_REACHABLE;
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_BUSY;
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_UNCONDITIONAL;
+import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_DATA_SYNC;
+import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_PACKET;
 import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_VOICE;
 import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_NONE;
 
@@ -272,7 +274,7 @@ public boolean getCallForwardingIndicator() {
         } else {
             cf = getCallForwardingPreference();
         }
-        return cf;
+        return cf || getVideoCallForwardingPreference();
     }
 
     /**
@@ -835,6 +837,7 @@ public void setCallForwardingOption(int commandInterfaceCFAction,
                 CommandsInterface.SERVICE_CLASS_VOICE, timerSeconds, onComplete);
     }
 
+    @Override
     public void setCallForwardingOption(int commandInterfaceCFAction,
             int commandInterfaceCFReason,
             String dialingNumber,
@@ -1186,7 +1189,12 @@ private CallForwardInfo getCallForwardInfo(ImsCallForwardInfo info) {
         CallForwardInfo cfInfo = new CallForwardInfo();
         cfInfo.status = info.mStatus;
         cfInfo.reason = getCFReasonFromCondition(info.mCondition);
-        cfInfo.serviceClass = SERVICE_CLASS_VOICE;
+        //Check if the service class signifies Video call forward
+        if(info.mServiceClass == (SERVICE_CLASS_DATA_SYNC + SERVICE_CLASS_PACKET)) {
+            cfInfo.serviceClass = info.mServiceClass;
+        } else {
+            cfInfo.serviceClass = SERVICE_CLASS_VOICE;
+        }
         cfInfo.toa = info.mToA;
         cfInfo.number = info.mNumber;
         cfInfo.timeSeconds = info.mTimeSeconds;
@@ -1210,7 +1218,11 @@ private CallForwardInfo getCallForwardInfo(ImsCallForwardInfo info) {
         } else {
             for (int i = 0, s = infos.length; i < s; i++) {
                 if (infos[i].mCondition == ImsUtInterface.CDIV_CF_UNCONDITIONAL) {
-                    if (r != null) {
+                    //Check if the service class signifies Video call forward
+                    if (infos[i].mServiceClass == (SERVICE_CLASS_DATA_SYNC +
+                            SERVICE_CLASS_PACKET)) {
+                        setVideoCallForwardingPreference(infos[i].mStatus == 1);
+                    } else if (r != null) {
                         setCallForwardingPreference(infos[i].mStatus == 1);
                         setVoiceCallForwardingFlag(r, 1, (infos[i].mStatus == 1),
                             infos[i].mNumber);
@@ -1628,4 +1640,26 @@ public void processDisconnectReason(ImsReasonInfo imsReasonInfo) {
     public boolean isUtEnabled() {
         return mCT.isUtEnabled();
     }
+
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        if (DBG) Rlog.d(LOG_TAG, "getCallForwardingOption reason=" + commandInterfaceCFReason +
+                "serviceclass =" + commandInterfaceServiceClass);
+        if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
+            if (DBG) Rlog.d(LOG_TAG, "requesting call forwarding query.");
+            Message resp;
+            resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
+
+            try {
+                ImsUtInterface ut = mCT.getUtInterface();
+                ut.queryCallForward(getConditionFromCFReason(commandInterfaceCFReason), null,
+                        commandInterfaceServiceClass, resp);
+            } catch (ImsException e) {
+                sendErrorResponse(onComplete, e);
+            }
+        } else if (onComplete != null) {
+            sendErrorResponse(onComplete);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
index 1549983c46..3ebf2a141c 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
@@ -1055,6 +1055,7 @@ void sendUssd(String ussdMessage) {
                     if (mIccRecords != null) {
                         mPhone.setVoiceCallForwardingFlag(1, cffEnabled, mDialingNumber);
                         mPhone.setCallForwardingPreference(cffEnabled);
+                        mPhone.setVideoCallForwardingPreference(cffEnabled);
                     }
                 }
 

From 26961a7fc2142c1b9138da0419c17d8057f9d1d4 Mon Sep 17 00:00:00 2001
From: Richard Liu <richardl@codeaurora.org>
Date: Wed, 13 Jan 2016 11:13:45 +0800
Subject: [PATCH 16/92] Move main thread in IPBIM to other thread to fix
 deadlock.

When thread A waits to get result A from main thread in
IccPhoneBookInterfaceManager (IPBIM), its lock in IPBIM is released.
So thread B holds this lock to query PB to post message to main
thread in UsimPhoneBookManager to get result B. Then result A
returns into main thread in IPBIM, it acquires lock in IPBIM to
notify thread A, but this lock in IPBIM is held by thread B.
Thread B also waits to get result B from main thread in
UsimPhoneBookManager, deadlock occurs.

Change-Id: Id6c6b6231618378c27216dbf0e13a665cbae1022
---
 .../telephony/IccPhoneBookInterfaceManager.java        | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java b/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
index a8a2674333..b495e61007 100644
--- a/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
@@ -19,6 +19,7 @@
 import android.content.ContentValues;
 import android.content.pm.PackageManager;
 import android.os.AsyncResult;
+import android.os.HandlerThread;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -59,7 +60,18 @@
     protected static final int EVENT_LOAD_DONE = 2;
     protected static final int EVENT_UPDATE_DONE = 3;
 
-    protected Handler mBaseHandler = new Handler() {
+    protected final IccPbHandler mBaseHandler;
+
+    private static final HandlerThread  mHandlerThread  = new HandlerThread("IccPbHandlerLoader");
+    static {
+        mHandlerThread.start();
+    }
+
+    protected class IccPbHandler extends Handler {
+        public IccPbHandler(Looper looper) {
+            super(looper);
+        }
+
         @Override
         public void handleMessage(Message msg) {
             AsyncResult ar;
@@ -119,6 +131,8 @@ public IccPhoneBookInterfaceManager(PhoneBase phone) {
         if (r != null) {
             mAdnCache = r.getAdnCache();
         }
+
+        mBaseHandler = new IccPbHandler(mHandlerThread.getLooper());
     }
 
     public void dispose() {
@@ -335,7 +349,7 @@ public boolean updateAdnRecordsWithContentValuesInEfBySearch(int efid, ContentVa
     protected void checkThread() {
         if (!ALLOW_SIM_OP_IN_UI_THREAD) {
             // Make sure this isn't the UI thread, since it will block
-            if (mBaseHandler.getLooper().equals(Looper.myLooper())) {
+            if (Looper.getMainLooper().equals(Looper.myLooper())) {
                 loge("query() called on the main UI thread!");
                 throw new IllegalStateException(
                         "You cannot call query on this provder from the main UI thread.");

From 5e3969d6c2be8f6c3c77be87b9ea28ff9893e09f Mon Sep 17 00:00:00 2001
From: Suchand Ghosh <suchan@codeaurora.org>
Date: Tue, 12 Jan 2016 10:19:00 +0530
Subject: [PATCH 17/92] IMS-VT: Update video state of the connection first.

Video state is used to determine if connection modification
happened. Delaying video state updates confuses other layers,
which use the video state notification to determine if session
upgrade/downgrade happened.

Change-Id: Ic2ec84d3673bbbd247546757336b95a066bf91f8
CRs-Fixed: 948726
---
 .../com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java     | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 7e90edd492..f25cf77792 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -373,6 +373,7 @@ public void unregisterForVoiceCallEnded(Handler h) {
             mPendingMO = new ImsPhoneConnection(mPhone,
                     checkForTestEmergencyNumber(dialString), this, mForegroundCall,
                     isEmergencyNumber, intentExtras);
+            mPendingMO.setVideoState(videoState);
         }
         addConnection(mPendingMO);
 

From d483262f1e84d0bcba10060e3372d5fec9ebd1fe Mon Sep 17 00:00:00 2001
From: Qingsheng Li <qingshengli@codeaurora.org>
Date: Fri, 27 Nov 2015 13:51:46 +0800
Subject: [PATCH 18/92] Telephony: Pass the subId when set data enabled

After rebooting device, setDataEnabled() is called using
the dummy subId, but before CMD_SET_USER_DATA_ENABLE is handled,
the vaild subId is read, so in onSetUserDataEnabled() method we use
valid subId to update db but not the dummy subId which we want to set.

Pass the subId when set data enabled to ensure that we can
save the mobile_data value to db using the correct subId.

Change-Id: I7c3944fa4c9922e66170e320742371374a034163
CRs-fixed: 930649
---
 .../internal/telephony/dataconnection/DcTrackerBase.java | 16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index b1423e7aa3..8137ff896e 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -835,7 +835,9 @@ public boolean getDataOnRoamingEnabled() {
     public void setDataEnabled(boolean enable) {
         Message msg = obtainMessage(DctConstants.CMD_SET_USER_DATA_ENABLE);
         msg.arg1 = enable ? 1 : 0;
-        if (DBG) log("setDataEnabled: sendMessage: enable=" + enable);
+        msg.arg2 = mPhone.getSubId();
+        if (DBG) log("setDataEnabled: sendMessage: enable=" + enable +
+                ", subId=" + mPhone.getSubId());
         sendMessage(msg);
     }
 
@@ -986,8 +988,9 @@ public void handleMessage(Message msg) {
             }
             case DctConstants.CMD_SET_USER_DATA_ENABLE: {
                 final boolean enabled = (msg.arg1 == DctConstants.ENABLED) ? true : false;
-                if (DBG) log("CMD_SET_USER_DATA_ENABLE enabled=" + enabled);
-                onSetUserDataEnabled(enabled);
+                final int subId = msg.arg2;
+                if (DBG) log("CMD_SET_USER_DATA_ENABLE enabled=" + enabled + ", subId=" + subId);
+                onSetUserDataEnabled(enabled, subId);
                 break;
             }
             case DctConstants.CMD_SET_DEPENDENCY_MET: {
@@ -1377,6 +1380,10 @@ public void cleanUpAllConnections(String cause) {
     public abstract boolean isDisconnected();
 
     protected void onSetUserDataEnabled(boolean enabled) {
+        onSetUserDataEnabled(enabled, mPhone.getSubId());
+    }
+
+    protected void onSetUserDataEnabled(boolean enabled, int subId) {
         synchronized (mDataEnabledLock) {
             if (mUserDataEnabled != enabled) {
                 mUserDataEnabled = enabled;
@@ -1385,8 +1392,7 @@ protected void onSetUserDataEnabled(boolean enabled) {
                 if (TelephonyManager.getDefault().getSimCount() == 1) {
                     Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
                 } else {
-                    int phoneSubId = mPhone.getSubId();
-                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId,
+                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + subId,
                             enabled ? 1 : 0);
                 }
                 if (getDataOnRoamingEnabled() == false &&

From 7ad0f8e11f353ba9b59b6cc517ec2d9463827697 Mon Sep 17 00:00:00 2001
From: Wileen Chiu <wileenc@codeaurora.org>
Date: Wed, 20 Jan 2016 10:26:53 -0800
Subject: [PATCH 19/92] Define telephony resources as a coreApp

- After encrypting the device, the
packageManager is unable to parse the
resources apk, thus the values are not
loaded at bootup
- Define telresources.apk as a coreApp

Change-Id: I1bb766283b88fa11bcd35f00d6e5804992b66c86
CRs-Fixed: 963027
---
 resources/AndroidManifest.xml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/resources/AndroidManifest.xml b/resources/AndroidManifest.xml
index 142a4be4e5..98ec2258b4 100644
--- a/resources/AndroidManifest.xml
+++ b/resources/AndroidManifest.xml
@@ -29,7 +29,8 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.frameworks.telresources" >
+    package="com.android.frameworks.telresources"
+    coreApp="true">
 
     <application android:process="com.qualcomm.telephony">
     </application>

From a16437db6cd687bcfc8d2ca210f70c9fff80b24d Mon Sep 17 00:00:00 2001
From: Wileen Chiu <wileenc@codeaurora.org>
Date: Thu, 3 Dec 2015 13:20:05 -0800
Subject: [PATCH 20/92] Add p2 option in OpenLogicalChannel

- Adding support for P2 parameter
- Needed to support OMAPI 3.0 defined
by SIM Alliance

Change-Id: I51ab0821f84dca8fff90c912ebbfc9f1129dcbe5
CRs-Fixed: 948787
---
 src/java/com/android/internal/telephony/BaseCommands.java |  3 +++
 .../com/android/internal/telephony/CommandsInterface.java | 10 ++++++++++
 src/java/com/android/internal/telephony/RIL.java          | 15 +++++++++++++++
 .../internal/telephony/test/SimulatedCommands.java        |  5 +++++
 .../com/android/internal/telephony/uicc/UiccCard.java     |  7 +++++++
 5 files changed, 40 insertions(+)

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index c73d26b03a..c58608767b 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -921,6 +921,9 @@ public void setLocalCallHold(boolean lchStatus) {
     public void iccOpenLogicalChannel(String AID, Message response) {}
 
     @Override
+    public void iccOpenLogicalChannel(String AID, byte p2, Message response) {}
+
+    @Override
     public void iccCloseLogicalChannel(int channel, Message response) {}
 
     @Override
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index b7c68acddc..814121fa0b 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -1805,6 +1805,16 @@ public void setInitialAttachApn(String apn, String protocol, int authType, Strin
     public void iccOpenLogicalChannel(String AID, Message response);
 
     /**
+     * Open a logical channel to the SIM.
+     *
+     * @param p2 P2 parameter
+     * @param AID application id.
+     * @param response Callback message. response.obj will be an int [1]
+                element [0] set to the id of the logical channel.
+     */
+    public void iccOpenLogicalChannel(String AID, byte p2, Message response);
+
+    /**
      * Close a previously opened logical channel to the SIM.
      *
      * Input parameters equivalent to TS 27.007 AT+CCHC command.
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index deaf6691c2..2b22a61c1a 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -2814,6 +2814,7 @@ protected RILRequest findAndRemoveRequestFromList(int serial) {
             case RIL_REQUEST_IMS_SEND_SMS: ret =  responseSMS(p); break;
             case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: ret =  responseICC_IO(p); break;
             case RIL_REQUEST_SIM_OPEN_CHANNEL: ret  = responseInts(p); break;
+            case RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2: ret = responseInts(p); break;
             case RIL_REQUEST_SIM_CLOSE_CHANNEL: ret  = responseVoid(p); break;
             case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: ret = responseICC_IO(p); break;
             case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
@@ -2950,6 +2951,7 @@ protected RadioCapability makeStaticRadioCapability() {
             case RIL_REQUEST_GET_IMEI:
             case RIL_REQUEST_GET_IMEISV:
             case RIL_REQUEST_SIM_OPEN_CHANNEL:
+            case RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2:
             case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
 
                 if (!RILJ_LOGV) {
@@ -4438,6 +4440,7 @@ protected Object responseActivityData(Parcel p) {
             case RIL_REQUEST_IMS_SEND_SMS: return "RIL_REQUEST_IMS_SEND_SMS";
             case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
             case RIL_REQUEST_SIM_OPEN_CHANNEL: return "RIL_REQUEST_SIM_OPEN_CHANNEL";
+            case RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2: return "RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2";
             case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
             case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
             case RIL_REQUEST_NV_READ_ITEM: return "RIL_REQUEST_NV_READ_ITEM";
@@ -4935,6 +4938,18 @@ public void iccOpenLogicalChannel(String AID, Message response) {
         send(rr);
     }
 
+    @Override
+    public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2, response);
+        rr.mParcel.writeByte(p2);
+        rr.mParcel.writeString(AID);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 6708bcefff..b12b9f5f87 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1722,6 +1722,11 @@ public void iccOpenLogicalChannel(String AID, Message response) {
     }
 
     @Override
+    public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
+        unimplemented(response);
+    }
+
+    @Override
     public void iccCloseLogicalChannel(int channel, Message response) {
         unimplemented(response);
     }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCard.java b/src/java/com/android/internal/telephony/uicc/UiccCard.java
index 961d18ee5d..00674f1e10 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCard.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCard.java
@@ -615,6 +615,13 @@ public void iccOpenLogicalChannel(String AID, Message response) {
                 mHandler.obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, response));
     }
 
+    public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
+        loglocal("Open Logical Channel: " + AID + " , " + p2 + " by pid:" + Binder.getCallingPid()
+                + " uid:" + Binder.getCallingUid());
+        mCi.iccOpenLogicalChannel(AID,
+                p2, mHandler.obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, response));
+    }
+
     /**
      * Exposes {@link CommandsInterface.iccCloseLogicalChannel}
      */

From c0be62f83e2102d2c946ebdfa3f7ff5f2a20bfd4 Mon Sep 17 00:00:00 2001
From: Sumod Mukkumkal Chandran <sumodm@codeaurora.org>
Date: Tue, 9 Feb 2016 12:31:09 +0530
Subject: [PATCH 21/92] Phone App crash: process com.android.phone has stopped.

Fix for the issue Phone App crash Unfortunately, the process
com.android.phone has stopped.

Change-Id: I70c941cb061c1066c79bfd293ebe1a3c63908fd9
---
 .../com/android/internal/telephony/SubscriptionController.java    | 6 +++++-
 src/java/com/google/android/mms/pdu/PduPersister.java             | 8 ++++++--
 2 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index c1f99b921f..0020ea3cdd 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -903,18 +903,22 @@ private int setCarrierText(String text, int subId) {
 
         // Now that all security checks passes, perform the operation as ourselves.
         final long identity = Binder.clearCallingIdentity();
+        int result = -1;
         try {
             ContentValues value = new ContentValues(1);
             value.put(SubscriptionManager.CARRIER_NAME, text);
 
-            int result = mContext.getContentResolver().update(SubscriptionManager.CONTENT_URI,
+            result = mContext.getContentResolver().update(SubscriptionManager.CONTENT_URI,
                     value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" +
                     Long.toString(subId), null);
             notifySubscriptionInfoChanged();
 
             return result;
+        } catch (android.database.sqlite.SQLiteDiskIOException e) {
+            e.printStackTrace();
         } finally {
             Binder.restoreCallingIdentity(identity);
+            return result;
         }
     }
 
diff --git a/src/java/com/google/android/mms/pdu/PduPersister.java b/src/java/com/google/android/mms/pdu/PduPersister.java
index 0f027becaf..2f5601bff4 100644
--- a/src/java/com/google/android/mms/pdu/PduPersister.java
+++ b/src/java/com/google/android/mms/pdu/PduPersister.java
@@ -1606,8 +1606,12 @@ public static String toIsoString(byte[] bytes) {
      * Remove all objects in the temporary path.
      */
     public void release() {
-        Uri uri = Uri.parse(TEMPORARY_DRM_OBJECT_URI);
-        SqliteWrapper.delete(mContext, mContentResolver, uri, null, null);
+        try {
+            Uri uri = Uri.parse(TEMPORARY_DRM_OBJECT_URI);
+            SqliteWrapper.delete(mContext, mContentResolver, uri, null, null);
+        } catch (android.database.sqlite.SQLiteDiskIOException e) {
+            e.printStackTrace();
+        }
     }
 
     /**

From e3b45707c790d35a9c6061eae61a689ba8345681 Mon Sep 17 00:00:00 2001
From: Yujing Gu <guy@codeaurora.org>
Date: Fri, 18 Mar 2016 15:30:31 +0800
Subject: [PATCH 22/92] Specify the path when loading from EF_ADN

For CSIM cards, EF_CSIM_LI is also 0x6F3A in CsimFileHandler. If not
specify the path for EF_ADN, the path returned from CsimFileHandler
will be DF_CDMA(0x7F25).

CRs-Fixed: 984740
Change-Id: Ie2ef49cfd624862f70c33598eb91c0b2c4a98d5e
---
 src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java | 4 ++++
 1 file changed, 4 insertions(+)
 mode change 100644 => 100755 src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java

diff --git a/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java b/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
old mode 100644
new mode 100755
index 3c900c73a9..638f0c94fc
--- a/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
+++ b/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
@@ -240,6 +240,10 @@ private String getEFPath(int efid) {
                                 ar.exception);
                     }
 
+                    if (mEf == IccConstants.EF_ADN) {
+                        mPath = getEFPath(mEf);
+                    }
+
                     mFh.updateEFLinearFixed(mEf, mPath, mRecordNumber,
                             data, mPin2, obtainMessage(EVENT_UPDATE_RECORD_DONE));
 

From 8306c37d1dafa03ef43c55f116e43b7a694d20ea Mon Sep 17 00:00:00 2001
From: Yujing Gu <guy@codeaurora.org>
Date: Thu, 25 Feb 2016 17:07:54 +0800
Subject: [PATCH 23/92] Exclude the last two bytes for the non-type1 Email
 file.

From 3GPP TS 31.102 4.4.2.13, if the file is not type 1
(as specified in EFPBR), the last two bytes of the email
should be exclude the E-mail Address.

Change-Id: I2dc595353a8498dc51a286c2a72fc7a82de81b5b
---
 .../android/internal/telephony/gsm/UsimPhoneBookManager.java   | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
index da7f33ecd7..b18fdfde0e 100644
--- a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
+++ b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
@@ -698,8 +698,14 @@ private String readEmailRecord(int recNum, int pbrIndex, int offSet) {
             return null;
         }
 
-        // The length of the record is X+2 byte, where X bytes is the email address
-        String email = IccUtils.adnStringFieldToString(emailRec, 0, emailRec.length - 2);
+        String email;
+        if (mEmailPresentInIap) {
+            //3gpp 31.102 4.4.2.13, in non-type1 EF_EMAIL file,
+            //the length of the record is X+2 byte, where X bytes is the email address
+            email = IccUtils.adnStringFieldToString(emailRec, 0, emailRec.length - 2);
+        } else {
+            email = IccUtils.adnStringFieldToString(emailRec, 0, emailRec.length);
+        }
         return email;
     }
 

From ce26ddd230965b3d205a6e6f950409607fbf28fa Mon Sep 17 00:00:00 2001
From: Andalam Parthasarathi <andala@codeaurora.org>
Date: Wed, 21 Oct 2015 14:10:41 +0530
Subject: [PATCH 24/92] Telephony plugin for GsmServiceStateTracker

 - Add makeGsmServiceStateTracker method in TelephonyPlugin
      to have  provision of extending it from proprietary space.
 - Added telephony delegate function and created QtiGsmServiceStateTracker
   in proprietary jar file

Change-Id: If048d14a4cc614e34afdbe1e1bf41023702a5cb1
CRs-Fixed: 902503
---
 .../internal/telephony/TelephonyPluginBase.java    |  6 ++++++
 .../telephony/TelephonyPluginDelegate.java         |  6 ++++++
 .../telephony/TelephonyPluginInterface.java        |  5 +++++
 .../android/internal/telephony/gsm/GSMPhone.java   |  4 ++--
 .../telephony/gsm/GsmServiceStateTracker.java      | 22 +++++++++++-----------
 5 files changed, 30 insertions(+), 13 deletions(-)

diff --git a/src/java/com/android/internal/telephony/TelephonyPluginBase.java b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
index 173ef14a6f..ba4de666c5 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginBase.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
@@ -34,6 +34,7 @@
 import com.android.internal.telephony.dataconnection.DcTracker;
 import com.android.internal.telephony.dataconnection.DctController;
 import com.android.internal.telephony.gsm.GSMPhone;
+import com.android.internal.telephony.gsm.GsmServiceStateTracker;
 
 public abstract class TelephonyPluginBase implements TelephonyPluginInterface {
     private String TAG = "TelephonyPluginBase";
@@ -81,4 +82,9 @@ public PhoneBase makeCDMALTEPhone(Context context, CommandsInterface ci,
     public void initExtTelephonyClasses(Context context,
             Phone[] phoneProxy, CommandsInterface[] commandsInterfaces) {
     }
+
+    @Override
+    public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone) {
+        return new GsmServiceStateTracker(phone);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
index 89cf198048..84899ebd0a 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
@@ -35,6 +35,8 @@
 import com.android.internal.telephony.ConfigResourceUtil;
 import com.android.internal.telephony.dataconnection.DcTracker;
 import com.android.internal.telephony.dataconnection.DctController;
+import com.android.internal.telephony.gsm.GSMPhone;
+import com.android.internal.telephony.gsm.GsmServiceStateTracker;
 import com.android.internal.telephony.TelephonyPluginBase;
 import com.android.internal.telephony.DefaultTelephonyPlugin;
 import com.android.internal.R;
@@ -136,4 +138,8 @@ public void initExtTelephonyClasses(Context context,
             Phone[] phoneProxy, CommandsInterface[] commandsInterfaces) {
         sPlugin.initExtTelephonyClasses(context, phoneProxy, commandsInterfaces);
     }
+
+    public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone) {
+        return sPlugin.makeGsmServiceStateTracker(phone);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
index 72ded60cdc..865e17d8ad 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
@@ -31,6 +31,9 @@
 
 import com.android.internal.telephony.dataconnection.DcTracker;
 import com.android.internal.telephony.dataconnection.DctController;
+import com.android.internal.telephony.gsm.GSMPhone;
+import com.android.internal.telephony.gsm.GsmServiceStateTracker;
+
 
 public interface TelephonyPluginInterface {
 
@@ -54,4 +57,6 @@ public PhoneBase makeCDMALTEPhone(Context context, CommandsInterface ci,
 
     public void initExtTelephonyClasses(Context context,
             Phone[] phoneProxy, CommandsInterface[] commandsInterfaces);
+
+    public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone);
 }
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 8c6c9bad7b..31507a6a14 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -156,7 +156,7 @@
         mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
         mCT = new GsmCallTracker(this);
 
-        mSST = new GsmServiceStateTracker(this);
+        mSST = TelephonyPluginDelegate.getInstance().makeGsmServiceStateTracker(this);
         mDcTracker = TelephonyPluginDelegate.getInstance().makeDcTracker(this);
 
         if (!unitTestMode) {
@@ -191,7 +191,7 @@
         mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
         mCT = new GsmCallTracker(this);
 
-        mSST = new GsmServiceStateTracker(this);
+        mSST = TelephonyPluginDelegate.getInstance().makeGsmServiceStateTracker(this);
         mDcTracker = TelephonyPluginDelegate.getInstance().makeDcTracker(this);
 
         if (!unitTestMode) {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index fcbf0eeb6b..1be652e6ca 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -91,20 +91,20 @@
 /**
  * {@hide}
  */
-final class GsmServiceStateTracker extends ServiceStateTracker {
+public class GsmServiceStateTracker extends ServiceStateTracker {
     static final String LOG_TAG = "GsmSST";
     static final boolean VDBG = false;
     //CAF_MSIM make it private ??
     private static final int EVENT_ALL_DATA_DISCONNECTED = 1001;
-    private GSMPhone mPhone;
-    GsmCellLocation mCellLoc;
-    GsmCellLocation mNewCellLoc;
+    protected GSMPhone mPhone;
+    protected GsmCellLocation mCellLoc;
+    protected GsmCellLocation mNewCellLoc;
     int mPreferredNetworkType;
 
     private int mMaxDataCalls = 1;
-    private int mNewMaxDataCalls = 1;
+    protected int mNewMaxDataCalls = 1;
     private int mReasonDataDenied = -1;
-    private int mNewReasonDataDenied = -1;
+    protected int mNewReasonDataDenied = -1;
 
     private static final String ACTION_MANAGED_ROAMING_IND =
             "codeaurora.intent.action.ACTION_MANAGED_ROAMING_IND";
@@ -119,12 +119,12 @@
      * Data roaming status solely based on TS 27.007 10.1.19 CGREG. Only used by
      * handlePollStateResult to store CGREG roaming result.
      */
-    private boolean mDataRoaming = false;
+    protected boolean mDataRoaming = false;
 
     /**
      * Mark when service state is in emergency call only mode
      */
-    private boolean mEmergencyOnly = false;
+    protected boolean mEmergencyOnly = false;
 
     /**
      * Sometimes we get the NITZ time before we know what country we
@@ -1073,7 +1073,7 @@ public void pollState() {
         }
     }
 
-    private void pollStateDone() {
+    protected void pollStateDone() {
         if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
             mNewSS.setVoiceRoaming(true);
             mNewSS.setDataRoaming(true);
@@ -1564,7 +1564,7 @@ private void onRestrictedStateChanged(AsyncResult ar) {
     }
 
     /** code is registration state 0-5 from TS 27.007 7.2 */
-    private int regCodeToServiceState(int code) {
+    protected int regCodeToServiceState(int code) {
         switch (code) {
             case 0:
             case 2: // 2 is "searching"
@@ -1594,7 +1594,7 @@ private int regCodeToServiceState(int code) {
      * code is registration state 0-5 from TS 27.007 7.2
      * returns true if registered roam, false otherwise
      */
-    private boolean regCodeIsRoaming (int code) {
+    protected boolean regCodeIsRoaming (int code) {
         return ServiceState.RIL_REG_STATE_ROAMING == code;
     }
 

From af238e593096d2b5e489dcef58c20fdaf51a6f83 Mon Sep 17 00:00:00 2001
From: Shaoxu Liu <shaoxu@codeaurora.org>
Date: Mon, 14 Dec 2015 09:42:26 +0800
Subject: [PATCH 25/92] Add a flag to control SPN display

If the new added flag config_spn_display_control is set to true,
the SPN will not be catenated to the carrier text.

By default this flag is set to false to work as the same as
android original design. It could be enabled in data package
overlay if needed.

Change-Id: I74b8c18983b08cdb1d2cf7c6128e973927ec4f32
---
 resources/res/values/config.xml                    | 27 ++++++++++++++++++++++
 .../telephony/gsm/GsmServiceStateTracker.java      |  8 +++++++
 2 files changed, 35 insertions(+)

diff --git a/resources/res/values/config.xml b/resources/res/values/config.xml
index 730ff98277..4bb6822f4a 100644
--- a/resources/res/values/config.xml
+++ b/resources/res/values/config.xml
@@ -48,4 +48,31 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     <string name="telephony_plugin_jar_name" translatable="false"></string>
     <!--Fully qualified class name of telephony extended plugin.-->
     <string name="telephony_plugin_class_name" translatable="false"></string>
+    <!-- When set to true, this config enables reading and displaying
+         the contents of EF_SDN present in SIM -->
+    <bool name="config_enable_displaying_sdn">false</bool>
+    <!-- config for showing dial option when fdn contact is selected.
+         By default feature is disabled -->
+    <bool name="config_fdn_direct_dial">false</bool>
+    <!-- FDN contact search is enabled-->
+    <bool name="config_fdn_contact_search">false</bool>
+    <!-- plmn name override enabled-->
+    <bool name="config_plmn_name_override_enabled">false</bool>
+
+    <!-- control not to show SPN in carrier text -->
+    <bool name="config_spn_display_control">false</bool>
+
+    <string name="sdn"></string>
+    <string name="summary_sdn"></string>
+    <string name="launch_sdn"></string>
+    <!-- pdp data retry for cause 29 and 33 is disabled-->
+    <bool name="config_pdp_retry_for_29_33_enabled">false</bool>
+    <!--pdp data reject retry delay can be configured here -->
+    <integer name="data_retry_delay">0</integer>
+    <!-- pdp data reject idle timeout delay-->
+    <integer name="data_retry_idle_delay">0</integer>
+    <!-- pdp data reject dialog string for cause 29 and 33 -->
+    <string name="data_conn_status_title"></string>
+    <string name="user_authentication_failed"></string>
+    <string name="service_not_subscribed"></string>
 </resources>
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 1be652e6ca..9af0ac58db 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -59,6 +59,7 @@
 
 import com.android.internal.telephony.CommandException;
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.ConfigResourceUtil;
 import com.android.internal.telephony.EventLogTags;
 import com.android.internal.telephony.ICarrierConfigLoader;
 import com.android.internal.telephony.MccTable;
@@ -156,6 +157,8 @@
      */
     private Notification mNotification;
 
+    private ConfigResourceUtil mConfigResUtil = new ConfigResourceUtil();
+
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
     private static final String WAKELOCK_TAG = "ServiceStateTracker";
@@ -669,6 +672,11 @@ protected void updateSpnDisplay() {
         spn = maybeUpdateHDTagForSpn(showSpn, spn);
         plmn = maybeUpdateHDTagForPlmn(showPlmn, plmn);
 
+        if (mConfigResUtil.getBooleanValue(mPhone.getContext(), "config_spn_display_control")) {
+            // Control not to show SPN.
+            showSpn = false;
+        }
+
         // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
         if (mSubId != subId ||
                 showPlmn != mCurShowPlmn

From b71bf2166da877035300c664b3eee6c1a8b60804 Mon Sep 17 00:00:00 2001
From: Andalam Parthasarathi <andala@codeaurora.org>
Date: Fri, 25 Sep 2015 11:11:56 +0530
Subject: [PATCH 26/92] Add pdp data reject with cause code 29 and 33

Following changes made:
1. Added config flag for data reject cause 29 and 33
2.  Modify access specifiers.

Change-Id: Ibd04b307176b492a26955d8f3e2e640010197555
CRs-Fixed: 774782
---
 .../telephony/dataconnection/DataConnection.java   | 50 ++++++++++++++--------
 .../telephony/dataconnection/DcController.java     |  2 +-
 .../telephony/dataconnection/DcFailCause.java      |  2 +
 .../dataconnection/DcRetryAlarmController.java     | 15 +++++--
 .../telephony/dataconnection/DcTracker.java        |  2 +-
 5 files changed, 49 insertions(+), 22 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
index 61e293d86a..2e7288418c 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
@@ -26,6 +26,7 @@
 import com.android.internal.telephony.RILConstants;
 import com.android.internal.telephony.RetryManager;
 import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.TelephonyPluginDelegate;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.Protocol;
@@ -86,9 +87,9 @@
  * NOTE: All DataConnection objects must be running on the same looper, which is the default
  * as the coordinator has members which are used without synchronization.
  */
-public final class DataConnection extends StateMachine {
-    private static final boolean DBG = true;
-    private static final boolean VDBG = true;
+public class DataConnection extends StateMachine {
+    protected static final boolean DBG = true;
+    protected static final boolean VDBG = true;
 
     /** Retry configuration: A doubling of retry times from 5secs to 30minutes */
     private static final String DEFAULT_DATA_RETRY_CONFIG = "default_randomization=2000,"
@@ -107,25 +108,25 @@
     // The Tester for failing all bringup's
     private DcTesterFailBringUpAll mDcTesterFailBringUpAll;
 
-    private static AtomicInteger mInstanceNumber = new AtomicInteger(0);
+    protected static AtomicInteger mInstanceNumber = new AtomicInteger(0);
     private AsyncChannel mAc;
 
     // Utilities for the DataConnection
-    private DcRetryAlarmController mDcRetryAlarmController;
+    protected DcRetryAlarmController mDcRetryAlarmController;
 
     // The DCT that's talking to us, we only support one!
-    private DcTrackerBase mDct = null;
+    protected DcTrackerBase mDct = null;
 
     protected String[] mPcscfAddr;
 
-    private ConfigResourceUtil mConfigResUtil = new ConfigResourceUtil();
+    protected ConfigResourceUtil mConfigResUtil = new ConfigResourceUtil();
 
     /**
      * Used internally for saving connecting parameters.
      */
-    static class ConnectionParams {
+    public static class ConnectionParams {
         int mTag;
-        ApnContext mApnContext;
+        public ApnContext mApnContext;
         int mInitialMaxRetry;
         int mProfileId;
         int mRilRat;
@@ -157,7 +158,7 @@ public String toString() {
     /**
      * Used internally for saving disconnecting parameters.
      */
-    static class DisconnectParams {
+    public static class DisconnectParams {
         int mTag;
         ApnContext mApnContext;
         String mReason;
@@ -182,7 +183,7 @@ public String toString() {
     private DisconnectParams mDisconnectParams;
     private DcFailCause mDcFailCause;
 
-    private PhoneBase mPhone;
+    protected PhoneBase mPhone;
     private LinkProperties mLinkProperties = new LinkProperties();
     private long mCreateTime;
     private long mLastFailTime;
@@ -195,7 +196,7 @@ public String toString() {
     private NetworkAgent mNetworkAgent;
 
     //***** Package visible variables
-    int mTag;
+    protected int mTag;
     int mCid;
     HashMap<ApnContext, ConnectionParams> mApnContexts = null;
     PendingIntent mReconnectIntent = null;
@@ -214,7 +215,7 @@ public String toString() {
     static final int EVENT_DATA_STATE_CHANGED = BASE + 7;
     static final int EVENT_TEAR_DOWN_NOW = BASE + 8;
     static final int EVENT_LOST_CONNECTION = BASE + 9;
-    static final int EVENT_RETRY_CONNECTION = BASE + 10;
+    protected static final int EVENT_RETRY_CONNECTION = BASE + 10;
     static final int EVENT_DATA_CONNECTION_DRS_OR_RAT_CHANGED = BASE + 11;
     static final int EVENT_DATA_CONNECTION_ROAM_ON = BASE + 12;
     static final int EVENT_DATA_CONNECTION_ROAM_OFF = BASE + 13;
@@ -281,7 +282,7 @@ static DataConnection makeDataConnection(PhoneBase phone, int id,
         return dc;
     }
 
-    void dispose() {
+    protected void dispose() {
         log("dispose: call quiteNow()");
         quitNow();
     }
@@ -422,7 +423,7 @@ private void checkSetMtu(ApnSetting apn, LinkProperties lp) {
     }
 
     //***** Constructor (NOTE: uses dcc.getHandler() as its Handler)
-    private DataConnection(PhoneBase phone, String name, int id,
+    protected DataConnection(PhoneBase phone, String name, int id,
                 DcTrackerBase dct, DcTesterFailBringUpAll failBringUpAll,
                 DcController dcc) {
         super(name, dcc.getHandler());
@@ -696,7 +697,7 @@ private void notifyConnectCompleted(ConnectionParams cp, DcFailCause cause, bool
      *
      * @param dp is the DisconnectParams.
      */
-    private void notifyDisconnectCompleted(DisconnectParams dp, boolean sendAll) {
+    protected void notifyDisconnectCompleted(DisconnectParams dp, boolean sendAll) {
         if (VDBG) log("NotifyDisconnectCompleted");
 
         ApnContext alreadySent = null;
@@ -1619,7 +1620,7 @@ public boolean processMessage(Message msg) {
             return retVal;
         }
     }
-    private DcRetryingState mRetryingState = new DcRetryingState();
+    protected DcRetryingState mRetryingState = new DcRetryingState();
 
     /**
      * The state machine is activating a connection.
@@ -1663,6 +1664,7 @@ public boolean processMessage(Message msg) {
                             // All is well
                             mDcFailCause = DcFailCause.NONE;
                             transitionTo(mActiveState);
+                            handlePdpRejectCauseSuccess();
                             break;
                         case ERR_BadCommand:
                             // Vendor ril rejected the command and didn't connect.
@@ -1693,6 +1695,10 @@ public boolean processMessage(Message msg) {
                                     + " result.isPermanentFail=" +
                                     mDct.isPermanentFail(result.mFailCause);
                             if (DBG) log(str);
+                            boolean isHandled = isPdpRejectCauseFailureHandled(result, cp);
+                            if (isHandled) {
+                                break;
+                            }
                             if (cp.mApnContext != null) cp.mApnContext.requestLog(str);
                             if (result.mFailCause.isRestartRadioFail() ||
                                     (cp.mApnContext != null &&
@@ -2349,4 +2355,14 @@ public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println(" mDcRetryAlarmController=" + mDcRetryAlarmController);
         pw.flush();
     }
+
+    protected void handlePdpRejectCauseSuccess() {
+        if (DBG) log("handlePdpRejectCauseSuccess()");
+    }
+
+    protected boolean isPdpRejectCauseFailureHandled(DataCallResponse.SetupResult result,
+            ConnectionParams cp) {
+        if (DBG) log("isPdpRejectCauseFailureHandled()");
+        return false;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcController.java b/src/java/com/android/internal/telephony/dataconnection/DcController.java
index 0aad0ddd87..543aad2a92 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcController.java
@@ -48,7 +48,7 @@
  * multiple data connections. For instance listening for unsolicited messages
  * and then demultiplexing them to the appropriate DC.
  */
-class DcController extends StateMachine {
+public class DcController extends StateMachine {
     private static final boolean DBG = true;
     private static final boolean VDBG = false;
 
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcFailCause.java b/src/java/com/android/internal/telephony/dataconnection/DcFailCause.java
index 4e0f879a5f..c0692fb632 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcFailCause.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcFailCause.java
@@ -58,6 +58,8 @@
     RADIO_POWER_OFF(-5),                    /* no retry */
     TETHERED_CALL_ACTIVE(-6),               /* no retry */
     ERROR_UNSPECIFIED(0xFFFF),
+    PDP_FAIL_IPV4_CALL_THROTTLED(-7),
+    PDP_FAIL_IPV6_CALL_THROTTLED(-8),
 
     // Errors generated by the Framework
     // specified here
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcRetryAlarmController.java b/src/java/com/android/internal/telephony/dataconnection/DcRetryAlarmController.java
index 763ceb762c..59b8721458 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcRetryAlarmController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcRetryAlarmController.java
@@ -44,6 +44,7 @@
     private String mActionRetry;
     private static final String INTENT_RETRY_ALARM_WHAT = "what";
     private static final String INTENT_RETRY_ALARM_TAG = "tag";
+    private PendingIntent mRetryIntent = null;
 
     private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
             @Override
@@ -109,7 +110,7 @@ void dispose() {
      * @param ar is the result from SETUP_DATA_CALL
      * @return < 0 if no retry is needed otherwise the delay to the next SETUP_DATA_CALL
      */
-    int getSuggestedRetryTime(DataConnection dc, AsyncResult ar) {
+    public int getSuggestedRetryTime(DataConnection dc, AsyncResult ar) {
         int retryDelay;
 
         DataCallResponse response = (DataCallResponse) ar.result;
@@ -147,10 +148,18 @@ public void startRetryAlarm(int what, int tag, int delay) {
                     " what=" + what + " tag=" + tag);
         }
 
-        PendingIntent retryIntent = PendingIntent.getBroadcast (mPhone.getContext(), 0,
+        mRetryIntent = PendingIntent.getBroadcast (mPhone.getContext(), 0,
                                         intent, PendingIntent.FLAG_UPDATE_CURRENT);
         mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
-                SystemClock.elapsedRealtime() + delay, retryIntent);
+                SystemClock.elapsedRealtime() + delay, mRetryIntent);
+    }
+
+    public void cancel(){
+        if(mRetryIntent != null) {
+            if (DBG) log("cancel event: "+mRetryIntent);
+            mAlarmManager.cancel(mRetryIntent);
+            mRetryIntent = null;
+        }
     }
 
     @Override
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 5da74a6d66..cba84a6f91 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -2613,7 +2613,7 @@ protected void addDummyApnSettings(String operator) {
     }
 
     /** Return the DC AsyncChannel for the new data connection */
-    private DcAsyncChannel createDataConnection() {
+    protected DcAsyncChannel createDataConnection() {
         if (DBG) log("createDataConnection E");
 
         int id = mUniqueIdGenerator.getAndIncrement();

From f8a3a6cef3175deaaac4f55b416ca95f9c187374 Mon Sep 17 00:00:00 2001
From: Rakesh Pallerla <rakesh@codeaurora.org>
Date: Tue, 29 Sep 2015 16:03:32 +0530
Subject: [PATCH 27/92] Make changes to create QtiPhoneProxy class.

Make changes required to create QtiPhoneProxy class.

Change-Id: I1f724bc3c51eaede16185924cae882100ac1642b
---
 .../com/android/internal/telephony/PhoneFactory.java     |  2 +-
 src/java/com/android/internal/telephony/PhoneProxy.java  | 16 +++++++++-------
 .../android/internal/telephony/TelephonyPluginBase.java  |  5 +++++
 .../internal/telephony/TelephonyPluginDelegate.java      |  4 ++++
 .../internal/telephony/TelephonyPluginInterface.java     |  2 ++
 5 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 2814f333ad..7091a6e740 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -195,7 +195,7 @@ public static void makeDefaultPhone(Context context) {
                     }
                     Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
 
-                    sProxyPhones[i] = new PhoneProxy(phone);
+                    sProxyPhones[i] = TelephonyPluginDelegate.getInstance().makePhoneProxy(phone);
                 }
                 mProxyController = ProxyController.getInstance(context, sProxyPhones,
                         mUiccController, sCommandsInterfaces);
diff --git a/src/java/com/android/internal/telephony/PhoneProxy.java b/src/java/com/android/internal/telephony/PhoneProxy.java
index 54a567c7e5..9182c5fa2f 100644
--- a/src/java/com/android/internal/telephony/PhoneProxy.java
+++ b/src/java/com/android/internal/telephony/PhoneProxy.java
@@ -73,16 +73,17 @@
 
     private int mRilVersion;
 
-    private static final int EVENT_VOICE_RADIO_TECH_CHANGED = 1;
+    protected static final int EVENT_VOICE_RADIO_TECH_CHANGED = 1;
     private static final int EVENT_RADIO_ON = 2;
-    private static final int EVENT_REQUEST_VOICE_RADIO_TECH_DONE = 3;
-    private static final int EVENT_RIL_CONNECTED = 4;
+    protected static final int EVENT_REQUEST_VOICE_RADIO_TECH_DONE = 3;
+    protected static final int EVENT_RIL_CONNECTED = 4;
     private static final int EVENT_UPDATE_PHONE_OBJECT = 5;
     private static final int EVENT_CARRIER_CONFIG_CHANGED = 6;
     private static final int EVENT_SIM_RECORDS_LOADED = 7;
     private static final int EVENT_RADIO_AVAILABLE = 8;
+    protected static final int EVENT_RADIO_UNAVAILABLE = 9;
 
-    private int mPhoneId = 0;
+    protected int mPhoneId = 0;
 
     private Context mContext;
     private BroadcastReceiver mPhoneProxyReceiver = new BroadcastReceiver() {
@@ -111,6 +112,7 @@ public PhoneProxy(PhoneBase phone) {
         mCommandsInterface.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
         mCommandsInterface.registerForVoiceRadioTechChanged(
                              this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
+        mCommandsInterface.registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, null);
         mPhoneId = phone.getPhoneId();
         mIccSmsInterfaceManager =
                 new IccSmsInterfaceManager((PhoneBase)this.mActivePhone);
@@ -220,15 +222,15 @@ public void handleMessage(Message msg) {
         super.handleMessage(msg);
     }
 
-    private static void logd(String msg) {
+    protected void logd(String msg) {
         Rlog.d(LOG_TAG, "[PhoneProxy] " + msg);
     }
 
-    private void loge(String msg) {
+    protected void loge(String msg) {
         Rlog.e(LOG_TAG, "[PhoneProxy] " + msg);
     }
 
-    private void phoneObjectUpdater(int newVoiceRadioTech) {
+    protected void phoneObjectUpdater(int newVoiceRadioTech) {
         logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
 
         if (mActivePhone != null) {
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginBase.java b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
index ba4de666c5..544d4a0dd1 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginBase.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
@@ -73,6 +73,11 @@ public PhoneBase makeGSMPhone(Context context, CommandsInterface ci,
     }
 
     @Override
+    public PhoneProxy makePhoneProxy(PhoneBase phone) {
+        return new PhoneProxy(phone);
+    }
+
+    @Override
     public PhoneBase makeCDMALTEPhone(Context context, CommandsInterface ci,
             PhoneNotifier notifier, int phoneId) {
         return new CDMALTEPhone(context, ci, notifier, phoneId);
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
index 84899ebd0a..cf66ce7b48 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
@@ -129,6 +129,10 @@ public PhoneBase makeGSMPhone(Context context, CommandsInterface ci,
         return sPlugin.makeGSMPhone(context, ci, notifier, phoneId);
     }
 
+    public PhoneProxy makePhoneProxy(PhoneBase phone) {
+        return sPlugin.makePhoneProxy(phone);
+    }
+
     public PhoneBase makeCDMALTEPhone(Context context, CommandsInterface ci,
             PhoneNotifier notifier, int phoneId) {
         return sPlugin.makeCDMALTEPhone(context, ci, notifier, phoneId);
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
index 865e17d8ad..1bf8dcfbaf 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
@@ -52,6 +52,8 @@ public SubscriptionInfoUpdater makeSubscriptionInfoUpdater(Context context,
     public PhoneBase makeGSMPhone(Context context, CommandsInterface ci,
             PhoneNotifier notifier, int phoneId);
 
+    public PhoneProxy makePhoneProxy(PhoneBase phone);
+
     public PhoneBase makeCDMALTEPhone(Context context, CommandsInterface ci,
             PhoneNotifier notifier, int phoneId);
 

From 10b5e03b0e992aa8890fdc623d30e7574f516595 Mon Sep 17 00:00:00 2001
From: Manjunatha Prabhu <prabum@codeaurora.org>
Date: Mon, 19 Oct 2015 18:29:23 +0530
Subject: [PATCH 28/92] FDN: Telephony plugin for SIMRecords

 - Add makeSIMRecords method in TelephonyPlugin
      to have  provision of extending it from proprietary space.
 - Added telephony delegate function and created QtiSimRecords
   in proprietary jar file

Change-Id: I97eda31c4ddb9f01ad4e06ce8d3ef02a8c960e0e
CRs-Fixed: 798105
---
 src/java/com/android/internal/telephony/TelephonyPluginBase.java   | 7 +++++++
 .../com/android/internal/telephony/TelephonyPluginDelegate.java    | 6 ++++++
 .../com/android/internal/telephony/TelephonyPluginInterface.java   | 6 +++++-
 .../com/android/internal/telephony/uicc/UiccCardApplication.java   | 3 ++-
 4 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/TelephonyPluginBase.java b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
index 544d4a0dd1..8312c636a8 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginBase.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginBase.java
@@ -35,6 +35,8 @@
 import com.android.internal.telephony.dataconnection.DctController;
 import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.gsm.GsmServiceStateTracker;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
 
 public abstract class TelephonyPluginBase implements TelephonyPluginInterface {
     private String TAG = "TelephonyPluginBase";
@@ -92,4 +94,9 @@ public void initExtTelephonyClasses(Context context,
     public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone) {
         return new GsmServiceStateTracker(phone);
     }
+
+    @Override
+    public SIMRecords makeSIMRecords (UiccCardApplication app, Context c, CommandsInterface ci) {
+        return new SIMRecords(app, c, ci);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
index cf66ce7b48..76491b5fec 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginDelegate.java
@@ -39,6 +39,8 @@
 import com.android.internal.telephony.gsm.GsmServiceStateTracker;
 import com.android.internal.telephony.TelephonyPluginBase;
 import com.android.internal.telephony.DefaultTelephonyPlugin;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
 import com.android.internal.R;
 
 import dalvik.system.PathClassLoader;
@@ -146,4 +148,8 @@ public void initExtTelephonyClasses(Context context,
     public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone) {
         return sPlugin.makeGsmServiceStateTracker(phone);
     }
+
+    public SIMRecords makeSIMRecords (UiccCardApplication app, Context c, CommandsInterface ci) {
+        return sPlugin.makeSIMRecords (app, c, ci);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
index 1bf8dcfbaf..ae3613b9ca 100644
--- a/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
+++ b/src/java/com/android/internal/telephony/TelephonyPluginInterface.java
@@ -33,7 +33,8 @@
 import com.android.internal.telephony.dataconnection.DctController;
 import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.gsm.GsmServiceStateTracker;
-
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.UiccCardApplication;
 
 public interface TelephonyPluginInterface {
 
@@ -61,4 +62,7 @@ public void initExtTelephonyClasses(Context context,
             Phone[] phoneProxy, CommandsInterface[] commandsInterfaces);
 
     public GsmServiceStateTracker makeGsmServiceStateTracker(GSMPhone phone);
+
+    public SIMRecords makeSIMRecords (UiccCardApplication app, Context c,
+            CommandsInterface ci);
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index 4e09badba0..f38167e89f 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -26,6 +26,7 @@
 
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyPluginDelegate;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
@@ -179,7 +180,7 @@ void dispose() {
 
     private IccRecords createIccRecords(AppType type, Context c, CommandsInterface ci) {
         if (type == AppType.APPTYPE_USIM || type == AppType.APPTYPE_SIM) {
-            return new SIMRecords(this, c, ci);
+            return TelephonyPluginDelegate.getInstance().makeSIMRecords(this, c, ci);
         } else if (type == AppType.APPTYPE_RUIM || type == AppType.APPTYPE_CSIM){
             return new RuimRecords(this, c, ci);
         } else if (type == AppType.APPTYPE_ISIM) {

From 99e4576c9095502edf649c87f67c51f23e503fa1 Mon Sep 17 00:00:00 2001
From: Ravi Paluri <rpaluri@codeaurora.org>
Date: Fri, 20 Nov 2015 18:39:14 +0530
Subject: [PATCH 29/92] IMS-VT: Update videoProvider in main thread

Setting video provider in seperate thread is causing timing
issues due to which media signalling is happening on
video provider of closed session. So, process merge complete
indication after video provider is updated to ensure that
media signalling happens on video provider attached with
conference imscallsession.

Change-Id: I9a5ca67402effbf22135addcbd3be240d36669b8
CRs-Fixed: 940142
---
 .../telephony/imsphone/ImsPhoneCallTracker.java    | 27 ++++++++--------------
 1 file changed, 9 insertions(+), 18 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index f25cf77792..a831713258 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -1415,24 +1415,15 @@ public void onCallMerged(final ImsCall call, final ImsCall peerCall, boolean swa
             }
             foregroundImsPhoneCall.merge(peerImsPhoneCall, ImsPhoneCall.State.ACTIVE);
 
-            // TODO Temporary code. Remove the try-catch block from the runnable once thread
-            // synchronization is fixed.
-            Runnable r = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        final ImsPhoneConnection conn = findConnection(call);
-                        log("onCallMerged: ImsPhoneConnection=" + conn);
-                        log("onCallMerged: CurrentVideoProvider=" + conn.getVideoProvider());
-                        setVideoCallProvider(conn, call);
-                        log("onCallMerged: CurrentVideoProvider=" + conn.getVideoProvider());
-                    } catch (Exception e) {
-                        loge("onCallMerged: exception " + e);
-                    }
-                }
-            };
-
-            ImsPhoneCallTracker.this.post(r);
+            try {
+                final ImsPhoneConnection conn = findConnection(call);
+                log("onCallMerged: ImsPhoneConnection=" + conn);
+                log("onCallMerged: CurrentVideoProvider=" + conn.getVideoProvider());
+                setVideoCallProvider(conn, call);
+                log("onCallMerged: CurrentVideoProvider=" + conn.getVideoProvider());
+            } catch (Exception e) {
+                loge("onCallMerged: exception " + e);
+            }
 
             // After merge complete, update foreground as Active
             // and background call as Held, if background call exists

From 3db37b5a2ee45317721117ded70cda46d48f1c66 Mon Sep 17 00:00:00 2001
From: Shriram Ganesh <sganesh@codeaurora.org>
Date: Tue, 1 Dec 2015 16:02:06 -0800
Subject: [PATCH 30/92] Fix disabled merge button on conference failure.

The notification for the conference failure is not notified on the
foreground call. As a result in a scenario of foreground single
party call and background conference call merge, the notifications
do not go out on the foreground call. This is because of internal
logic of merge peer and merge host that are maintained during
conference scenarios that makes the host as conference call.

Change-Id: Ia910c1b00e3b4a232153c5b3873a4ec708830f66
CRs-Fixed: 931958
---
 .../com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index a831713258..91e4e89a99 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -1458,7 +1458,7 @@ public void onCallMergeFailed(ImsCall call, ImsReasonInfo reasonInfo) {
 
             // Start plumbing this even through Telecom so other components can take
             // appropriate action.
-            ImsPhoneConnection conn = findConnection(call);
+            ImsPhoneConnection conn = findConnection(mForegroundCall.getImsCall());
             if (conn != null) {
                 conn.onConferenceMergeFailed();
             }

From c7fa65984eb1c0c224fd2d491397bb31fe48dd96 Mon Sep 17 00:00:00 2001
From: Ruthwar Kumar Ambeer <ruthwar@codeaurora.org>
Date: Mon, 30 Nov 2015 16:18:58 +0530
Subject: [PATCH 31/92] Update preferred network type based on active Sub ID

On subInfo changed, Network type need not to be
updated if SUB is not active or dummy.

Keep the phone id based network type in sync with
Sub ID based network type always.

Change-Id: Idaa9da264321307f3f757f086b171f7e783a229a
---
 src/java/com/android/internal/telephony/PhoneBase.java           | 6 +++---
 src/java/com/android/internal/telephony/PhoneFactory.java        | 7 +++++++
 src/java/com/android/internal/telephony/ServiceStateTracker.java | 2 +-
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index 2351ccbc09..c679b4b145 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -1123,7 +1123,7 @@ public void unregisterForEmergencyCallToggle(Handler h) {
 
     private void updateSavedNetworkOperator(NetworkSelectMessage nsm) {
         int subId = getSubId();
-        if (SubscriptionManager.isValidSubscriptionId(subId)) {
+        if (SubscriptionController.getInstance().isActiveSubId(subId)) {
             // open the shared preferences editor, and write the value.
             // nsm.operatorNumeric is "" if we're in automatic.selection.
             SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
@@ -2689,7 +2689,7 @@ public void radioCapabilityUpdated(RadioCapability rc) {
         // Update the cached value
         mRadioCapability.set(rc);
 
-        if (SubscriptionManager.isValidSubscriptionId(getSubId())) {
+        if (SubscriptionController.getInstance().isActiveSubId(getSubId())) {
             updatePreferredType();
             sendSubscriptionSettings(true);
         }
@@ -2719,7 +2719,7 @@ public void sendSubscriptionSettings(boolean restoreNetworkSelection) {
 
     protected void setPreferredNetworkTypeIfSimLoaded() {
         int subId = getSubId();
-        if (SubscriptionManager.isValidSubscriptionId(subId)) {
+        if (SubscriptionController.getInstance().isActiveSubId(subId)) {
             int type = PhoneFactory.calculatePreferredNetworkType(mContext, getSubId());
             setPreferredNetworkType(type, null);
         }
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 7091a6e740..4b6f9adcdc 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -385,6 +385,13 @@ public static int calculatePreferredNetworkType(Context context, int phoneSubId)
                         "phoneSubId = " + phoneSubId + " networkType = " + networkType);
                 networkType = userNwType;
             }
+
+            //Update phone id based network type with Sub ID based.
+            if (networkType != phoneIdNetworkType) {
+                TelephonyManager.putIntAtIndex(context.getContentResolver(),
+                        Settings.Global.PREFERRED_NETWORK_MODE, phoneId,
+                        networkType);
+            }
         } else {
             Rlog.d(LOG_TAG, "calculatePreferredNetworkType: phoneSubId = " + phoneSubId +
                     " is not a active SubId");
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index 88f1c14d74..1c831f1266 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -261,7 +261,7 @@ public void onSubscriptionsChanged() {
             // Set the network type, in case the radio does not restore it.
             int subId = mPhoneBase.getSubId();
             if (mPreviousSubId.getAndSet(subId) != subId) {
-                if (SubscriptionManager.isValidSubscriptionId(subId)) {
+                if (mSubscriptionController.isActiveSubId(subId)) {
                     Context context = mPhoneBase.getContext();
 
                     mPhoneBase.notifyCallForwardingIndicator();

From bd4e168b5756ae8a94cb33a5b7cb6f54558a47c4 Mon Sep 17 00:00:00 2001
From: Sukanya Rajkhowa <srajkh@codeaurora.org>
Date: Tue, 1 Dec 2015 17:32:30 -0800
Subject: [PATCH 32/92] Reset internet requests when SIM is removed

- When SIM is plugged out in Attached state, data state machine
  goes from Attached -> Idle state and does not release the
  requests. As a result, the executed flag of internet network
  request remains false and ALLOW_DATA true is not sent down
  when SIM is plugged back in same slot

- Fix this by resetting INTERNET network request when SIM is
  removed. With the fix, when sim is plugged back into the same
  slot and data attaches, state machine will move correctly
  from Idle->Attaching

CRs-Fixed: 928537

Change-Id: I3ac780f4a7c2114b007107422b3c6cfc7142892e
---
 .../internal/telephony/dataconnection/DctController.java      | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index b1899ace25..0916335500 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -32,6 +32,7 @@
 import android.os.Messenger;
 import android.provider.Settings;
 import android.telephony.Rlog;
+import android.telephony.SubscriptionInfo;
 import android.telephony.SubscriptionManager;
 import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
 import android.text.TextUtils;
@@ -568,6 +569,16 @@ private void onSubInfoReady() {
         for (int i = 0; i < mPhoneNum; ++i) {
             int subId = mPhones[i].getSubId();
             logd("onSubInfoReady handle pending requests subId=" + subId);
+            SubscriptionInfo subInfo = mSubMgr.getActiveSubscriptionInfoForSimSlotIndex(i);
+            if (subInfo == null) {  // No sim in slot
+                logd("onSubInfoReady: subInfo = null");
+                PhoneBase phoneBase = (PhoneBase)mPhones[i].getActivePhone();
+                DcTrackerBase dcTracker = phoneBase.mDcTracker;
+                if (dcTracker.isApnTypeActive(PhoneConstants.APN_TYPE_DEFAULT)) {
+                    logd("onSubInfoReady: reset INTERNET request as SIM has been removed");
+                    deactivateDdsRequests();
+                }
+            }
             mNetworkFilter[i].setNetworkSpecifier(String.valueOf(subId));
             ((DctController.TelephonyNetworkFactory)mNetworkFactory[i]).evalPendingRequest();
         }

From a996d2e2215486d55a07d835d2f95433a1a2795e Mon Sep 17 00:00:00 2001
From: Andalam Parthasarathi <andala@codeaurora.org>
Date: Tue, 6 Oct 2015 17:37:31 +0530
Subject: [PATCH 33/92] Add call reject cause code.

Included last call reject cause code 26.

Change-Id: I0ea326588f336ad28429624305d251b58bf99d0e
CRs-Fixed: 801884
---
 src/java/com/android/internal/telephony/gsm/CallFailCause.java | 1 +
 src/java/com/android/internal/telephony/gsm/GsmConnection.java | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/src/java/com/android/internal/telephony/gsm/CallFailCause.java b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
index 8ef42b2a61..5861c4c621 100644
--- a/src/java/com/android/internal/telephony/gsm/CallFailCause.java
+++ b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
@@ -63,6 +63,7 @@
     static final int CALL_FAIL_NO_ANSWER_FROM_USER = 19;
     static final int CALL_REJECTED = 21;
     static final int PREEMPTION = 25;
+    static final int NON_SELECTED_USER_CLEARING = 26;
     static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 27;
     static final int INVALID_NUMBER = 28;
     static final int FACILITY_REJECTED = 29;
diff --git a/src/java/com/android/internal/telephony/gsm/GsmConnection.java b/src/java/com/android/internal/telephony/gsm/GsmConnection.java
index 6dd625d92e..24a2943220 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmConnection.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmConnection.java
@@ -490,6 +490,9 @@ int disconnectCauseFromCode(int causeCode) {
             case CallFailCause.EMERGENCY_PERM_FAILURE:
                 return DisconnectCause.EMERGENCY_PERM_FAILURE;
 
+            case CallFailCause.NON_SELECTED_USER_CLEARING:
+                return DisconnectCause.NON_SELECTED_USER_CLEARING;
+
             case CallFailCause.ERROR_UNSPECIFIED:
             case CallFailCause.NORMAL_CLEARING:
             default:

From bc93aeb0a10685546977628df2b3edd988cc910c Mon Sep 17 00:00:00 2001
From: Sandeep Kunta <skunta@codeaurora.org>
Date: Wed, 17 Jun 2015 17:58:36 +0530
Subject: [PATCH 34/92] Initialize call state phone app starts

If phone process crashed during an active voice call, even after restart
of phone app, clients still get call state as OFFHOOK since
TelephonyRegistry has the old infomration and whenever new client is
registered that old infomration is given resulting in erroneous UI
behavior. Present fix sends call state update during when phone app
starts so that TelephonyRegistry resets its information.

Change-Id: I709a8b4d78c50099c021ad5f78bbc9fdf6db6585
CRs-Fixed: 906539
---
 src/java/com/android/internal/telephony/cdma/CDMAPhone.java | 1 +
 src/java/com/android/internal/telephony/gsm/GSMPhone.java   | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 0c1152986a..261b3c9b44 100644
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -153,6 +153,7 @@ public CDMAPhone(Context context, CommandsInterface ci, PhoneNotifier notifier,
         super("CDMA", notifier, context, ci, false, phoneId);
         initSstIcc();
         init(context, notifier);
+        notifyPhoneStateChanged();
     }
 
     protected void initSstIcc() {
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 31507a6a14..6c7ffd6fde 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -172,6 +172,7 @@
         mSST.registerForNetworkAttached(this, EVENT_REGISTERED_TO_NETWORK, null);
         mCi.setOnSs(this, EVENT_SS, null);
         setProperties();
+        notifyPhoneStateChanged();
     }
 
     public
@@ -211,6 +212,7 @@
         log("GSMPhone: constructor: sub = " + mPhoneId);
 
         setProperties();
+        notifyPhoneStateChanged();
     }
 
     protected void setProperties() {

From 83b3108b58fa5685058ce4140db0bdaae12469fc Mon Sep 17 00:00:00 2001
From: Ravindra <c_rthat@codeaurora.org>
Date: Mon, 7 Dec 2015 16:02:05 +0530
Subject: [PATCH 35/92] Fix to prevent crash on conference failure.

Notify conference failure only when mForegroundCall has atleast
one connection.

Change-Id: I61cc2441627e3e43e03ef3cfd768e68f1ad3425f
CRs-Fixed: 947347
---
 src/java/com/android/internal/telephony/gsm/GsmCallTracker.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
index 6fe5604a0d..185664204d 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
@@ -938,7 +938,7 @@ GsmConnection getConnectionByIndex(GsmCall call, int index)
                 if (ar.exception != null) {
                     mPhone.notifySuppServiceFailed(getFailedService(msg.what));
                     List<Connection> conn = mForegroundCall.getConnections();
-                    if (conn != null) {
+                    if (conn.size() != 0) {
                         Rlog.d(LOG_TAG, "Notify merge failure");
                         conn.get(0).onConferenceMergeFailed();
                     }

From d4c0b2e102712480d2fadf14e5144b6867991f51 Mon Sep 17 00:00:00 2001
From: Susheel Nyamala <snyamala@codeaurora.org>
Date: Thu, 3 Dec 2015 19:30:30 +0530
Subject: [PATCH 36/92] Fix Ims pdn deactivate due to single pdn arbitration

Add exception for Ims pdn for clean up due to single pdn
arbitration.
Add support for Ims pdn to co-exist with other on non ims
pdn's in single pdn case.

Change-Id: I3c22abf0c1a90900936a0ac190cadc699c2eca69
---
 .../telephony/dataconnection/DcTracker.java        | 33 ++++++++++++++--------
 1 file changed, 22 insertions(+), 11 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index cba84a6f91..7c1e8d8d14 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -1010,19 +1010,21 @@ protected boolean cleanUpAllConnections(boolean tearDown, String reason) {
 
         if (!TextUtils.isEmpty(reason)) {
             specificdisable = reason.equals(Phone.REASON_DATA_SPECIFIC_DISABLED)
-                    || reason.equals(Phone.REASON_ROAMING_ON);
+                    || reason.equals(Phone.REASON_ROAMING_ON)
+                    || reason.equals(Phone.REASON_SINGLE_PDN_ARBITRATION);
         }
 
         for (ApnContext apnContext : mApnContexts.values()) {
-            if (apnContext.isDisconnected() == false) didDisconnect = true;
             if (specificdisable) {
                 if (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IMS)) {
                     if (DBG) log("ApnConextType: " + apnContext.getApnType());
+                    if (apnContext.isDisconnected() == false) didDisconnect = true;
                     apnContext.setReason(reason);
                     cleanUpConnection(tearDown, apnContext);
                 }
             } else {
                 // TODO - only do cleanup if not disconnected
+                if (apnContext.isDisconnected() == false) didDisconnect = true;
                 apnContext.setReason(reason);
                 cleanUpConnection(tearDown, apnContext);
             }
@@ -1371,15 +1373,17 @@ private boolean setupData(ApnContext apnContext, int radioTech) {
                     return false;
                 }
 
-                // Only lower priority calls left.  Disconnect them all in this single PDP case
-                // so that we can bring up the requested higher priority call (once we receive
-                // repsonse for deactivate request for the calls we are about to disconnect
-                if (cleanUpAllConnections(true, Phone.REASON_SINGLE_PDN_ARBITRATION)) {
-                    // If any call actually requested to be disconnected, means we can't
-                    // bring up this connection yet as we need to wait for those data calls
-                    // to be disconnected.
-                    if (DBG) log("setupData: Some calls are disconnecting first.  Wait and retry");
-                    return false;
+                if (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IMS)) {
+                    // Only lower priority calls left.  Disconnect them all in this single PDP case
+                    // so that we can bring up the requested higher priority call (once we receive
+                    // repsonse for deactivate request for the calls we are about to disconnect
+                    if (cleanUpAllConnections(true, Phone.REASON_SINGLE_PDN_ARBITRATION)) {
+                        // If any call actually requested to be disconnected, means we can't
+                        // bring up this connection yet as we need to wait for those data calls
+                        // to be disconnected.
+                        if (DBG) log("setupData: Some calls are disconnecting first.  Wait and retry");
+                        return false;
+                    }
                 }
 
                 // No other calls are active, so proceed
@@ -1476,7 +1480,14 @@ protected void gotoIdleAndNotifyDataConnection(String reason) {
      * @return true if higher priority active apn found
      */
     private boolean isHigherPriorityApnContextActive(ApnContext apnContext) {
+        if (apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IMS)) {
+            return false;
+        }
+
         for (ApnContext otherContext : mPrioritySortedApnContexts) {
+            if (otherContext.getApnType().equals(PhoneConstants.APN_TYPE_IMS)) {
+                continue;
+            }
             if (apnContext.getApnType().equalsIgnoreCase(otherContext.getApnType())) return false;
             if (otherContext.isEnabled() && otherContext.getState() != DctConstants.State.FAILED) {
                 return true;

From 91b4ae864ddc457deaa2b06b43807b7f9121b08d Mon Sep 17 00:00:00 2001
From: Prasath Balakrishnan <bpras@codeaurora.org>
Date: Wed, 25 Nov 2015 16:46:06 +0530
Subject: [PATCH 37/92] Call Forwarding Icon displayed for Deactivated SUB

Call forwarding icon is displayed in the notification bar for the
deactivated SUB after reboot. Since the icc records are null
for the SIM it reads the status from the preference to display the
icon. An additional check is added to identify whether the SIM
is active or not.

CRs-Fixed: 943338

Change-Id: I4f9ec1fab40d39e1cc6a8611b38192ba248eb10f
---
 .../com/android/internal/telephony/PhoneBase.java  | 29 ++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index c679b4b145..ed169333a9 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -33,6 +33,8 @@
 import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.preference.PreferenceManager;
@@ -1563,6 +1565,10 @@ public void setCallForwardingPreference(boolean enabled) {
     public boolean getCallForwardingPreference() {
         Rlog.d(LOG_TAG, "Get callforwarding info from perferences");
 
+        if (!isCurrentSubValid()) {
+            return false;
+        }
+
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
         boolean cf = false;
         // Migrate CF enabled flag from phoneid based preference to subId based.
@@ -1673,6 +1679,29 @@ public void setSimImsi(String imsi) {
         editor.apply();
     }
 
+    private boolean isCurrentSubValid() {
+        final int PROVISIONED = 1;
+        final int INVALID_STATE = -1;
+        int provisionStatus = PROVISIONED;
+        SubscriptionManager subscriptionManager = SubscriptionManager.from(mContext);
+        IExtTelephony mExtTelephony = IExtTelephony.Stub.
+                asInterface(ServiceManager.getService("extphone"));
+        if (TelephonyManager.getDefault().isMultiSimEnabled()) {
+            try {
+                //get current provision state of the SIM.
+                provisionStatus =
+                        mExtTelephony.getCurrentUiccCardProvisioningStatus(mPhoneId);
+            } catch (RemoteException ex) {
+                provisionStatus = INVALID_STATE;
+            } catch (NullPointerException ex) {
+                provisionStatus = INVALID_STATE;
+            }
+        }
+        Rlog.d(LOG_TAG, "ProvisionStatus: " + provisionStatus);
+        return subscriptionManager.isActiveSubId(getSubId()) &&
+                (provisionStatus == PROVISIONED);
+    }
+
     /**
      *  Query the status of the CDMA roaming preference
      */

From 5222189939da8320a6f7191d53e3680f31fd44a2 Mon Sep 17 00:00:00 2001
From: Amit Mahajan <amitmahajan@google.com>
Date: Wed, 16 Sep 2015 18:24:50 -0700
Subject: [PATCH 38/92] Fix useImsForUt check

The check was looking at last character to determine if dialed
number is UT which is not correct. Should look at the last character
of the network portion.

Bug: 24125413
Change-Id: I21e0d2ffac4548d74e68355db86a98516daee304
---
 src/java/com/android/internal/telephony/cdma/CDMAPhone.java | 4 +---
 src/java/com/android/internal/telephony/gsm/GSMPhone.java   | 4 +---
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 261b3c9b44..724b231ea4 100644
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -458,12 +458,10 @@ public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundl
                 && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext)
                 && (imsPhone.getServiceState().getState() != ServiceState.STATE_POWER_OFF);
 
-        boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled()
-                && dialString.endsWith("#");
-
         boolean isUt = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.
                 stripSeparators(dialString)).endsWith("#");
 
+        boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
 
         if (DBG) {
             Rlog.d(LOG_TAG, "imsUseEnabled=" + imsUseEnabled
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 6c7ffd6fde..126c4d9ea0 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -836,12 +836,10 @@ boolean isInCall() {
                 && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext)
                 && (imsPhone.getServiceState().getState() != ServiceState.STATE_POWER_OFF);
 
-        boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled()
-                && dialString.endsWith("#");
-
         boolean isUt = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.
                 stripSeparators(dialString)).endsWith("#");
 
+        boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
 
         if (LOCAL_DEBUG) {
             Rlog.d(LOG_TAG, "imsUseEnabled=" + imsUseEnabled

From 7ba66635a58b0651757659a5870f4642d2ad6838 Mon Sep 17 00:00:00 2001
From: Susheel Nyamala <snyamala@codeaurora.org>
Date: Tue, 24 Nov 2015 20:01:11 +0530
Subject: [PATCH 39/92] Add iccid support for mvno data

To support multimode cards, add iccid as a type for mvno data.

Change-Id: I51115da1b39b839aaccd12d3efe71c1c3f1322b2
---
 .../internal/telephony/dataconnection/ApnSetting.java     | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java b/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
index 117ec6099d..8e1dd5a1dd 100755
--- a/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
+++ b/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
@@ -18,6 +18,7 @@
 
 import android.telephony.ServiceState;
 import android.text.TextUtils;
+import android.util.Log;
 
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.RILConstants;
@@ -34,6 +35,7 @@
 
     static final String V2_FORMAT_REGEX = "^\\[ApnSettingV2\\]\\s*";
     static final String V3_FORMAT_REGEX = "^\\[ApnSettingV3\\]\\s*";
+    static final String TAG = "ApnSetting";
 
     public final String carrier;
     public final String apn;
@@ -368,7 +370,20 @@ public static boolean mvnoMatches(IccRecords r, String mvnoType, String mvnoMatc
                     gid1.substring(0, mvno_match_data_length).equalsIgnoreCase(mvnoMatchData)) {
                 return true;
             }
+        } else if (mvnoType.equalsIgnoreCase("iccid")) {
+            String iccId = r.getIccId();
+            if (iccId != null) {
+                String[] mvnoIccidList = mvnoMatchData.split(",");
+                for (String mvnoIccid : mvnoIccidList) {
+                    Log.d(TAG, "mvnoIccid: " + mvnoIccid);
+                    if (iccId.startsWith(mvnoIccid)) {
+                        Log.d(TAG, "mvno icc id match found");
+                        return true;
+                    }
+                }
+            }
         }
+
         return false;
     }
 

From f2c78b1f3b1a5d51dceaa6b9c067951a4ddd48a8 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 21 May 2016 05:58:08 -0700
Subject: [PATCH 40/92] telephony: Fix RAT type extra key

 * AOSP has one, and QC has one, and they should be interchangeable.

Change-Id: I0ca1fd854bb98d8e10e515adef1a283c6a32f2b1
---
 .../internal/telephony/imsphone/ImsPhoneConnection.java        | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index 5f1092f1a6..b8b9daa432 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -48,6 +48,8 @@
 
 import java.util.Objects;
 
+import org.codeaurora.ims.qtiims.QtiImsInterfaceUtils;
+
 /**
  * {@hide}
  */
@@ -908,13 +910,15 @@ public boolean updateWifiState() {
      * @param extras The ImsCallProfile extras.
      */
     private void updateWifiStateFromExtras(Bundle extras) {
-        if (extras.containsKey(ImsCallProfile.EXTRA_CALL_RAT_TYPE)) {
+        // Google and Qualcomm have competing implementations
+        final String extraCompatType = extras.containsKey(ImsCallProfile.EXTRA_CALL_RAT_TYPE) ?
+            ImsCallProfile.EXTRA_CALL_RAT_TYPE : QtiImsInterfaceUtils.QTI_IMS_CALL_RAT_EXTRA_KEY;
+        if (extras.containsKey(extraCompatType)) {
             // The RIL (sadly) sends us the EXTRA_CALL_RAT_TYPE as a string extra, rather than an
             // integer extra, so we need to parse it.
             int radioTechnology;
             try {
-                radioTechnology = Integer.parseInt(extras.getString(
-                        ImsCallProfile.EXTRA_CALL_RAT_TYPE));
+                radioTechnology = Integer.parseInt(extras.getString(extraCompatType));
             } catch (NumberFormatException nfe) {
                 radioTechnology = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
             }

From 6f9f7821e9bf226afad945635a449c821b49423d Mon Sep 17 00:00:00 2001
From: zhu youhua <youhua@codeaurora.org>
Date: Tue, 8 Dec 2015 17:57:22 +0800
Subject: [PATCH 41/92] Define EF MSPL/MLPL/PRL values and paths

Add several EF paths for UI to get CDMA device info.

Change-Id: Iff43d6b5a6706e54aaf50867419c30a1a322cb2f
CRs-Fixed: 695024
---
 src/java/com/android/internal/telephony/uicc/CsimFileHandler.java | 4 ++++
 src/java/com/android/internal/telephony/uicc/IccConstants.java    | 5 +++++
 src/java/com/android/internal/telephony/uicc/RuimFileHandler.java | 4 ++++
 3 files changed, 13 insertions(+)

diff --git a/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java b/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
index 38cc250eba..186adaebd7 100644
--- a/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
@@ -44,8 +44,12 @@ protected String getEFPath(int efid) {
         case EF_CSIM_IMSIM:
         case EF_CSIM_CDMAHOME:
         case EF_CSIM_EPRL:
+        case EF_CSIM_PRL:
         case EF_CSIM_MIPUPP:
             return MF_SIM + DF_ADF;
+        case EF_CSIM_MSPL:
+        case EF_CSIM_MLPL:
+            return MF_SIM + DF_TELECOM + DF_MMSS;
         }
         String path = getCommonIccEFPath(efid);
         if (path == null) {
diff --git a/src/java/com/android/internal/telephony/uicc/IccConstants.java b/src/java/com/android/internal/telephony/uicc/IccConstants.java
index 90e6b46464..d395fc186e 100644
--- a/src/java/com/android/internal/telephony/uicc/IccConstants.java
+++ b/src/java/com/android/internal/telephony/uicc/IccConstants.java
@@ -73,6 +73,10 @@
     static final int EF_CSIM_IMSIM = 0x6F22;
     static final int EF_CSIM_CDMAHOME = 0x6F28;
     static final int EF_CSIM_EPRL = 0x6F5A;
+    static final int EF_CSIM_PRL = 0x6F30;
+    // C.S0074-Av1.0 Section 4
+    static final int EF_CSIM_MLPL = 0x4F20;
+    static final int EF_CSIM_MSPL = 0x4F21;
     static final int EF_CSIM_MIPUPP = 0x6F4D;
 
     //ISIM access
@@ -99,6 +103,7 @@
     static final String DF_GRAPHICS = "5F50";
     static final String DF_GSM = "7F20";
     static final String DF_CDMA = "7F25";
+    static final String DF_MMSS = "5F3C";
 
     //UICC access
     static final String DF_ADF = "7FFF";
diff --git a/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java b/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
index 58e939fa00..58d72cac99 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
@@ -64,8 +64,12 @@ protected String getEFPath(int efid) {
         case EF_CSIM_IMSIM:
         case EF_CSIM_CDMAHOME:
         case EF_CSIM_EPRL:
+        case EF_CSIM_PRL:
         case EF_CSIM_MIPUPP:
             return MF_SIM + DF_CDMA;
+        case EF_CSIM_MSPL:
+        case EF_CSIM_MLPL:
+            return MF_SIM + DF_TELECOM + DF_MMSS;
         }
         return getCommonIccEFPath(efid);
     }

From cc9c7b6b26f214afb8653e232c75b689562f9b64 Mon Sep 17 00:00:00 2001
From: Mona Hossain <mhossain@codeaurora.org>
Date: Tue, 13 Oct 2015 13:24:31 -0700
Subject: [PATCH 42/92] Update Instrumentation code

Add support for QSPP enhancement

Change-Id: I47bb86b0d0f40fead67e27f29df3eeedf888f628
---
 src/java/android/provider/Telephony.java       |  8 ++++----
 src/java/android/telephony/SmsManager.java     | 13 +++++++------
 src/java/android/telephony/gsm/SmsManager.java | 14 +++++++-------
 3 files changed, 18 insertions(+), 17 deletions(-)

diff --git a/src/java/android/provider/Telephony.java b/src/java/android/provider/Telephony.java
index 443a192baf..94385d8c52 100644
--- a/src/java/android/provider/Telephony.java
+++ b/src/java/android/provider/Telephony.java
@@ -316,7 +316,7 @@ public static String getDefaultSmsPackage(Context context) {
          * @hide
          */
         public static Cursor query(ContentResolver cr, String[] projection) {
-            android.util.SeempLog.record(13);
+            android.util.SeempLog.record(10);
             return cr.query(CONTENT_URI, projection, null, null, DEFAULT_SORT_ORDER);
         }
 
@@ -326,7 +326,7 @@ public static Cursor query(ContentResolver cr, String[] projection) {
          */
         public static Cursor query(ContentResolver cr, String[] projection,
                 String where, String orderBy) {
-            android.util.SeempLog.record(13);
+            android.util.SeempLog.record(10);
             return cr.query(CONTENT_URI, projection, where,
                     null, orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
         }
@@ -2044,7 +2044,7 @@ private Mms() {
          */
         public static Cursor query(
                 ContentResolver cr, String[] projection) {
-            android.util.SeempLog.record(13);
+            android.util.SeempLog.record(10);
             return cr.query(CONTENT_URI, projection, null, null, DEFAULT_SORT_ORDER);
         }
 
@@ -2055,7 +2055,7 @@ public static Cursor query(
         public static Cursor query(
                 ContentResolver cr, String[] projection,
                 String where, String orderBy) {
-            android.util.SeempLog.record(13);
+            android.util.SeempLog.record(10);
             return cr.query(CONTENT_URI, projection,
                     where, null, orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
         }
diff --git a/src/java/android/telephony/SmsManager.java b/src/java/android/telephony/SmsManager.java
index f8fc6db0c7..30c0bb17df 100644
--- a/src/java/android/telephony/SmsManager.java
+++ b/src/java/android/telephony/SmsManager.java
@@ -290,7 +290,7 @@
     public void sendTextMessage(
             String destinationAddress, String scAddress, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent) {
-        android.util.SeempLog.record(94);
+        android.util.SeempLog.record_str(75, destinationAddress);
         sendTextMessageInternal(destinationAddress, scAddress, text,
             sentIntent, deliveryIntent, true /* persistMessageForCarrierApp*/);
     }
@@ -341,6 +341,7 @@ public void sendTextMessageWithoutPersisting(
     public void sendTextMessageWithSelfPermissions(
             String destinationAddress, String scAddress, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        android.util.SeempLog.record_str(75, destinationAddress);
         if (TextUtils.isEmpty(destinationAddress)) {
             throw new IllegalArgumentException("Invalid destinationAddress");
         }
@@ -525,7 +526,6 @@ public void injectSmsPdu(byte[] pdu, String format, PendingIntent receivedIntent
     public void sendMultipartTextMessage(
             String destinationAddress, String scAddress, ArrayList<String> parts,
             ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
-        android.util.SeempLog.record(96);
         sendMultipartTextMessageInternal(destinationAddress, scAddress, parts,
               sentIntents, deliveryIntents, true /* persistMessageForCarrierApp*/);
     }
@@ -709,7 +709,7 @@ public void sendMultipartTextMessage(
     public void sendDataMessage(
             String destinationAddress, String scAddress, short destinationPort,
             byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
-        android.util.SeempLog.record(92);
+        android.util.SeempLog.record_str(73, destinationAddress);
         if (TextUtils.isEmpty(destinationAddress)) {
             throw new IllegalArgumentException("Invalid destinationAddress");
         }
@@ -737,6 +737,7 @@ public void sendDataMessage(
     public void sendDataMessageWithSelfPermissions(
             String destinationAddress, String scAddress, short destinationPort,
             byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        android.util.SeempLog.record_str(73, destinationAddress);
         if (TextUtils.isEmpty(destinationAddress)) {
             throw new IllegalArgumentException("Invalid destinationAddress");
         }
@@ -870,7 +871,7 @@ private static ISms getISmsService() {
      * {@hide}
      */
     public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
-        android.util.SeempLog.record(98);
+        android.util.SeempLog.record(79);
         boolean success = false;
 
         if (null == pdu) {
@@ -902,7 +903,7 @@ public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
      */
     public boolean
     deleteMessageFromIcc(int messageIndex) {
-        android.util.SeempLog.record(99);
+        android.util.SeempLog.record(80);
         boolean success = false;
         byte[] pdu = new byte[IccConstants.SMS_RECORD_LENGTH-1];
         Arrays.fill(pdu, (byte)0xff);
@@ -936,7 +937,7 @@ public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
      * {@hide}
      */
     public boolean updateMessageOnIcc(int messageIndex, int newStatus, byte[] pdu) {
-        android.util.SeempLog.record(100);
+        android.util.SeempLog.record(81);
         boolean success = false;
 
         try {
diff --git a/src/java/android/telephony/gsm/SmsManager.java b/src/java/android/telephony/gsm/SmsManager.java
index 7040b4425d..41c5adcda2 100644
--- a/src/java/android/telephony/gsm/SmsManager.java
+++ b/src/java/android/telephony/gsm/SmsManager.java
@@ -76,7 +76,7 @@ private SmsManager() {
     public final void sendTextMessage(
             String destinationAddress, String scAddress, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent) {
-        android.util.SeempLog.record(94);
+        android.util.SeempLog.record_str(75, destinationAddress);
         mSmsMgrProxy.sendTextMessage(destinationAddress, scAddress, text,
                 sentIntent, deliveryIntent);
     }
@@ -129,7 +129,7 @@ public final void sendTextMessage(
     public final void sendMultipartTextMessage(
             String destinationAddress, String scAddress, ArrayList<String> parts,
             ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
-        android.util.SeempLog.record(96);
+        android.util.SeempLog.record_str(77, destinationAddress);
         mSmsMgrProxy.sendMultipartTextMessage(destinationAddress, scAddress, parts,
                 sentIntents, deliveryIntents);
     }
@@ -163,7 +163,7 @@ public final void sendMultipartTextMessage(
     public final void sendDataMessage(
             String destinationAddress, String scAddress, short destinationPort,
             byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
-        android.util.SeempLog.record(92);
+        android.util.SeempLog.record_str(73, destinationAddress);
         mSmsMgrProxy.sendDataMessage(destinationAddress, scAddress, destinationPort,
                 data, sentIntent, deliveryIntent);
     }
@@ -181,7 +181,7 @@ public final void sendDataMessage(
      */
     @Deprecated
     public final boolean copyMessageToSim(byte[] smsc, byte[] pdu, int status) {
-        android.util.SeempLog.record(101);
+        android.util.SeempLog.record(82);
         return mSmsMgrProxy.copyMessageToIcc(smsc, pdu, status);
     }
 
@@ -195,7 +195,7 @@ public final boolean copyMessageToSim(byte[] smsc, byte[] pdu, int status) {
      */
     @Deprecated
     public final boolean deleteMessageFromSim(int messageIndex) {
-        android.util.SeempLog.record(102);
+        android.util.SeempLog.record(83);
         return mSmsMgrProxy.deleteMessageFromIcc(messageIndex);
     }
 
@@ -213,7 +213,7 @@ public final boolean deleteMessageFromSim(int messageIndex) {
      */
     @Deprecated
     public final boolean updateMessageOnSim(int messageIndex, int newStatus, byte[] pdu) {
-        android.util.SeempLog.record(103);
+        android.util.SeempLog.record(84);
         return mSmsMgrProxy.updateMessageOnIcc(messageIndex, newStatus, pdu);
     }
 
@@ -225,7 +225,7 @@ public final boolean updateMessageOnSim(int messageIndex, int newStatus, byte[]
      */
     @Deprecated
     public final ArrayList<android.telephony.SmsMessage> getAllMessagesFromSim() {
-        android.util.SeempLog.record(104);
+        android.util.SeempLog.record(85);
         return android.telephony.SmsManager.getDefault().getAllMessagesFromIcc();
     }
 

From 13efc53b5fa48df404aa27abda927ed36466d3dc Mon Sep 17 00:00:00 2001
From: Fang Yunong <yunong@codeaurora.org>
Date: Wed, 13 May 2015 15:58:08 +0800
Subject: [PATCH 43/92] WEA: Add an field define for cellbroadcasd table

Add an field define for cellbroadcasd table

Change-Id: Iec8c75407f80f6e915e05c47797e1ec3f0fc29ee
---
 src/java/android/provider/Telephony.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/android/provider/Telephony.java b/src/java/android/provider/Telephony.java
index 94385d8c52..0fc49a11b8 100644
--- a/src/java/android/provider/Telephony.java
+++ b/src/java/android/provider/Telephony.java
@@ -2983,7 +2983,7 @@ private CellBroadcasts() {}
          * <P>Type: INTEGER</P>
          */
         public static final String SERVICE_CATEGORY = "service_category";
-
+        public static final String MESSAGE_DELETED = "flag_is_deleted";
         /**
          * Message language code.
          * <P>Type: TEXT</P>

From 514c79b5fe79eeda4d63066035dac03cf8af14a1 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Mon, 16 May 2016 15:28:40 -0700
Subject: [PATCH 44/92] Telephony: don't show unsupported transfer on IMS

Ims phone calls do not have an impl to support call transfers yet; do
not report that we support it.

Ticket: CYNGNOS-2760

Change-Id: I43e97c7d98d239e68204e0d58cafd82f38dd10e3
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java  | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 91e4e89a99..854c9d3c00 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -698,8 +698,10 @@ private void switchAfterConferenceSuccess() {
 
     boolean
     canTransfer() {
+        /** TODO: use checks when impl exists, see {@link #explicitCallTransfer()}
         return mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE
-            && mBackgroundCall.getState() == ImsPhoneCall.State.HOLDING;
+            && mBackgroundCall.getState() == ImsPhoneCall.State.HOLDING; **/
+        return false;
     }
 
     //***** Private Instance Methods

From a94ae667a6cefaef2f4c87787dafabdd5458f047 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Mon, 30 May 2016 15:01:03 -0700
Subject: [PATCH 45/92] DcTracker: use IMSI with APN lookup

Ticket: PAELLA-158
Change-Id: Id805a8ef16a1054dac0bd2b3f3b83a32d4502eea
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../android/internal/telephony/dataconnection/DcTracker.java   | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 7c1e8d8d14..9295b91137 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -135,6 +135,8 @@ public void onChange(boolean selfChange) {
 
     static final Uri PREFERAPN_NO_UPDATE_URI_USING_SUBID =
                         Uri.parse("content://telephony/carriers/preferapn_no_update/subId/");
+    static final Uri PREFERAPN_NO_UPDATE_URI_USING_SUBID_IMSI =
+            Uri.parse("content://telephony/carriers/preferapn_no_update/subIdImsi/");
     static final String APN_ID = "apn_id";
 
     /**
@@ -2762,7 +2764,9 @@ protected void setPreferredApn(int pos) {
         }
 
         String subId = Long.toString(mPhone.getSubId());
-        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        String imsi = mPhone.getSubscriberId();
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID_IMSI, subId);
+        uri = Uri.withAppendedPath(uri, imsi);
         log("setPreferredApn: delete");
         ContentResolver resolver = mPhone.getContext().getContentResolver();
         resolver.delete(uri, null, null);
@@ -2782,7 +2786,9 @@ protected ApnSetting getPreferredApn(ArrayList<ApnSetting> apnList) {
         }
 
         String subId = Long.toString(mPhone.getSubId());
-        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
+        String imsi = mPhone.getSubscriberId();
+        Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID_IMSI, subId);
+        uri = Uri.withAppendedPath(uri, imsi);
         Cursor cursor = mPhone.getContext().getContentResolver().query(
                 uri, new String[] { "_id", "name", "apn" },
                 null, null, Telephony.Carriers.DEFAULT_SORT_ORDER);

From 3718ef2d361bcfdce11546b734e740dbe55a7a51 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Mon, 20 Jun 2016 11:13:54 -0700
Subject: [PATCH 46/92] Telephony: handle 3rd party sms apps + 'always ask'

3rd party SMS apps may not be able to handle our always ask behavior, so
they may get stuck in a bad state. An example of this is Hangouts, which
just ends up never sending messages when always ask is selected.

TIcket: CYNGNOS-3068

Change-Id: I8a0f1f6bf7a5010438e40eb0be9aa178d2141f3c
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 src/java/com/android/internal/telephony/SmsApplication.java  | 12 ++++++++++++
 .../com/android/internal/telephony/UiccSmsController.java    |  7 ++++---
 2 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SmsApplication.java b/src/java/com/android/internal/telephony/SmsApplication.java
index 5a95394241..b269ed217f 100644
--- a/src/java/com/android/internal/telephony/SmsApplication.java
+++ b/src/java/com/android/internal/telephony/SmsApplication.java
@@ -38,6 +38,7 @@
 import android.telephony.Rlog;
 import android.telephony.SmsManager;
 import android.telephony.TelephonyManager;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.android.internal.content.PackageMonitor;
@@ -57,6 +58,7 @@
     private static final String BLUETOOTH_PACKAGE_NAME = "com.android.bluetooth";
     private static final String MMS_SERVICE_PACKAGE_NAME = "com.android.mms.service";
     private static final String TELEPHONY_PROVIDER_PACKAGE_NAME = "com.android.providers.telephony";
+    private static final String DEFAULT_SYSTEM_MMS_PACKAGE_NAME = "com.android.messaging";
 
     private static final String SCHEME_SMS = "sms";
     private static final String SCHEME_SMSTO = "smsto";
@@ -737,6 +739,16 @@ public static boolean isDefaultSmsApplication(Context context, String packageNam
         return false;
     }
 
+    /**
+     * @hide
+     */
+    public static boolean canSmsAppHandleAlwaysAsk(Context context) {
+        final ComponentName defaultMmsApplication = SmsApplication.getDefaultMmsApplication(context,
+                false);
+        return TextUtils.equals(DEFAULT_SYSTEM_MMS_PACKAGE_NAME,
+                defaultMmsApplication.getPackageName());
+    }
+
     private static String getDefaultSmsApplicationPackageName(Context context) {
         final ComponentName component = getDefaultSmsApplication(context, false);
         if (component != null) {
diff --git a/src/java/com/android/internal/telephony/UiccSmsController.java b/src/java/com/android/internal/telephony/UiccSmsController.java
index 7d17d441bf..f9777d329e 100644
--- a/src/java/com/android/internal/telephony/UiccSmsController.java
+++ b/src/java/com/android/internal/telephony/UiccSmsController.java
@@ -291,13 +291,14 @@ public boolean isImsSmsSupportedForSubscriber(int subId) {
 
     @Override
     public boolean isSmsSimPickActivityNeeded(int subId) {
-        if (!isSMSPromptEnabled()) {
+        final Context context = ActivityThread.currentApplication().getApplicationContext();
+        boolean canCurrentAppHandleAlwaysAsk = SmsApplication.canSmsAppHandleAlwaysAsk(context);
+        if (!isSMSPromptEnabled() && canCurrentAppHandleAlwaysAsk) {
             Rlog.d(LOG_TAG, "isSmsSimPickActivityNeeded: false, sms prompt disabled.");
             // user knows best
             return false;
         }
 
-        final Context context = ActivityThread.currentApplication().getApplicationContext();
         TelephonyManager telephonyManager =
                 (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
         List<SubscriptionInfo> subInfoList;
@@ -331,7 +332,7 @@ public boolean isSmsSimPickActivityNeeded(int subId) {
             }
         }
 
-        return false;
+        return !canCurrentAppHandleAlwaysAsk;
     }
 
     @Override

From 9354bf650fd3d0fbc3f4a4f8277e1ef1aaafeba6 Mon Sep 17 00:00:00 2001
From: Prasath Balakrishnan <bpras@codeaurora.org>
Date: Mon, 25 Jan 2016 14:04:05 +0530
Subject: [PATCH 47/92] Fix issue when two MMS requests with same priority on
 both SUB's

When executing MMS request on one SUB and a new MMS request
is received on other SUB. First execute the current request
before handling new request.

CRs-Fixed: 958989
Change-Id: I57fee028d9ac0e91d94eb70f8ea75c7fcb5f7087
---
 .../internal/telephony/dataconnection/DctController.java     | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index 0916335500..e1c8bace58 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -544,11 +544,23 @@ protected int getTopPriorityRequestPhoneId() {
         int priority = -1;
         int subId;
 
+        int activePhoneId = -1;
+        for (int i = 0; i < mDcSwitchStateMachine.length; i++) {
+            if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
+                activePhoneId = i;
+                break;
+            }
+        }
+
         for (RequestInfo requestInfo : mRequestInfos.values()) {
             logd("getTopPriorityRequestPhoneId requestInfo=" + requestInfo);
             if (requestInfo.priority > priority) {
                 priority = requestInfo.priority;
                 topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
+            } else if (priority == requestInfo.priority) {
+                if (requestInfo.executedPhoneId == activePhoneId) {
+                    topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
+                }
             }
         }
         if (TextUtils.isEmpty(topSubId)) {

From b3d90614fba215ed3d5e5407578d4f4af2d2fd2d Mon Sep 17 00:00:00 2001
From: Sooraj Sasindran <ssasin@codeaurora.org>
Date: Tue, 1 Mar 2016 10:20:18 -0800
Subject: [PATCH 48/92] Telephony Data: Introduce DataAllowed state

Currently Data Connection state transition from sending allow data
to attached state skipping data allowed state. This is incorrect
as first one is configuration and second is registration with network.
Adding new state to move to DataAllowed state once configuration is
updated correctly.

Change-Id: I57f4f78759ddb74dc3da0488a5c38241edbd41a1
CRs-Fixed: 962649
---
 .../dataconnection/DcSwitchStateMachine.java       | 50 +++++++++++++++++++++-
 1 file changed, 49 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
index a30b3a8e70..9ec9f058ea 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
@@ -56,6 +56,7 @@
     private IdleState mIdleState = new IdleState();
     private EmergencyState mEmergencyState = new EmergencyState();
     private AttachingState mAttachingState = new AttachingState();
+    private DataAllowedState mDataAllowedState = new DataAllowedState();
     private AttachedState mAttachedState = new AttachedState();
     private DetachingState mDetachingState = new DetachingState();
     private DefaultState mDefaultState = new DefaultState();
@@ -74,6 +75,7 @@ protected DcSwitchStateMachine(Phone phone, String name, int id) {
         addState(mIdleState, mDefaultState);
         addState(mEmergencyState, mDefaultState);
         addState(mAttachingState, mDefaultState);
+        addState(mDataAllowedState, mAttachingState);
         addState(mAttachedState, mDefaultState);
         addState(mDetachingState, mDefaultState);
         setInitialState(mIdleState);
@@ -312,6 +314,10 @@ public boolean processMessage(Message msg) {
                             if (dataState == ServiceState.STATE_IN_SERVICE) {
                                 logd("AttachingState: Already attached, move to ATTACHED state");
                                 transitionTo(mAttachedState);
+                            } else {
+                                logd("AttachingState: Received success on Data allowed, " +
+                                     "move to Data Allowed state");
+                                transitionTo(mDataAllowedState);
                             }
 
                         }
@@ -356,7 +362,9 @@ public boolean processMessage(Message msg) {
                         DctController.getInstance().releaseAllRequests(mId);
                     }
 
-                    transitionTo(mIdleState);
+                    // Wait for data allowed response to allow further
+                    // changes in DDS configuration.
+                    deferMessage(msg);
                     retVal = HANDLED;
                     break;
                 }
@@ -373,6 +381,46 @@ public boolean processMessage(Message msg) {
         }
     }
 
+    private class DataAllowedState extends State {
+        private int mCurrentAllowedSequence = 0;
+        @Override
+        public void enter() {
+            log("DataAllowedState: enter");
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            boolean retVal;
+
+            switch (msg.what) {
+                case DcSwitchAsyncChannel.REQ_DISCONNECT_ALL: {
+                    if (DBG) {
+                        log("DataAllowedState: REQ_DISCONNECT_ALL" );
+                    }
+                    final PhoneBase pb = (PhoneBase)((PhoneProxy)mPhone).getActivePhone();
+                    if (pb.mDcTracker.getAutoAttachOnCreation()) {
+                        // if AutoAttachOnCreation, then we may have executed requests
+                        // without ever actually getting to Attached, so release the request
+                        // here in that case.
+                        if (DBG) log("releasingAll due to autoAttach");
+                        DctController.getInstance().releaseAllRequests(mId);
+                    }
+                    transitionTo(mIdleState);
+                    retVal = HANDLED;
+                    break;
+                }
+                default:
+                    if (VDBG) {
+                        log("DataAllowedState: nothandled msg.what=0x" +
+                                Integer.toHexString(msg.what));
+                    }
+                    retVal = NOT_HANDLED;
+                    break;
+            }
+            return retVal;
+        }
+    }
+
     private class AttachedState extends State {
         @Override
         public void enter() {

From 90501cb1e0a6c51bc7c30565bec9889589d7e04a Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Wed, 22 Jun 2016 15:12:01 -0700
Subject: [PATCH 49/92] Subscription updater: don't turn data off if we've
 never set a deafult

In the case of an MSIM device that has only had 1 SIM and then you swap
the sim to another slot, the data will turn off, but it's the same SIM
and should not.

Change-Id: I77ed8c22663aa10d211e6f4de06b791c1a8f0971
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../com/android/internal/telephony/SubscriptionInfoUpdater.java     | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 9a27beba86..0b489a94f1 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -767,7 +767,11 @@ synchronized protected void updateSubscriptionInfoByIccId() {
                             Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION,
                             SubscriptionManager.INVALID_SUBSCRIPTION_ID);
 
-                    if (realStoredDataSub != SubscriptionManager.getDefaultDataSubId()) {
+                    if (realStoredDataSub != SubscriptionManager.INVALID_SUBSCRIPTION_ID &&
+                            realStoredDataSub != SubscriptionManager.getDefaultDataSubId()) {
+                        logd("switching data off; real stored sub: " + realStoredDataSub
+                                + ", and we think the default sub id is now: "
+                                + SubscriptionManager.getDefaultDataSubId());
                         PhoneFactory.getDefaultPhone().setDataEnabled(false);
                     }
 

From bee587bdaa465739a31ff34e9652e13a0fed613d Mon Sep 17 00:00:00 2001
From: Suresh Kumar Sugguna <sureshk@codeaurora.org>
Date: Fri, 16 Oct 2015 18:09:19 +0530
Subject: [PATCH 50/92] IMS: Explicit call transfer feature

Code changes to support IMS explicit call transfer feature.

Change-Id: I45547cfd0679ca6850a430579a48aee0b7ab6290
CRs-Fixed: 897726
---
 resources/res/values/config.xml                    |  3 +++
 .../codeaurora/ims/qtiims/IQtiImsInterface.aidl    | 13 +++++++++++
 .../ims/qtiims/IQtiImsInterfaceListener.aidl       | 11 +++++++++-
 .../qtiims/QtiImsInterfaceListenerBaseImpl.java    | 17 ++-------------
 .../ims/qtiims/QtiImsInterfaceUtils.java           | 25 ++++++++++++++++++++++
 5 files changed, 53 insertions(+), 16 deletions(-)

diff --git a/resources/res/values/config.xml b/resources/res/values/config.xml
index 4bb6822f4a..d36b3a3ee1 100644
--- a/resources/res/values/config.xml
+++ b/resources/res/values/config.xml
@@ -75,4 +75,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     <string name="data_conn_status_title"></string>
     <string name="user_authentication_failed"></string>
     <string name="service_not_subscribed"></string>
+
+    <!-- control to enable or disable call transfer feature -->
+    <bool name="config_enable_calltransfer_over_ims">false</bool>
 </resources>
diff --git a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
index 329b14060e..b582567d95 100644
--- a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
+++ b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
@@ -117,4 +117,17 @@ oneway interface IQtiImsInterface {
      */
     void registerForViceRefreshInfo(IQtiImsInterfaceListener listener);
 
+   /**
+     * sendCallTransferRequest
+     * Transfer an established call to given number or call id
+     *
+     * @param phoneId indicates the phone instance which triggered the request
+     * @param type is one of the values QTI_IMS_TRANSFER_TYPE_*, as defined in
+     *        <code>org.codeaurora.ims.qtiims.QtiImsInterfaceUtils.</code>
+     * @param number indicates the target number to transfer
+     * @param listener an IQtiImsInterfaceListener instance to indicate the response
+     * @return void
+     */
+    void sendCallTransferRequest(int phoneId, int type, String number,
+            IQtiImsInterfaceListener listener);
 }
diff --git a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
index 32d14020bf..7d43604aac 100644
--- a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
+++ b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
@@ -92,7 +92,7 @@ oneway interface IQtiImsInterfaceListener {
     /**
      * Notifies client the result of call deflect request
      *
-     * @param <result> is one of the values QTIIMS_REQUEST_*, as defined in
+     * @param <result> is one of the values QTI_IMS_REQUEST_*, as defined in
      *        <code>org.codeaurora.ims.qtiims.QtiImsInterfaceUtils.</code>
      * @return void.
      */
@@ -106,4 +106,13 @@ oneway interface IQtiImsInterfaceListener {
      * @return void.
      */
     void notifyRefreshViceInfo(in QtiViceInfo viceInfo);
+
+    /**
+     * Notifies client the result of call transfer request
+     *
+     * @param <result> is one of the values QTI_IMS_REQUEST_*, as defined in
+     *        <code>org.codeaurora.ims.qtiims.QtiImsInterfaceUtils.</code>
+     * @return void.
+     */
+    void receiveCallTransferResponse(int result);
 }
diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
index c93e2f9244..aa8b626a89 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
@@ -29,55 +29,42 @@
 
 package org.codeaurora.ims.qtiims;
 
-import android.telephony.Rlog;
-
 /**
  * This class contains default implementation for IQtiImsInterfaceListener.
  */
 public class QtiImsInterfaceListenerBaseImpl extends IQtiImsInterfaceListener.Stub {
 
-    private static String LOG_TAG = "QtiImsInterfaceListenerBaseImpl";
-
     @Override
     public void onSetCallForwardUncondTimer(int status) {
-        logUnexpectedQtiImsListenerCall("onSetCallForwardUncondTimer");
     }
 
     @Override
     public void onGetCallForwardUncondTimer(int startHour, int endHour, int startMinute,
             int endMinute, int reason, int status, String number, int service) {
-        logUnexpectedQtiImsListenerCall("onGetCallForwardUncondTimer");
     }
 
     @Override
     public void onUTReqFailed(int errCode, String errString) {
-        logUnexpectedQtiImsListenerCall("onUTReqFailed");
     }
 
     @Override
     public void onGetPacketCount(int status, long packetCount) {
-        logUnexpectedQtiImsListenerCall("onGetPacketCount");
     }
 
     @Override
     public void onGetPacketErrorCount(int status, long packetErrorCount) {
-        logUnexpectedQtiImsListenerCall("onGetPacketErrorCount");
     }
 
     @Override
     public void receiveCallDeflectResponse(int result) {
-        logUnexpectedQtiImsListenerCall("receiveCallDeflectResponse");
     }
 
     @Override
     public void notifyRefreshViceInfo(QtiViceInfo viceInfo) {
-        logUnexpectedQtiImsListenerCall("notifyRefreshViceInfo");
     }
 
-    private static void logUnexpectedQtiImsListenerCall(String name)
-    {
-        Rlog.e(LOG_TAG, "Error! " + name + "() in QtiImsInterfaceListener should not be " +
-                "called, Default Implementation.");
+    @Override
+    public void receiveCallTransferResponse(int result) {
     }
 }
 
diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
index de017dcd3e..fa639163d1 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
@@ -30,6 +30,8 @@
 package org.codeaurora.ims.qtiims;
 
 import android.content.ContentResolver;
+import android.content.Context;
+import com.android.internal.telephony.ConfigResourceUtil;
 
 /**
  * This class contains QtiImsInterface specific utiltity functions.
@@ -54,6 +56,20 @@
     public static final String QTI_IMS_CALL_RAT_EXTRA_KEY = "callRadioTech";
 
     /**
+     * Definitions for the call transfer type. For easier implementation,
+     * the transfer type is defined as a bit mask value.
+     */
+    //Value representing blind call transfer type
+    public static final int QTI_IMS_BLIND_TRANSFER = 0x01;
+    //Value representing assured call transfer type
+    public static final int QTI_IMS_ASSURED_TRANSFER = 0x02;
+    //Value representing consultative call transfer type
+    public static final int QTI_IMS_CONSULTATIVE_TRANSFER = 0x04;
+
+    /* Call transfer extra key */
+    public static final String QTI_IMS_TRANSFER_EXTRA_KEY = "transferType";
+
+    /**
      * Private constructor for QtiImsInterfaceUtils as we don't want to instantiate this class
      */
     private QtiImsInterfaceUtils() {
@@ -86,4 +102,13 @@ public static void setCallDeflectNumber(ContentResolver contentResolver, String
         android.provider.Settings.Global.putString(contentResolver,
                 QTI_IMS_CALL_DEFLECT_NUMBER, deflectNum);
     }
+
+    /***
+     * Checks if the IMS call transfer property is enabled or not.
+     * Returns true if enabled, or false otherwise.
+     */
+    public static boolean isCallTransferEnabled(Context context) {
+        ConfigResourceUtil mConfigResUtil = new ConfigResourceUtil();
+        return mConfigResUtil.getBooleanValue(context, "config_enable_calltransfer_over_ims");
+    }
 }

From 079b0b5f2f00c51ea5f768661442e70f376bc2e4 Mon Sep 17 00:00:00 2001
From: Anju Mathapati <anjucm@codeaurora.org>
Date: Wed, 10 Feb 2016 10:36:25 -0800
Subject: [PATCH 51/92] IMS: Interface change for VOPS and SSAC

Add a new api for clients to query vops and
ssac status

Change-Id: I9999f6bbe1954981e20212cfcbfe8a21cf80a35e
CRs-Fixed: 965993
---
 .../codeaurora/ims/qtiims/IQtiImsInterface.aidl    | 17 +++++++++++++++++
 .../ims/qtiims/IQtiImsInterfaceListener.aidl       | 22 ++++++++++++++++++++++
 .../qtiims/QtiImsInterfaceListenerBaseImpl.java    |  9 +++++++++
 .../ims/qtiims/QtiImsInterfaceUtils.java           | 18 ++++++++++++++++++
 4 files changed, 66 insertions(+)

diff --git a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
index b582567d95..3a81faf331 100644
--- a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
+++ b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterface.aidl
@@ -130,4 +130,21 @@ oneway interface IQtiImsInterface {
      */
     void sendCallTransferRequest(int phoneId, int type, String number,
             IQtiImsInterfaceListener listener);
+
+    /**
+     * Query Vops information
+     *
+     * @param listener an IQtiImsInterfaceListener instance to indicate the response
+     * @return void
+     */
+    void queryVopsStatus(IQtiImsInterfaceListener listener);
+
+   /**
+     * Query Ssac information
+     *
+     * @param listener an IQtiImsInterfaceListener instance to indicate the response
+     * @return void
+     */
+    void querySsacStatus(IQtiImsInterfaceListener listener);
+
 }
diff --git a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
index 7d43604aac..792bebc135 100644
--- a/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
+++ b/src/java/org/codeaurora/ims/qtiims/IQtiImsInterfaceListener.aidl
@@ -115,4 +115,26 @@ oneway interface IQtiImsInterfaceListener {
      * @return void.
      */
     void receiveCallTransferResponse(int result);
+
+    /**
+     * Notifies Vops value to the clients
+     *
+     * @param vopsStatus
+     *        if true  : Voice is supported on LTE
+     *        if false : Voice is not supported on LTE
+     * @return void.
+     */
+    void notifyVopsStatus(boolean vopsStatus);
+
+    /**
+     * Notifies Ssac value to the clients
+     *
+     * @param ssacStatusResponse
+     *        if true  : Access barring factor for voice calls is 0
+     *        if false : Access barring factor for voice calls is non-zero
+     *                   Range: 0 to 100. Value 100 is used when
+     *                   the UE goes to the LTE Connected state
+     * @return void.
+     */
+    void notifySsacStatus(boolean ssacStatusResponse);
 }
diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
index aa8b626a89..44d9835e8f 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceListenerBaseImpl.java
@@ -66,5 +66,14 @@ public void notifyRefreshViceInfo(QtiViceInfo viceInfo) {
     @Override
     public void receiveCallTransferResponse(int result) {
     }
+
+    @Override
+    public void notifyVopsStatus(boolean vopsStatus) {
+    }
+
+    @Override
+    public void notifySsacStatus(boolean ssacStatusResponse) {
+    }
+
 }
 
diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
index fa639163d1..637578f693 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
@@ -69,6 +69,24 @@
     /* Call transfer extra key */
     public static final String QTI_IMS_TRANSFER_EXTRA_KEY = "transferType";
 
+    /* Constants used for VOPS and SSAC feature */
+    // Intent action
+    public static final String ACTION_VOPS_SSAC_STATUS =
+            "org.codeaurora.VOIP_VOPS_SSAC_STATUS";
+    /* Intent extra
+     * if true  : Voice is supported on LTE
+     * if false : Voice is not supported on LTE
+     */
+    public static final String EXTRA_VOPS = "Vops";
+    /* Intent extra
+     * if true  : Access barring factor for voice calls is 0
+     * if false : Access barring factor for voice calls is non-zero
+     *            Range: 0 to 100. Value 100 is used when
+     *            the UE goes to the LTE Connected state
+     */
+    public static final String EXTRA_SSAC = "Ssac";
+
+
     /**
      * Private constructor for QtiImsInterfaceUtils as we don't want to instantiate this class
      */

From 9e3df8a9a770af78e068dd912e1f561a36772913 Mon Sep 17 00:00:00 2001
From: Omkar Kolangade <omkark@codeaurora.org>
Date: Wed, 24 Feb 2016 09:22:25 -0800
Subject: [PATCH 52/92] IMS: Encrypted Calling Extras Key Definition

Adding a key String that will be used to
1. Pack and unpack encryption status/preference,
   in the dial/start API.
2. Pack and unpack the encryption status in the
   ImsCallProfile's extras Bundle.

Change-Id: I29ba8f384d04acb4c9bab4730e50e9f9bc17f84e
CRs-Fixed: 978178
---
 src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
index 637578f693..ef1ab3d55d 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
@@ -87,6 +87,9 @@
     public static final String EXTRA_SSAC = "Ssac";
 
 
+    /* Call encryption status extra key. The value will be a boolean. */
+    public static final String QTI_IMS_CALL_ENCRYPTION_EXTRA_KEY = "CallEncryption";
+
     /**
      * Private constructor for QtiImsInterfaceUtils as we don't want to instantiate this class
      */

From 8e0b6eeafda163aa014a77ea4c75dc6d906b782a Mon Sep 17 00:00:00 2001
From: Muhammed Siju <msiju@codeaurora.org>
Date: Thu, 19 May 2016 14:28:43 +0530
Subject: [PATCH 53/92] IMS-VT: Remove unused QTI_IMS_CALL_RAT_EXTRA_KEY extra.

QTI_IMS_CALL_RAT_EXTRA_KEY is being replaced by
ImsCallProfile.EXTRA_CALL_RAT_TYPE.

Change-Id: I8e418fb1166783b35a65c010abec63e915781713
CRs-Fixed: 1000005
---
 src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
index ef1ab3d55d..e59420938a 100644
--- a/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
+++ b/src/java/org/codeaurora/ims/qtiims/QtiImsInterfaceUtils.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -52,9 +52,6 @@
     /* Default error value */
     public static final int QTI_IMS_REQUEST_ERROR = 1;
 
-    /* Call RAT extra key */
-    public static final String QTI_IMS_CALL_RAT_EXTRA_KEY = "callRadioTech";
-
     /**
      * Definitions for the call transfer type. For easier implementation,
      * the transfer type is defined as a bit mask value.

From 9122c16069c9368076ef710649a9a6cf53991816 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Wed, 22 Jun 2016 15:56:59 -0700
Subject: [PATCH 54/92] Ims: remove use of old nonexistant qti constant

Change-Id: I4668d4f810014ad317191c9dd37cd71b04bdb56a
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../com/android/internal/telephony/imsphone/ImsPhoneConnection.java | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index b8b9daa432..090c93ce89 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -911,14 +911,12 @@ public boolean updateWifiState() {
      */
     private void updateWifiStateFromExtras(Bundle extras) {
         // Google and Qualcomm have competing implementations
-        final String extraCompatType = extras.containsKey(ImsCallProfile.EXTRA_CALL_RAT_TYPE) ?
-            ImsCallProfile.EXTRA_CALL_RAT_TYPE : QtiImsInterfaceUtils.QTI_IMS_CALL_RAT_EXTRA_KEY;
-        if (extras.containsKey(extraCompatType)) {
+        if (extras.containsKey(ImsCallProfile.EXTRA_CALL_RAT_TYPE)) {
             // The RIL (sadly) sends us the EXTRA_CALL_RAT_TYPE as a string extra, rather than an
             // integer extra, so we need to parse it.
             int radioTechnology;
             try {
-                radioTechnology = Integer.parseInt(extras.getString(extraCompatType));
+                radioTechnology = Integer.parseInt(extras.getString(ImsCallProfile.EXTRA_CALL_RAT_TYPE));
             } catch (NumberFormatException nfe) {
                 radioTechnology = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
             }

From 44396d8e77244233e0673551e495dee4b2b0a2ac Mon Sep 17 00:00:00 2001
From: Neil Fuller <nfuller@google.com>
Date: Tue, 8 Dec 2015 11:04:46 +0000
Subject: [PATCH 55/92] Remove identifier that causes warnings under OpenJDK 8
 compiler

Bug: 24494019
Change-Id: Ifca3226d3de1c72cc24c6092e105b42b95408c18
---
 src/java/com/google/android/mms/pdu/EncodedStringValue.java | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/java/com/google/android/mms/pdu/EncodedStringValue.java b/src/java/com/google/android/mms/pdu/EncodedStringValue.java
index 83a1f81d97..1ada25912a 100644
--- a/src/java/com/google/android/mms/pdu/EncodedStringValue.java
+++ b/src/java/com/google/android/mms/pdu/EncodedStringValue.java
@@ -83,7 +83,7 @@ public EncodedStringValue(int charSet, String data) {
                 // or unsupported.
                 mData = data.getBytes(CharacterSets.MIMENAME_ISO_8859_1);
                 mCharacterSet = CharacterSets.ISO_8859_1;
-            } catch (UnsupportedEncodingException _) {
+            } catch (UnsupportedEncodingException e2) {
                 mData = data.getBytes(); // system default encoding
                 mCharacterSet = CharacterSets.ANY_CHARSET;
             }
@@ -166,7 +166,7 @@ public String getString()  {
                 try {
                     mCharacterSet = CharacterSets.ISO_8859_1;
                     return new String(mData, CharacterSets.MIMENAME_ISO_8859_1);
-                } catch (UnsupportedEncodingException _) {
+                } catch (UnsupportedEncodingException e2) {
                     mCharacterSet = CharacterSets.ANY_CHARSET;
                     return new String(mData); // system default encoding.
                 }
@@ -238,7 +238,7 @@ public Object clone() throws CloneNotSupportedException {
             try {
                 ret[i] = new EncodedStringValue(mCharacterSet,
                         temp[i].getBytes());
-            } catch (NullPointerException _) {
+            } catch (NullPointerException e) {
                 // Can't arrive here
                 return null;
             }

From a80e16fa05b4b5e04b7b96453a6f3e4d0ea3cbb9 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Fri, 1 Jul 2016 00:36:12 -0700
Subject: [PATCH 56/92] gsmsst: Protect against "null" string literals

 * Yes, this happens.

Change-Id: I81a5e1404f530bcdab2f3f44f30bbe489ccf9849
---
 .../android/internal/telephony/gsm/GsmServiceStateTracker.java   | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 9af0ac58db..6bb5cfaf2b 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -837,14 +837,17 @@ protected void handlePollStateResult (int what, AsyncResult ar) {
                             regState = Integer.parseInt(states[0]);
 
                             // states[3] (if present) is the current radio technology
-                            if (states.length >= 4 && states[3] != null) {
+                            if (states.length >= 4 && states[3] != null &&
+                                    !"null".equals(states[3])) {
                                 type = Integer.parseInt(states[3]);
                             }
                             if ((states.length >= 5 ) &&
-                                    (regState == ServiceState.RIL_REG_STATE_DENIED)) {
+                                    (regState == ServiceState.RIL_REG_STATE_DENIED) &&
+                                    !"null".equals(states[4])) {
                                 mNewReasonDataDenied = Integer.parseInt(states[4]);
                             }
-                            if (states.length >= 6) {
+                            if (states.length >= 6 && states[5] != null &&
+                                    !"null".equals(states[5])) {
                                 mNewMaxDataCalls = Integer.parseInt(states[5]);
                             }
                         } catch (NumberFormatException ex) {

From f567219cd29a672f1cfbff63e43303a1d2648b12 Mon Sep 17 00:00:00 2001
From: Sridhar Dubbaka <sdubbaka@codeaurora.org>
Date: Tue, 22 Sep 2015 22:13:39 +0530
Subject: [PATCH 57/92] Add channel 60 Cellboradcast support.

Add channel 60 Cellboradcast support.

Change-Id: I9790fc7f952b8f471b1446555b9b98fac8c9bee6
---
 src/java/com/android/internal/telephony/SubscriptionController.java | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 0020ea3cdd..2979a760ef 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -1783,6 +1783,7 @@ public void setSubscriptionProperty(int subId, String propKey, String propValue)
             case SubscriptionManager.CB_ALERT_SPEECH:
             case SubscriptionManager.CB_ETWS_TEST_ALERT:
             case SubscriptionManager.CB_CHANNEL_50_ALERT:
+            case SubscriptionManager.CB_CHANNEL_60_ALERT:
             case SubscriptionManager.CB_CMAS_TEST_ALERT:
             case SubscriptionManager.CB_OPT_OUT_DIALOG:
                 value.put(propKey, Integer.parseInt(propValue));
@@ -1879,6 +1880,7 @@ public String getSubscriptionProperty(int subId, String propKey, String callingP
                         case SubscriptionManager.CB_ALERT_SPEECH:
                         case SubscriptionManager.CB_ETWS_TEST_ALERT:
                         case SubscriptionManager.CB_CHANNEL_50_ALERT:
+                        case SubscriptionManager.CB_CHANNEL_60_ALERT:
                         case SubscriptionManager.CB_CMAS_TEST_ALERT:
                         case SubscriptionManager.CB_OPT_OUT_DIALOG:
                             resultValue = cursor.getInt(0) + "";

From 07d7e4536b6f1a15ee6263bfd656bb4afdcf2a18 Mon Sep 17 00:00:00 2001
From: Umashankar Godachi <umasha@codeaurora.org>
Date: Thu, 22 Oct 2015 12:02:20 +0530
Subject: [PATCH 58/92] Fix ADN records loading removing EFEXT1 dependency.

Currently if EFEXT1 file is not present on a card a
runtime exception is thrown, and ADN records are not
loaded.

Fix: Allow ADN records loading even if EFEXT1 file is
not present by not throwing runtime exception.
Also in AdnRecordCache, find the free EXT1 record and
pass it to updateEF method, inorder to add the contact
with number greater than 20 in size.

Change-Id: Ibce813f259a1b734c57d15b98d7ac98d7f553bb4
CRs-Fixed: 927889
---
 .../internal/telephony/uicc/AdnRecordCache.java    | 15 ++++----
 .../internal/telephony/uicc/AdnRecordLoader.java   | 41 +++++++++++-----------
 2 files changed, 30 insertions(+), 26 deletions(-)

diff --git a/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java b/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
index 3d3f855fce..f9c221bef4 100644
--- a/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
+++ b/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
@@ -156,10 +156,12 @@ private void sendErrorResponse(Message response, String errString) {
     /* Find the free EXT1 record in the EXT1 file */
     private int findFreeExtRec(int extensionEf) {
         int[] extRec = extRecList.get(extensionEf);
-        for (int i = 0; i  < extRec.length; i++) {
-            if (extRec[i] == 0) {
-                Rlog.d(LOG_TAG, "Free record found: " +(i+1));
-                return (i+1);
+        if (extRec != null) {
+            for (int i = 0; i < extRec.length; i++) {
+                if (extRec[i] == 0) {
+                    Rlog.d(LOG_TAG, "Free record found: " +(i+1));
+                    return (i+1);
+                }
             }
         }
 
@@ -333,7 +335,7 @@ private int updateAdnBySearchOnEf(boolean useLocalPb, int efid, AdnRecord oldAdn
         } else {
             mUserWriteResponse.put(efid, response);
             new AdnRecordLoader(mFh).updateEF(newAdn, efid, extensionEF,
-                    index, pin2,
+                    index, pin2, findFreeExtRec(extensionEF),
                     obtainMessage(EVENT_UPDATE_ADN_DONE, efid, index, newAdn));
         }
 
@@ -485,7 +487,8 @@ private void useLocalPb(boolean useLocalPb) {
                         mUsimPhoneBookManager.loadEfFilesFromUsim().set(index - 1, adn);
                     }
                     if (adn != null && adn.hasExtendedRecord()
-                            && adn.mExtRecord > 0) {
+                            && adn.mExtRecord > 0
+                            && extRecList.get(extensionEf) != null) {
                         extRecList.get(extensionEf)[adn.mExtRecord - 1] = 1;
                     }
                 }
diff --git a/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java b/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
index 638f0c94fc..a0c4b653c1 100755
--- a/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
+++ b/src/java/com/android/internal/telephony/uicc/AdnRecordLoader.java
@@ -43,7 +43,7 @@
     // For "load one"
     int mRecordNumber;
 
-    int mNumExtRec;
+    int mNumExtRec = -1;
 
     // for "load all"
     ArrayList<AdnRecord> mAdns; // only valid after EVENT_ADN_LOAD_ALL_DONE
@@ -208,7 +208,7 @@ private String getEFPath(int efid) {
     handleMessage(Message msg) {
         AsyncResult ar;
         byte data[];
-        int[] extRecord;
+        int[] extRecord = null;
         AdnRecord adn;
 
         try {
@@ -256,21 +256,20 @@ private String getEFPath(int efid) {
                     String path = (String)(ar.userObj);
 
                     if (ar.exception != null) {
-                        throw new RuntimeException("get EF record size failed",
-                                ar.exception);
-                    }
-
-                    int[] extRecordSize = (int[])ar.result;
-                    // extRecordSize is int[3] array
-                    // int[0]  is the record length
-                    // int[1]  is the total length of the EF file
-                    // int[2]  is the number of records in the EF file
-                    // So int[0] * int[2] = int[1]
-                    if (extRecordSize.length != 3) {
-                        throw new RuntimeException("get wrong EF record size format",
-                                ar.exception);
+                        Rlog.d(LOG_TAG, "Exception occured while fetching record size for EFEXT1");
+                    } else {
+                        int[] extRecordSize = (int[])ar.result;
+                        // extRecordSize is int[3] array
+                        // int[0]  is the record length
+                        // int[1]  is the total length of the EF file
+                        // int[2]  is the number of records in the EF file
+                        // So int[0] * int[2] = int[1]
+                        if (extRecordSize.length != 3) {
+                            throw new RuntimeException("get wrong EF record size format",
+                                    ar.exception);
+                        }
+                        mNumExtRec = extRecordSize[2]; //Number of EXT records.
                     }
-                    mNumExtRec = extRecordSize[2]; //Number of EXT records.
                     mPendingExtLoads = 1;
 
                     /* If we are loading from EF_ADN, specifically
@@ -377,12 +376,14 @@ private String getEFPath(int efid) {
                     mPendingExtLoads = 0;
 
                     // extRecord has the details of used/free EXT1 records.
-                    extRecord = new int[mNumExtRec];
-                    for (int i = 0; i < mNumExtRec; i++) {
-                        extRecord[i] = 0;
+                    if (mNumExtRec != -1) {
+                        extRecord = new int[mNumExtRec];
+                        for (int i = 0; i < mNumExtRec; i++) {
+                            extRecord[i] = 0;
+                        }
                     }
 
-                    for(int i = 0, s = datas.size() ; i < s ; i++) {
+                    for (int i = 0, s = datas.size() ; i < s ; i++) {
                         adn = new AdnRecord(mEf, 1 + i, datas.get(i));
                         mAdns.add(adn);
 

From 3139447fe6d7b569563b34c0f4a28188e5560a6d Mon Sep 17 00:00:00 2001
From: Umashankar Godachi <umasha@codeaurora.org>
Date: Thu, 8 Oct 2015 21:16:27 +0530
Subject: [PATCH 59/92] FR29338: Read SIM Contacts from EF-ADN if EF-PBR read
 failed.

Currently on a USIM UICC card, contacts are read from EF-PBR.
If EF-PBR file is absent or the read failed, no contacts displayed.
This requirement will add the support for reading SIM contacts from
EF-ADN, if EF-PBR read failed.

Fix: In IccPhoneBookInterfaceManager, while loading the records check
for EF-PBR present. If EF-PBR is absent, treat the card as 2g and
reload the records from EF-ADN.

Add code to check if EF-PBR is present in UsimPhoneBookManager.

Change-Id: I55ef0541789cd5958da26cd18b070a46d75d78b0
---
 .../internal/telephony/IccPhoneBookInterfaceManager.java  | 15 +++++++++++----
 .../internal/telephony/gsm/UsimPhoneBookManager.java      |  6 ++++++
 .../android/internal/telephony/uicc/AdnRecordCache.java   |  4 ++++
 3 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java b/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
index b495e61007..085c4e282e 100644
--- a/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
@@ -51,6 +51,7 @@
     protected final Object mLock = new Object();
     protected int mRecordSize[];
     protected boolean mSuccess;
+    private   boolean mForceAdnUsage = false;
     protected List<AdnRecord> mRecords;
 
 
@@ -139,6 +140,7 @@ public void dispose() {
         if (mRecords != null) {
             mRecords.clear();
         }
+        mForceAdnUsage = false;
     }
 
     public void updateIccRecords(IccRecords iccRecords) {
@@ -328,13 +330,13 @@ public boolean updateAdnRecordsWithContentValuesInEfBySearch(int efid, ContentVa
                     "Requires android.permission.READ_CONTACTS permission");
         }
 
-        efid = updateEfForIccType(efid);
-        if (DBG) logd("getAdnRecordsInEF: efid=" + efid);
-
         synchronized(mLock) {
             checkThread();
             AtomicBoolean status = new AtomicBoolean(false);
             Message response = mBaseHandler.obtainMessage(EVENT_LOAD_DONE, status);
+            efid = updateEfForIccType(efid);
+            if (DBG) logd("getAdnRecordsInEF: efid=" + efid);
+
             if (mAdnCache != null) {
                 mAdnCache.requestLoadAllAdnLike(efid,
                         mAdnCache.extensionEfForEf(efid), null, response);
@@ -342,6 +344,11 @@ public boolean updateAdnRecordsWithContentValuesInEfBySearch(int efid, ContentVa
             } else {
                 loge("Failure while trying to load from SIM due to uninitialised adncache");
             }
+            if (mRecords == null && efid == IccConstants.EF_PBR && !mAdnCache.isPbrPresent()) {
+                logd("getAdnRecordsInEF: Load from EF_ADN as pbr is not present");
+                mForceAdnUsage = true;
+                return getAdnRecordsInEf(IccConstants.EF_ADN);
+            }
         }
         return mRecords;
     }
@@ -383,7 +390,7 @@ protected void waitForResult(AtomicBoolean status) {
 
     private int updateEfForIccType(int efid) {
         // Check if we are trying to read ADN records
-        if (efid == IccConstants.EF_ADN) {
+        if (efid == IccConstants.EF_ADN && !mForceAdnUsage) {
             if (mPhone.getCurrentUiccAppType() == AppType.APPTYPE_USIM ||
                     mPhone.getCurrentUiccAppType() == AppType.APPTYPE_CSIM) {
                 return IccConstants.EF_PBR;
diff --git a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
index b18fdfde0e..444ac2d4a2 100644
--- a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
+++ b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
@@ -149,6 +149,10 @@ public void reset() {
         mRefreshCache = false;
     }
 
+    public boolean isPbrFilePresent() {
+        return mIsPbrPresent;
+    }
+
     public ArrayList<AdnRecord> loadEfFilesFromUsim() {
         synchronized (mLock) {
             if (!mPhoneBookRecords.isEmpty()) {
@@ -953,6 +957,8 @@ public void handleMessage(Message msg) {
                 ar = (AsyncResult) msg.obj;
                 if (ar.exception == null) {
                     createPbrFile((ArrayList<byte[]>) ar.result);
+                } else {
+                    mIsPbrPresent = false;
                 }
                 synchronized (mLock) {
                     mLock.notify();
diff --git a/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java b/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
index f9c221bef4..862368f85e 100644
--- a/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
+++ b/src/java/com/android/internal/telephony/uicc/AdnRecordCache.java
@@ -355,6 +355,10 @@ private void useLocalPb(boolean useLocalPb) {
                 useLocalPb ? mUsimLocalPhoneBookManager : mUsimGlobalPhoneBookManager;
     }
 
+    public boolean isPbrPresent() {
+        return (mUsimGlobalPhoneBookManager.isPbrFilePresent() ||
+                mUsimLocalPhoneBookManager.isPbrFilePresent());
+    }
 
     /**
      * Responds with exception (in response) if efid is not a known ADN-like

From 9a69cada259f987ba69757782c5d049113397a59 Mon Sep 17 00:00:00 2001
From: Wileen Chiu <wileenc@codeaurora.org>
Date: Fri, 6 Nov 2015 17:11:41 -0800
Subject: [PATCH 60/92] Check subid when querying network selection

- Manual network selection is not supported for all
global modes, and will automatically switch to automatic
for unsupported modes
- when checking if manual network selection is supported,
we do not check if the subid is active, and the default
network mode is used for DUMMY SUBIDs instead
- If the subid is not active, use the network mode
associated with the phone id instead

Change-Id: I955de159990fab59f7d48f4900c615580763417b
CRs-Fixed: 936605
---
 src/java/com/android/internal/telephony/gsm/GSMPhone.java | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 126c4d9ea0..accb4ee5af 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -38,6 +38,7 @@
 
 import com.android.internal.telephony.CallTracker;
 import com.android.internal.telephony.ConfigResourceUtil;
+import com.android.internal.telephony.PhoneFactory;
 
 import android.text.TextUtils;
 import android.telephony.Rlog;
@@ -1933,9 +1934,7 @@ public boolean isManualNetSelAllowed() {
         int nwMode = Phone.PREFERRED_NT_MODE;
         int subId = getSubId();
 
-        nwMode = android.provider.Settings.Global.getInt(mContext.getContentResolver(),
-                    android.provider.Settings.Global.PREFERRED_NETWORK_MODE + subId, nwMode);
-
+        nwMode = PhoneFactory.calculatePreferredNetworkType(mContext, subId);
         Rlog.d(LOG_TAG, "isManualNetSelAllowed in mode = " + nwMode);
         /*
          *  For multimode targets in global mode manual network

From 200c49557fd2f2c1452403858ab32ef6e41f77a8 Mon Sep 17 00:00:00 2001
From: David Ng <dave@codeaurora.org>
Date: Wed, 9 Dec 2015 22:06:47 -0800
Subject: [PATCH 61/92] Revert "updateSpnDisplay: When PLMN values are same for
 before & after SIM loading in."

This reverts commit e85f0481135dd33c0e3392e16796add80de44eeb.

Conflicts:
	src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java

Change-Id: I83054b1549e1a1c29cc56e17bdec1942cee546a9
---
 .../com/android/internal/telephony/cdma/CdmaServiceStateTracker.java | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 60950421ea..5b43eecec9 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -591,8 +591,6 @@ protected void updateSpnDisplay() {
         String plmn = mSS.getOperatorAlphaLong();
         boolean showPlmn = false;
 
-        showPlmn = plmn != null;
-
         int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
         int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
         if (subIds != null && subIds.length > 0) {
@@ -614,6 +612,7 @@ protected void updateSpnDisplay() {
             // would set showPlmn to true only if plmn was not empty, i.e. was not
             // null and not blank. But this would cause us to incorrectly display
             // "No Service". Now showPlmn is set to true for any non null string.
+            showPlmn = plmn != null;
             if (DBG) {
                 log(String.format("updateSpnDisplay: changed sending intent" +
                             " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
@@ -665,7 +664,7 @@ protected void handlePollStateResultMessage(int what, AsyncResult ar){
                 if (states.length > 0) {
                     try {
                         regState = Integer.parseInt(states[0]);
-
+    
                         // states[3] (if present) is the current radio technology
                         if (states.length >= 4 && states[3] != null) {
                             dataRadioTechnology = Integer.parseInt(states[3]);

From 2a2094e8f054e21d09193e69ddb4f2cb57a7dea2 Mon Sep 17 00:00:00 2001
From: Andalam Parthasarathi <andala@codeaurora.org>
Date: Mon, 23 Nov 2015 18:19:13 +0530
Subject: [PATCH 62/92] Telephony: Config values for other languages

Added config strings for spanish and portuguese
languages.

Change-Id: Ifef59f4fafec455c976ab684fb6f0aa440214275
CRs-Fixed: 943387
---
 resources/res/values-es-rUS/config.xml | 37 ++++++++++++++++++++++++++++++++++
 resources/res/values-pt-rPT/config.xml | 36 +++++++++++++++++++++++++++++++++
 2 files changed, 73 insertions(+)
 create mode 100644 resources/res/values-es-rUS/config.xml
 create mode 100644 resources/res/values-pt-rPT/config.xml

diff --git a/resources/res/values-es-rUS/config.xml b/resources/res/values-es-rUS/config.xml
new file mode 100644
index 0000000000..73df57c783
--- /dev/null
+++ b/resources/res/values-es-rUS/config.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2015, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<!-- These resources are around just to allow their values to be customized
+     for different hardware and product builds.  Do not translate. -->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- pdp data reject dialog string for cause 29 and 33 -->
+    <string name="data_conn_status_title" translatable="false"></string>
+    <string name="user_authentication_failed" translatable="false"></string>
+    <string name="service_not_subscribed" translatable="false"></string>
+</resources>
diff --git a/resources/res/values-pt-rPT/config.xml b/resources/res/values-pt-rPT/config.xml
new file mode 100644
index 0000000000..ac287f536e
--- /dev/null
+++ b/resources/res/values-pt-rPT/config.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2015, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<!-- These resources are around just to allow their values to be customized
+     for different hardware and product builds.  Do not translate. -->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- SDN related strings -->
+    <string name="sdn" translatable="false"></string>
+    <string name="summary_sdn" translatable="false"></string>
+</resources>

From fe0a2f2629ff6f7d3b61025513b7ad499b9b5e2e Mon Sep 17 00:00:00 2001
From: Richard LIU <richardl@codeaurora.org>
Date: Wed, 18 Nov 2015 19:32:52 +0800
Subject: [PATCH 63/92] Do not set "gsm.operator.idpstring" per phoneId

Do not set "gsm.operator.idpstring" per phoneId, otherwise
PhoneNumberUtils could not get the right value

Change-Id: I540846d9208f84ff48b6830d45c66abfb16a8a54
---
 .../com/android/internal/telephony/cdma/CdmaServiceStateTracker.java | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 5b43eecec9..1ebd7a72b0 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -1437,11 +1437,10 @@ protected void setOperatorIdd(String operatorNumeric) {
         String idd = mHbpcdUtils.getIddByMcc(
                 Integer.parseInt(operatorNumeric.substring(0,3)));
         if (idd != null && !idd.isEmpty()) {
-            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING,
-                     idd);
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
         } else {
             // use default "+", since we don't know the current IDP
-            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
+            SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
         }
     }
 

From 31cadbe401e8396b1acd82fd56ef65d08cf64db6 Mon Sep 17 00:00:00 2001
From: Sandeep Kunta <skunta@codeaurora.org>
Date: Tue, 9 Sep 2014 18:24:05 +0530
Subject: [PATCH 64/92] MSIM: Fix ECBM dialog issue in G+C

Fix ECBM dialog issue by setting ECM mode property value
 as single SIM instead of comma separation in MSIM.

Change-Id: I7bb3c169dc0e0216afbf773236e4d08fda33a0c0
CRs-Fixed: 732984
---
 src/java/com/android/internal/telephony/cdma/CDMAPhone.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 724b231ea4..dd6631cf26 100644
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -1174,7 +1174,7 @@ private void handleEnterEmergencyCallbackMode(Message msg) {
             mIsPhoneInEcmState = true;
             // notify change
             sendEmergencyCallbackModeChange();
-            setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "true");
+            super.setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "true");
 
             // Post this runnable so we will automatically exit
             // if no one invokes exitEmergencyCallbackMode() directly.
@@ -1202,7 +1202,7 @@ private void handleExitEmergencyCallbackMode(Message msg) {
         if (ar.exception == null) {
             if (mIsPhoneInEcmState) {
                 mIsPhoneInEcmState = false;
-                setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "false");
+                super.setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "false");
             }
             // send an Intent
             sendEmergencyCallbackModeChange();

From 35b357b911ebb9eac4ff4f3b003797b243cc25ac Mon Sep 17 00:00:00 2001
From: Sukanya Rajkhowa <srajkh@codeaurora.org>
Date: Fri, 18 Dec 2015 14:48:26 -0800
Subject: [PATCH 65/92] Setup data on new APNs only when APN changes

- If new records are loaded due to RAT change 1x->LTE or vice versa,
  connections need to be restarted
- If CDMA subscription change event is received, APN list needs to be
  created before setting up data call
- For all other cases, setup data connections if there is also a change
  in APN

CRs-Fixed: 960246

Change-Id: I5093f506daed8b8d5e8a1fd5220043d0cd55918c
---
 .../com/android/internal/telephony/dataconnection/DcTracker.java   | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 9295b91137..e1569ae8fd 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -2930,9 +2930,6 @@ public void handleMessage (Message msg) {
 
             case DctConstants.EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED: // fall thru
             case DctConstants.EVENT_DATA_RAT_CHANGED:
-                //May new Network allow setupData, so try it here
-                setupDataOnConnectableApns(Phone.REASON_NW_TYPE_CHANGED,
-                        RetryFailures.ONLY_ON_CHANGE);
                 // When data rat changes we might need to load different
                 // set of apns (example, LTE->1x)
                 if (onUpdateIcc()) {
@@ -2942,6 +2939,10 @@ public void handleMessage (Message msg) {
                     // If cdma subscription source changed to NV or data rat changed to cdma
                     // (while subscription source was NV) - we need to trigger NV ready
                     onNvReady();
+                } else {
+                    //May new Network allow setupData, so try it here
+                    setupDataOnConnectableApns(Phone.REASON_NW_TYPE_CHANGED,
+                            RetryFailures.ONLY_ON_CHANGE);
                 }
                 break;
 

From 28678cf38af0dd3d01f6e3df6db6b286ab11807b Mon Sep 17 00:00:00 2001
From: Benergy Meenan Ravuri <bravuri@codeaurora.org>
Date: Thu, 31 Dec 2015 17:37:17 +0530
Subject: [PATCH 66/92] IMS: Fix null pointer exception for call forwarding

Check if ICCrecords are present, before setting the call forwarding
flag in ICCrecrods.

Change-Id: I7fe632acd4a9b42caf8c8bf6fee7d2cd97c41102
CRs-Fixed: 955679
---
 src/java/com/android/internal/telephony/PhoneBase.java | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index ed169333a9..dc790d7984 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -1525,7 +1525,10 @@ private void setCallForwardingIndicatorInSharedPref(boolean enable) {
 
     public void setVoiceCallForwardingFlag(int line, boolean enable, String number) {
         setCallForwardingIndicatorInSharedPref(enable);
-        mIccRecords.get().setVoiceCallForwardingFlag(line, enable, number);
+        IccRecords r = mIccRecords.get();
+        if (r != null) {
+            r.setVoiceCallForwardingFlag(line, enable, number);
+        }
     }
 
     protected void setVoiceCallForwardingFlag(IccRecords r, int line, boolean enable,

From eec0d6166faae45bfd574d0887cdcfafe4eeca05 Mon Sep 17 00:00:00 2001
From: Suresh Kumar Sugguna <sureshk@codeaurora.org>
Date: Thu, 10 Dec 2015 22:14:10 +0530
Subject: [PATCH 67/92] IMS: Exit ECBM before dialing a pending non-emergency
 MO call

When the device is in Emergency CallBack Mode, then exit the
ECBM before dialing a pending non-emergency mobile originating call.

Change-Id: I7f24b9cadb83351965b00cf17be0fb061197ac43
CRs-Fixed: 948702
---
 .../telephony/imsphone/ImsPhoneCallTracker.java    | 46 ++++++++++++++++++++--
 1 file changed, 42 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 854c9d3c00..962f8ad6a0 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -161,6 +161,7 @@ public void onReceive(Context context, Intent intent) {
     private static final int EVENT_HANGUP_PENDINGMO = 18;
     private static final int EVENT_RESUME_BACKGROUND = 19;
     private static final int EVENT_DIAL_PENDINGMO = 20;
+    private static final int EVENT_EXIT_ECBM_BEFORE_PENDINGMO = 21;
 
     private static final int TIMEOUT_HANGUP_PENDINGMO = 500;
 
@@ -310,8 +311,7 @@ public void unregisterForVoiceCallEnded(Handler h) {
     synchronized Connection
     dial(String dialString, int clirMode, int videoState, Bundle intentExtras)
             throws CallStateException {
-        boolean isPhoneInEcmMode = SystemProperties.getBoolean(
-                TelephonyProperties.PROPERTY_INECM_MODE, false);
+        boolean isPhoneInEcmMode = isPhoneInEcbMode();
         boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(dialString);
 
         if (DBG) log("dial clirMode=" + clirMode);
@@ -1148,6 +1148,28 @@ private int getDisconnectCauseFromReasonInfo(ImsReasonInfo reasonInfo) {
     }
 
     /**
+     * @return true if the phone is in Emergency Callback mode, otherwise false
+     */
+    private boolean isPhoneInEcbMode() {
+        return SystemProperties.getBoolean(TelephonyProperties.PROPERTY_INECM_MODE, false);
+    }
+
+    /**
+     * Before dialing pending MO request, check for the Emergency Callback mode.
+     * If device is in Emergency callback mode, then exit the mode before dialing pending MO.
+     */
+    private void dialPendingMO() {
+        boolean isPhoneInEcmMode = isPhoneInEcbMode();
+        boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(
+                mPendingMO.getOrigDialString());
+        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
+            sendEmptyMessage(EVENT_DIAL_PENDINGMO);
+        } else {
+            sendEmptyMessage(EVENT_EXIT_ECBM_BEFORE_PENDINGMO);
+        }
+    }
+
+    /**
      * Listen to the IMS call state change
      */
     private ImsCall.Listener mImsCallListener = new ImsCall.Listener() {
@@ -1279,7 +1301,7 @@ public void onCallHeld(ImsCall imsCall) {
                         //only the first callback reaches here
                         //otherwise the oldState is already HOLDING
                         if (mPendingMO != null) {
-                            sendEmptyMessage(EVENT_DIAL_PENDINGMO);
+                            dialPendingMO();
                         }
 
                         // In this case there will be no call resumed, so we can assume that we
@@ -1301,7 +1323,7 @@ public void onCallHoldFailed(ImsCall imsCall, ImsReasonInfo reasonInfo) {
                 if (reasonInfo.getCode() == ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED) {
                     // disconnected while processing hold
                     if (mPendingMO != null) {
-                        sendEmptyMessage(EVENT_DIAL_PENDINGMO);
+                        dialPendingMO();
                     }
                 } else if (bgState == ImsPhoneCall.State.ACTIVE) {
                     mForegroundCall.switchWith(mBackgroundCall);
@@ -1768,6 +1790,22 @@ void notifySrvccState(Call.SrvccState state) {
                 mPendingIntentExtras = null;
                 break;
 
+            case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
+                if (mPendingMO != null) {
+                    //Send ECBM exit request
+                    try {
+                        getEcbmInterface().exitEmergencyCallbackMode();
+                        mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
+                        pendingCallClirMode = mClirMode;
+                        pendingCallInEcm = true;
+                    } catch (ImsException e) {
+                        e.printStackTrace();
+                        mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
+                        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
+                    }
+                }
+                break;
+
             case EVENT_EXIT_ECM_RESPONSE_CDMA:
                 // no matter the result, we still do the same here
                 if (pendingCallInEcm) {

From 8b4ba43ce0732e6fac4b95b028f999de713e0ed3 Mon Sep 17 00:00:00 2001
From: Huaibin Yang <huaibiny@codeaurora.org>
Date: Mon, 25 Jan 2016 13:49:06 -0800
Subject: [PATCH 68/92] Telephony: CDMA: allow MT SMS when in ECBM

Currently CDMA telephony ignores MT SMS when phone is in Emergency
Callback Mode (ECBM), so app layer won't be able to receive SMS. This
may not be desired when a carrier requires app to receive MT SMS in
ECBM. This change allows ECBM MT SMS from ril on telephony side.

CRs-Fixed: 948338
Change-Id: I43cd4fd97bdede931864ef29cfc65c7e0573c022
---
 .../internal/telephony/cdma/CdmaInboundSmsHandler.java  | 17 -----------------
 1 file changed, 17 deletions(-)

diff --git a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
index 8ef952be31..8139b0fe67 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
@@ -89,15 +89,6 @@ public static CdmaInboundSmsHandler makeInboundSmsHandler(Context context,
     }
 
     /**
-     * Return whether the device is in Emergency Call Mode (only for 3GPP2).
-     * @return true if the device is in ECM; false otherwise
-     */
-    private static boolean isInEmergencyCallMode() {
-        String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE, "false");
-        return "true".equals(inEcm);
-    }
-
-    /**
      * Return true if this handler is for 3GPP2 messages; false for 3GPP format.
      * @return true (3GPP2)
      */
@@ -113,10 +104,6 @@ protected boolean is3gpp2() {
      */
     @Override
     protected int dispatchMessageRadioSpecific(SmsMessageBase smsb) {
-        if (isInEmergencyCallMode()) {
-            return Activity.RESULT_OK;
-        }
-
         SmsMessage sms = (SmsMessage) smsb;
         boolean isBroadcastType = (SmsEnvelope.MESSAGE_TYPE_BROADCAST == sms.getMessageType());
 
@@ -207,10 +194,6 @@ protected int dispatchMessageRadioSpecific(SmsMessageBase smsb) {
      */
     @Override
     protected void acknowledgeLastIncomingSms(boolean success, int result, Message response) {
-        if (isInEmergencyCallMode()) {
-            return;
-        }
-
         int causeCode = resultToCause(result);
         mPhone.mCi.acknowledgeLastIncomingCdmaSms(success, causeCode, response);
 

From 1e4c0b0eeeb3d966c5da4e137b1af09568edc566 Mon Sep 17 00:00:00 2001
From: Wileen Chiu <wileenc@codeaurora.org>
Date: Mon, 22 Feb 2016 13:11:31 -0800
Subject: [PATCH 69/92] Send shutdown command to modem

- The shutdown command is not sent to
the modem for a graceful shutdown when
the modem is in offline state in which,
the RADIO_POWER off request is rejected
- Send the shutdown command as soon as
the device has been given a chance to
power down the radio

Change-Id: I2fc2eae04918f3927e93924f6ae7b3e19f920de2
CRs-Fixed: 977534
---
 .../com/android/internal/telephony/ServiceStateTracker.java   | 11 +++++++++++
 .../internal/telephony/cdma/CdmaServiceStateTracker.java      |  2 +-
 .../internal/telephony/gsm/GsmServiceStateTracker.java        |  2 +-
 3 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index 1c831f1266..f8ab9ad99e 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -185,6 +185,7 @@
     protected static final int EVENT_IMS_STATE_CHANGED                 = 46;
     protected static final int EVENT_IMS_STATE_DONE                    = 47;
     protected static final int EVENT_IMS_CAPABILITY_CHANGED            = 48;
+    protected static final int EVENT_RADIO_POWER_OFF_DONE                  = 49;
 
     protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
 
@@ -632,6 +633,16 @@ public void handleMessage(Message msg) {
                 }
                 break;
 
+            case EVENT_RADIO_POWER_OFF_DONE:
+                if (DBG) log("EVENT_RADIO_POWER_OFF_DONE");
+                if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
+                    // during shutdown the modem may not send radio state changed event
+                    // as a result of radio power request
+                    // Hence, issuing shut down regardless of radio power response
+                    mCi.requestShutdown(null);
+                }
+                break;
+
             default:
                 log("Unhandled message with number: " + msg.what);
                 break;
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 1ebd7a72b0..0c38e279d2 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -1994,7 +1994,7 @@ protected void hangupAndPowerOff() {
         mPhone.mCT.mRingingCall.hangupIfAlive();
         mPhone.mCT.mBackgroundCall.hangupIfAlive();
         mPhone.mCT.mForegroundCall.hangupIfAlive();
-        mCi.setRadioPower(false, null);
+        mCi.setRadioPower(false, obtainMessage(EVENT_RADIO_POWER_OFF_DONE));
     }
 
     protected void parseSidNid (String sidStr, String nidStr) {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 6bb5cfaf2b..531f393dd5 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -575,7 +575,7 @@ protected void hangupAndPowerOff() {
             mPhone.mCT.mForegroundCall.hangupIfAlive();
         }
 
-        mCi.setRadioPower(false, null);
+        mCi.setRadioPower(false, obtainMessage(EVENT_RADIO_POWER_OFF_DONE));
     }
 
     @Override

From 0dbab41dd234c211a7322e5a6f1a794580ecba44 Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Wed, 24 Feb 2016 21:04:51 +0530
Subject: [PATCH 70/92] Fix default data reset issue on device powerup

Subinfo null check is leading to default data call reset.
Replace it with sim state check.

Change-Id: I64c255c667e7ed667e004b361c0a68e507b30e5d
CRs-Fixed: 980485
---
 .../internal/telephony/dataconnection/DctController.java     | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index e1c8bace58..ea2b2f3859 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -32,7 +32,6 @@
 import android.os.Messenger;
 import android.provider.Settings;
 import android.telephony.Rlog;
-import android.telephony.SubscriptionInfo;
 import android.telephony.SubscriptionManager;
 import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
 import android.text.TextUtils;
@@ -45,6 +44,9 @@
 import com.android.internal.telephony.PhoneProxy;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.dataconnection.DcSwitchAsyncChannel.RequestInfo;
+import com.android.internal.telephony.uicc.IccCardStatus;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.IndentingPrintWriter;
 
@@ -578,12 +580,14 @@ protected int getTopPriorityRequestPhoneId() {
 
     private void onSubInfoReady() {
         logd("onSubInfoReady mPhoneNum=" + mPhoneNum);
+        UiccController uiccController = UiccController.getInstance();
         for (int i = 0; i < mPhoneNum; ++i) {
+            UiccCard card = uiccController.getUiccCard(i);
             int subId = mPhones[i].getSubId();
             logd("onSubInfoReady handle pending requests subId=" + subId);
-            SubscriptionInfo subInfo = mSubMgr.getActiveSubscriptionInfoForSimSlotIndex(i);
-            if (subInfo == null) {  // No sim in slot
-                logd("onSubInfoReady: subInfo = null");
+            if ((card == null) || (card.getCardState() ==
+                    IccCardStatus.CardState.CARDSTATE_ABSENT)) {
+                logd("onSubInfoReady: SIM card absent on phoneId = " + i);
                 PhoneBase phoneBase = (PhoneBase)mPhones[i].getActivePhone();
                 DcTrackerBase dcTracker = phoneBase.mDcTracker;
                 if (dcTracker.isApnTypeActive(PhoneConstants.APN_TYPE_DEFAULT)) {

From 7e642723d7bb97b4074f8f2962a51b38a7aa529b Mon Sep 17 00:00:00 2001
From: Yujing Gu <guy@codeaurora.org>
Date: Mon, 16 Nov 2015 17:45:52 +0800
Subject: [PATCH 71/92] Add the slot id when broadcasting card state to STK
 app.

Add the slot id when broadcasting card state to STK app.

Change-Id: Iad6df264a0223c5097a1983ae13911485a6d269e
---
 src/java/com/android/internal/telephony/cat/CatService.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index 9151c7572b..917da5b75c 100755
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -1005,8 +1005,9 @@ private void  broadcastCardStateAndIccRefreshResp(CardState cardState,
 
         // This sends an intent with CARD_ABSENT (0 - false) /CARD_PRESENT (1 - true).
         intent.putExtra(AppInterface.CARD_STATUS, cardPresent);
+        intent.putExtra("SLOT_ID", mSlotId);
         CatLog.d(this, "Sending Card Status: "
-                + cardState + " " + "cardPresent: " + cardPresent);
+                + cardState + " " + "cardPresent: " + cardPresent +  "SLOT_ID: " +  mSlotId);
         mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
     }
 

From 0f88ef6b7d8f96d7fae7b628d71b6aece8d586ba Mon Sep 17 00:00:00 2001
From: Muhammed Siju <msiju@codeaurora.org>
Date: Fri, 11 Mar 2016 13:26:23 +0530
Subject: [PATCH 72/92] Fix DDS switch issues for CDMA and IWLAN scenarios.

Maintain data allowed flags for each phone, based on the
current DDS switch scenerio. Ignore ATTACHed event in DcSSM
IdleState, if data is not allowed on that phone.
This helps to prevent unnecessary ALLOW_DATA(T) requests
when CDMA or IWLAN data registration is reported after PS
detach is initiated for the phone. It also helps to avoid
wrong DDS switch in case of race condition between PS detach
and data registration indication.

Change-Id: I4bb1923e39182dd3df80207fcd6841273c67d75c
CRs-Fixed: 986052
---
 .../dataconnection/DcSwitchStateMachine.java        |  4 +++-
 .../telephony/dataconnection/DctController.java     | 21 +++++++++++++++++++++
 2 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
index 9ec9f058ea..b16d0571a5 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
@@ -138,7 +138,7 @@ public boolean processMessage(Message msg) {
                         log("IdleState: EVENT_DATA_ATTACHED");
                     }
 
-                    if (ddsPhoneId == mId) {
+                    if (DctController.getInstance().isDataAllowedOnPhoneId(mId)) {
                         if (DBG) {
                             log("IdleState: DDS sub reported ATTACHed in IDLE state");
                         }
@@ -147,6 +147,8 @@ public boolean processMessage(Message msg) {
                          */
                         deferMessage(msg);
                         transitionTo(mAttachingState);
+                    } else {
+                        if (DBG) log("IdleState: ignore ATATCHed event as data is not allowed");
                     }
                     retVal = HANDLED;
                     break;
diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index ea2b2f3859..a20600cef3 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -53,6 +53,7 @@
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayDeque;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map.Entry;
@@ -94,6 +95,8 @@
 
     private SubscriptionManager mSubMgr;
 
+    protected AtomicBoolean[] mIsDataAllowed;
+
     private OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
             new OnSubscriptionsChangedListener() {
         @Override
@@ -234,9 +237,16 @@ protected DctController(PhoneProxy[] phones) {
         mNetworkFactoryMessenger = new Messenger[mPhoneNum];
         mNetworkFactory = new NetworkFactory[mPhoneNum];
         mNetworkFilter = new NetworkCapabilities[mPhoneNum];
+        mIsDataAllowed = new AtomicBoolean[mPhoneNum];
 
         for (int i = 0; i < mPhoneNum; ++i) {
             int phoneId = i;
+            if (mPhoneNum == 1) {
+                // For single SIM mode allow data by default
+                mIsDataAllowed[i] = new AtomicBoolean(true);
+            } else {
+                mIsDataAllowed[i] = new AtomicBoolean(false);
+            }
             mDcSwitchStateMachine[i] = new DcSwitchStateMachine(mPhones[i],
                     "DcSwitchStateMachine-" + phoneId, phoneId);
             mDcSwitchStateMachine[i].start();
@@ -849,6 +859,17 @@ public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
         }
     }
 
+    protected void setDataAllowedOnPhoneId(int phoneId, boolean dataAllowed) {
+        if (SubscriptionManager.isValidPhoneId(phoneId)) {
+            mIsDataAllowed[phoneId].set(dataAllowed);
+        }
+    }
+
+    public boolean isDataAllowedOnPhoneId(int phoneId) {
+        return SubscriptionManager.isValidPhoneId(phoneId) &&
+                mIsDataAllowed[phoneId].get();
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("DctController:");
         try {

From 8b477da8c8c30195b307303c392a857695ddc04e Mon Sep 17 00:00:00 2001
From: Suchand Ghosh <suchan@codeaurora.org>
Date: Mon, 21 Mar 2016 12:35:47 +0530
Subject: [PATCH 73/92] IMS: Fix phone app crash at
 setOutgoingCallerIdDisplay().

Phone process crash due to duplicate callback received at
GsmPhone when launch additional call settings and click on
Caller ID->Hide number.
Correct logic to receive messge EVENT_SET_CLIR_COMPLETE by
the requested phone (GsmPhone or ImsPhone), not by both.

Change-Id: Iec19577b7bf567c769089c40c05c656754b694ae
CRs-Fixed: 990931
---
 src/java/com/android/internal/telephony/gsm/GSMPhone.java | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index accb4ee5af..e2624dad14 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -1329,8 +1329,7 @@ public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode,
         ImsPhone imsPhone = mImsPhone;
         if ((imsPhone != null)
                 && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
-            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode,
-            obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
+            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
             return;
         }
         // Packing CLIR value in the message. This will be required for

From b3571da33cd77218deb382374bddb8a043f27383 Mon Sep 17 00:00:00 2001
From: Sandeep Gutta <sangutta@codeaurora.org>
Date: Thu, 31 Dec 2015 09:01:45 +0530
Subject: [PATCH 74/92] MSIM: Use SIM specific subId for setMccMnc

While updating MccMnc value use the subId corresponds
to the SIM slotId.

Change-Id: Ifd7295a264f48e1210d87cb83ac76f5ad46df356
CRs-Fixed: 956103
---
 src/java/com/android/internal/telephony/uicc/SIMRecords.java | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/uicc/SIMRecords.java b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
index 1ac262be0a..8b6f743955 100644
--- a/src/java/com/android/internal/telephony/uicc/SIMRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
@@ -1429,11 +1429,14 @@ protected void onAllRecordsLoaded() {
         if (!TextUtils.isEmpty(operator)) {
             log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" +
                     operator + "'");
-            log("update icc_operator_numeric=" + operator);
             mTelephonyManager.setSimOperatorNumericForPhone(
                     mParentApp.getPhoneId(), operator);
             final SubscriptionController subController = SubscriptionController.getInstance();
-            subController.setMccMnc(operator, subController.getDefaultSmsSubId());
+            int[] subId = subController.getSubId(mParentApp.getPhoneId());
+            if (subId != null && subId.length > 0) {
+                subController.setMccMnc(operator, subId[0]);
+                log("update icc_operator_numeric = " + operator + " subId = " + subId[0]);
+            }
         } else {
             log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
         }

From ce2ca072fee674bcf7e53ceb3367c8643869cee2 Mon Sep 17 00:00:00 2001
From: pengfeix <pengfeix@codeaurora.org>
Date: Tue, 12 Apr 2016 13:13:21 +0800
Subject: [PATCH 75/92] Finer grained character boundaries in computing SMS
 fragment lengths

The standard Java character iterator has potentially unbounded
distance between character boundaries, meaning that when
breaking an SMS message into fragments it's not safe to assume that
the fragment will contain such a boundary. This patch
special-cases flags (pairs of Regional Indicator Symbols) and also
guarantees some progress in the case of no boundary found.

Change-Id: I35990b44ad72887e1fdd436223808e18b04bd578
CRs-Fixed: 994916
---
 .../android/internal/telephony/SmsMessageBase.java  | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/SmsMessageBase.java b/src/java/com/android/internal/telephony/SmsMessageBase.java
index 0b8dfdfd7d..a4cc690b1b 100644
--- a/src/java/com/android/internal/telephony/SmsMessageBase.java
+++ b/src/java/com/android/internal/telephony/SmsMessageBase.java
@@ -352,6 +352,10 @@ protected void extractEmailAddressFromMessageBody() {
          mIsEmail = Telephony.Mms.isEmailAddress(mEmailFrom);
     }
 
+    //Returns true if the given code point is regional indicator symbol
+    private static boolean isRegionalIndicatorSymbol(int codepoint) {
+        return (0x1F1E6 <= codepoint && codepoint <= 0x1F1FF);
+    }
     /**
      * Find the next position to start a new fragment of a multipart SMS.
      *
@@ -370,7 +374,22 @@ public static int findNextUnicodePosition(
             BreakIterator breakIterator = BreakIterator.getCharacterInstance();
             breakIterator.setText(msgBody.toString());
             if (!breakIterator.isBoundary(nextPos)) {
-                nextPos = breakIterator.preceding(nextPos);
+                int breakPos = breakIterator.preceding(nextPos);
+                while (breakPos + 4 <= nextPos
+                    && isRegionalIndicatorSymbol(
+                     Character.codePointAt(msgBody, breakPos))
+                    && isRegionalIndicatorSymbol(
+                     Character.codePointAt(msgBody, breakPos + 2))) {
+                   // skip forward over flags (pairs of Regional Indicator Symbol)
+                   breakPos += 4;
+                }
+                if (breakPos > currentPosition) {
+                    nextPos = breakPos;
+                } else if (Character.isHighSurrogate(msgBody.charAt(nextPos - 1))) {
+                  // no character boundary in this fragment, try to at least land on a code point
+                    nextPos -= 1;
+                }
+
             }
         }
         return nextPos;

From cbaa8d31506c2843ae8c549bc3dff9743300c531 Mon Sep 17 00:00:00 2001
From: Yujing Gu <guy@codeaurora.org>
Date: Tue, 29 Mar 2016 17:27:25 +0800
Subject: [PATCH 76/92] Parse the record number from byte to int

ADN won't be retrieved correctly if the record number is more
than 127. Need to Parse the record number from byte to int.

Change-Id: I0b324c3a0ca0fff07609b84079541d2099b964cc
CRs-Fixed: 985649
---
 .../internal/telephony/gsm/UsimPhoneBookManager.java   | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
index 444ac2d4a2..d2e1d540e0 100644
--- a/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
+++ b/src/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
@@ -527,9 +527,9 @@ private void updatePhoneAdnRecordWithEmail(int pbrIndex) {
                     Rlog.e(LOG_TAG, "Error: Improper ICC card: No IAP record for ADN, continuing");
                     break;
                 }
-                int recNum = record[mEmailTagNumberInIap];
+                int recNum = record[mEmailTagNumberInIap] & 0xFF;
 
-                if (recNum > 0) {
+                if (recNum != 0xFF && recNum > 0) {
                     String[] emails = new String[1];
                     // SIM record numbers are 1 based
                     emails[0] = readEmailRecord(recNum - 1, pbrIndex, 0);
@@ -578,8 +578,8 @@ private void updatePhoneAdnRecordWithAnr(int pbrIndex) {
                     Rlog.e(LOG_TAG, "Error: Improper ICC card: No IAP record for ADN, continuing");
                     break;
                 }
-                int recNum = record[mAnrTagNumberInIap];
-                if (recNum > 0) {
+                int recNum = record[mAnrTagNumberInIap] & 0xFF;
+                if (recNum != 0xFF && recNum > 0) {
                     String[] anrs = new String[1];
                     // SIM record numbers are 1 based
                     anrs[0] = readAnrRecord(recNum - 1, pbrIndex, 0);
@@ -771,8 +771,9 @@ private int getEmailRecNumber(int adnRecIndex, int numRecs, String oldEmail) {
             } catch (IndexOutOfBoundsException e) {
                 Rlog.e(LOG_TAG, "IndexOutOfBoundsException in getEmailRecNumber");
             }
-            if (record != null && record[mEmailTagNumberInIap] > 0) {
-                recordNumber = record[mEmailTagNumberInIap];
+            if (record != null && (record[mEmailTagNumberInIap] & 0xFF) != 0xFF
+                && (record[mEmailTagNumberInIap] & 0xFF) > 0) {
+                recordNumber = record[mEmailTagNumberInIap] & 0xFF;
                 log(" getEmailRecNumber: record is " + IccUtils.bytesToHexString(record)
                         + ", the email recordNumber is :" + recordNumber);
                 return recordNumber;
@@ -812,8 +813,9 @@ private int getAnrRecNumber(int adnRecIndex, int numRecs, String oldAnr) {
             } catch (IndexOutOfBoundsException e) {
                 Rlog.e(LOG_TAG, "IndexOutOfBoundsException in getAnrRecNumber");
             }
-            if (record != null && record[mAnrTagNumberInIap] > 0) {
-                recordNumber = record[mAnrTagNumberInIap];
+            if (record != null && (record[mAnrTagNumberInIap] & 0xFF) != 0xFF
+                && (record[mAnrTagNumberInIap] & 0xFF) > 0) {
+                recordNumber = record[mAnrTagNumberInIap] & 0xFF;
                 log("getAnrRecNumber: recnum from iap is :" + recordNumber);
                 return recordNumber;
             } else {

From fea40e5c879a0173a8822e9d44c4810602ca58cb Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Wed, 6 Apr 2016 17:44:27 +0530
Subject: [PATCH 77/92] Fix ims pdn request issue

Make onSubInfoReady protected for inheritance

Change-Id: Ifa8763909cf4e0d636e73fbdd952e8ce2d4eec95
---
 .../com/android/internal/telephony/dataconnection/DctController.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index a20600cef3..1ab146d841 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -588,7 +588,7 @@ protected int getTopPriorityRequestPhoneId() {
         return phoneId;
     }
 
-    private void onSubInfoReady() {
+    protected void onSubInfoReady() {
         logd("onSubInfoReady mPhoneNum=" + mPhoneNum);
         UiccController uiccController = UiccController.getInstance();
         for (int i = 0; i < mPhoneNum; ++i) {

From b6d95be167664c9bc81bfbb0d1f487f2926cbf84 Mon Sep 17 00:00:00 2001
From: Ravindra <c_rthat@codeaurora.org>
Date: Thu, 7 Apr 2016 16:41:18 +0530
Subject: [PATCH 78/92] Fix to avoid unnecessary PS attach.

When data attach event is received in IDLE state send
PS attach only if the attached RAT is CDMA.

Change-Id: Id4b1b8267f7052101eaea115e49849b4a09cd694
CRs-Fixed: 995959 963959
---
 .../telephony/dataconnection/DcSwitchStateMachine.java        |  9 +++++++--
 .../internal/telephony/dataconnection/DctController.java      | 11 ++++++++++-
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
index b16d0571a5..ff9fd14f3c 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
@@ -145,8 +145,12 @@ public boolean processMessage(Message msg) {
                         /* Move to AttachingState and handle this ATTACH msg over there.
                          * This would ensure that Modem gets a ALLOW_DATA(true)
                          */
-                        deferMessage(msg);
-                        transitionTo(mAttachingState);
+                        if (ServiceState.isCdma(dataRat)) {
+                            deferMessage(msg);
+                            transitionTo(mAttachingState);
+                        } else {
+                            transitionTo(mAttachedState);
+                        }
                     } else {
                         if (DBG) log("IdleState: ignore ATATCHed event as data is not allowed");
                     }
@@ -251,6 +255,7 @@ private void doEnter() {
             final PhoneBase pb = (PhoneBase)((PhoneProxy)mPhone).getActivePhone();
             pb.mCi.setDataAllowed(true, obtainMessage(EVENT_DATA_ALLOWED,
                     ++mCurrentAllowedSequence, 0));
+            DctController.getInstance().resetDdsSwitchNeededFlag();
             // if we're on a carrier that unattaches us if we're idle for too long
             // (on wifi) and they won't re-attach until we poke them.  Poke them!
             // essentially react as Attached does here in Attaching.
diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index 1ab146d841..28262fcad5 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -96,6 +96,7 @@
     private SubscriptionManager mSubMgr;
 
     protected AtomicBoolean[] mIsDataAllowed;
+    protected AtomicBoolean mNeedsDdsSwitch = new AtomicBoolean(false);
 
     private OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
             new OnSubscriptionsChangedListener() {
@@ -530,7 +531,7 @@ private void deactivateDdsRequests() {
     protected void onSettingsChanged() {
         //Sub Selection
         int dataSubId = mSubController.getDefaultDataSubId();
-
+        mNeedsDdsSwitch.set(true);
         int activePhoneId = -1;
         for (int i=0; i<mDcSwitchStateMachine.length; i++) {
             if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
@@ -870,6 +871,14 @@ public boolean isDataAllowedOnPhoneId(int phoneId) {
                 mIsDataAllowed[phoneId].get();
     }
 
+    public boolean isDdsSwitchNeeded() {
+        return mNeedsDdsSwitch.get();
+    }
+
+    public void resetDdsSwitchNeededFlag() {
+        mNeedsDdsSwitch.set(false);
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("DctController:");
         try {

From a8208a51278a86fe62a5187d4a93c3e59f49b521 Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Wed, 23 Mar 2016 23:44:11 +0530
Subject: [PATCH 79/92] Fix Dds switch issue for wifi and IWLAN scenarios

In wifi on case, internet requests are released and there are
no oustanding requests to process, so user triggered Dds switch will
be blocked. Add a dummy network request to force Dds switch.

If IWLAN is reported on non dds sub, move state machine to Attached
state, to process any on demand network requests possible over IWLAN

Change-Id: I38a917906808511705eedb7d39534781759296cb
CRs-Fixed: 993272
---
 .../dataconnection/DcSwitchStateMachine.java       | 24 ++++++++++++++++++++--
 .../telephony/dataconnection/DctController.java    |  6 ++++++
 2 files changed, 28 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
index ff9fd14f3c..6caf20d928 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
@@ -138,7 +138,13 @@ public boolean processMessage(Message msg) {
                         log("IdleState: EVENT_DATA_ATTACHED");
                     }
 
-                    if (DctController.getInstance().isDataAllowedOnPhoneId(mId)) {
+                    int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
+                    if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+                        if (DBG) {
+                            log("IdleState: IWLAN reported in IDLE state");
+                        }
+                        transitionTo(mAttachedState);
+                    } else if (DctController.getInstance().isDataAllowedOnPhoneId(mId)) {
                         if (DBG) {
                             log("IdleState: DDS sub reported ATTACHed in IDLE state");
                         }
@@ -447,7 +453,21 @@ public boolean processMessage(Message msg) {
                     apnRequest.log("DcSwitchStateMachine.AttachedState: REQ_CONNECT");
                     if (DBG) log("AttachedState: REQ_CONNECT, apnRequest=" + apnRequest);
 
-                    DctController.getInstance().executeRequest(apnRequest);
+                    int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
+                    if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+                        SubscriptionController subController = SubscriptionController.getInstance();
+                        int ddsSubId = subController.getDefaultDataSubId();
+                        int ddsPhoneId = subController.getPhoneId(ddsSubId);
+                        if (mId == ddsPhoneId) {
+                            logd("AttachedState: Already attached on IWLAN. " +
+                                    "Retry Allow Data for Dds switch");
+                            transitionTo(mAttachingState);
+                        } else {
+                            DctController.getInstance().executeRequest(apnRequest);
+                        }
+                    } else {
+                        DctController.getInstance().executeRequest(apnRequest);
+                    }
                     retVal = HANDLED;
                     break;
                 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index 28262fcad5..fdc5145a00 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -570,6 +570,7 @@ protected int getTopPriorityRequestPhoneId() {
             if (requestInfo.priority > priority) {
                 priority = requestInfo.priority;
                 topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
+                retRequestInfo = requestInfo;
             } else if (priority == requestInfo.priority) {
                 if (requestInfo.executedPhoneId == activePhoneId) {
                     topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
@@ -580,6 +581,11 @@ protected int getTopPriorityRequestPhoneId() {
             subId = mSubController.getDefaultDataSubId();
         } else {
             subId = Integer.parseInt(topSubId);
+            if (apnForNetworkRequest(retRequestInfo.request).equals(
+                    PhoneConstants.APN_TYPE_IMS) && mNeedsDdsSwitch.get()) {
+                logd("getTopPriorityRequestPhoneId: ims request, use dds phone id");
+                subId = mSubController.getDefaultDataSubId();
+            }
         }
         final int phoneId = mSubController.getPhoneId(subId);
         if (phoneId == DEFAULT_PHONE_INDEX) {

From e93e6b5ade17936021e5ef69f4bd82c44cb701b8 Mon Sep 17 00:00:00 2001
From: Dheeraj Shetty <dshetty@codeaurora.org>
Date: Wed, 13 Apr 2016 20:55:54 -0700
Subject: [PATCH 80/92] Use EVS codec for HD if carrier supports it.

If the audio codec is EVS_WB, EVS_NWB or EVS_FB and the carrier
config to use HD for EVS codec is set to true, then set HD to true.

Change-Id: I5550e6c9660c0ccd25418a33c44ee2c71ddd47b9
CRs-fixed: 986961
---
 .../telephony/imsphone/ImsPhoneConnection.java     | 43 +++++++++++++++++++---
 1 file changed, 38 insertions(+), 5 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index 090c93ce89..089cd5705f 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -986,8 +986,10 @@ private static boolean areBundlesEqual(Bundle extras, Bundle newExtras) {
 
     /**
      * Determines the {@link ImsPhoneConnection} audio quality based on the local and remote
-     * {@link ImsCallProfile}. If indicate a HQ audio call if the local stream profile
-     * indicates AMR_WB or EVRC_WB and there is no remote restrict cause.
+     * {@link ImsCallProfile}. Indicate a HD audio call if the local stream profile
+     * is AMR_WB, EVRC_WB, EVS_WB, EVS_SWB, EVS_FB (EVS codec is considered only if the
+     * operator supports HD on EVS) and
+     * there is no remote restrict cause.
      *
      * @param localCallProfile The local call profile.
      * @param remoteCallProfile The remote call profile.
@@ -1000,15 +1002,47 @@ private int getAudioQualityFromCallProfile(
             return AUDIO_QUALITY_STANDARD;
         }
 
-        boolean isHighDef = (localCallProfile.mMediaProfile.mAudioQuality
+        final boolean isEvsCodecHighDef = getBooleanCarrierConfig(mOwner.mPhone.getContext(),
+                CarrierConfigManager.KEY_IMS_SUPPORT_EVS_HD_ICON_BOOL) &&
+                (localCallProfile.mMediaProfile.mAudioQuality
+                         == ImsStreamMediaProfile.AUDIO_QUALITY_EVS_WB
+                || localCallProfile.mMediaProfile.mAudioQuality
+                         == ImsStreamMediaProfile.AUDIO_QUALITY_EVS_SWB
+                || localCallProfile.mMediaProfile.mAudioQuality
+                         == ImsStreamMediaProfile.AUDIO_QUALITY_EVS_FB);
+
+        final boolean isHighDef = (localCallProfile.mMediaProfile.mAudioQuality
                         == ImsStreamMediaProfile.AUDIO_QUALITY_AMR_WB
                 || localCallProfile.mMediaProfile.mAudioQuality
-                        == ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_WB)
+                        == ImsStreamMediaProfile.AUDIO_QUALITY_EVRC_WB
+                || isEvsCodecHighDef)
                 && remoteCallProfile.mRestrictCause == ImsCallProfile.CALL_RESTRICT_CAUSE_NONE;
         return isHighDef ? AUDIO_QUALITY_HIGH_DEFINITION : AUDIO_QUALITY_STANDARD;
     }
 
     /**
+     * Get the boolean config from carrier config manager.
+     *
+     * @param context the context to get carrier service
+     * @param key config key defined in CarrierConfigManager
+     * @return boolean value of corresponding key.
+     */
+    private boolean getBooleanCarrierConfig(Context context, String key) {
+        CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(
+                Context.CARRIER_CONFIG_SERVICE);
+        PersistableBundle b = null;
+        if (configManager != null) {
+            b = configManager.getConfig();
+        }
+        if (b != null) {
+            return b.getBoolean(key);
+        } else {
+            // Return static default defined in CarrierConfigManager.
+            return CarrierConfigManager.getDefaultConfig().getBoolean(key);
+        }
+    }
+
+    /**
      * Provides a string representation of the {@link ImsPhoneConnection}.  Primarily intended for
      * use in log statements.
      *
@@ -1039,4 +1073,3 @@ protected boolean isEmergency() {
         return mIsEmergency;
     }
 }
-

From a9d7209ff06367252fdd827f4bac051c1a38ffb3 Mon Sep 17 00:00:00 2001
From: Ravindra Thattahalli Javaraiah <c_rthat@codeaurora.org>
Date: Tue, 8 Dec 2015 18:35:17 +0530
Subject: [PATCH 81/92] Notify disconnect on phone dispose

While disposing a phone object if there are any active connections then
notify disconnect to the registrants to update the ui.

Change-Id: I74a3d5c9e3919083a786df43053b2b70ad9deb15
CRs-Fixed: 954722
---
 src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java | 6 ++++++
 src/java/com/android/internal/telephony/gsm/GsmCallTracker.java   | 6 ++++++
 2 files changed, 12 insertions(+)

diff --git a/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
index b3ab17b8c2..f10ecb1db0 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaCallTracker.java
@@ -1022,6 +1022,12 @@ private void handleCallWaitingInfo (CdmaCallWaitingNotification cw) {
 
         if (!mPhone.mIsTheCurrentActivePhone) {
             Rlog.w(LOG_TAG, "Ignoring events received on inactive CdmaPhone");
+            for (int i = 0; i < mConnections.length; i++) {
+                CdmaConnection conn = mConnections[i];
+                if ((conn != null) && (conn.mCause != DisconnectCause.NOT_DISCONNECTED)) {
+                    conn.onDisconnect(conn.mCause);
+                }
+            }
             return;
         }
         switch (msg.what) {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
index 185664204d..0601002da1 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmCallTracker.java
@@ -913,6 +913,12 @@ GsmConnection getConnectionByIndex(GsmCall call, int index)
         if (!mPhone.mIsTheCurrentActivePhone) {
             Rlog.e(LOG_TAG, "Received message " + msg +
                     "[" + msg.what + "] while being destroyed. Ignoring.");
+            for (int i = 0; i < mConnections.length; i++) {
+                GsmConnection conn = mConnections[i];
+                if ((conn != null) && (conn.mCause != DisconnectCause.NOT_DISCONNECTED)) {
+                    conn.onDisconnect(conn.mCause);
+                }
+            }
             return;
         }
         switch (msg.what) {

From 4a6e7c5d98a223cb5642107a011413d4e101c18b Mon Sep 17 00:00:00 2001
From: Ravindra <c_rthat@codeaurora.org>
Date: Mon, 14 Mar 2016 16:29:35 +0530
Subject: [PATCH 82/92] Fix to resolve data call issue for sim hot swap case

Update the setting for MOBILE_DATA irrespective of mUserDataEnabled
memeber varible because there are scenarios where the value of this
variable will be true for dummy subId which prevents updating the
actual value to data base.

Change-Id: I3324703c6c1df76a3b5ffc505ea8239d2c1c9bad
CRs-Fixed: 990158
---
 .../internal/telephony/dataconnection/DcTrackerBase.java | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index 8137ff896e..67d3a18cb0 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -1385,16 +1385,16 @@ protected void onSetUserDataEnabled(boolean enabled) {
 
     protected void onSetUserDataEnabled(boolean enabled, int subId) {
         synchronized (mDataEnabledLock) {
+            // For single SIM phones, this is a per phone property.
+            if (TelephonyManager.getDefault().getSimCount() == 1) {
+                Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
+            } else {
+                Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + subId,
+                        enabled ? 1 : 0);
+            }
+
             if (mUserDataEnabled != enabled) {
                 mUserDataEnabled = enabled;
-
-                // For single SIM phones, this is a per phone property.
-                if (TelephonyManager.getDefault().getSimCount() == 1) {
-                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
-                } else {
-                    Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + subId,
-                            enabled ? 1 : 0);
-                }
                 if (getDataOnRoamingEnabled() == false &&
                         mPhone.getServiceState().getDataRoaming() == true) {
                     if (enabled) {

From 09ca1bb16eabefb09dc50d94ff00463f6ed79fa0 Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Thu, 7 Apr 2016 13:11:07 +0530
Subject: [PATCH 83/92] Fix ims pdn issue on non dds sub on iwlan

Set Dds flag if top sub id doesnt match dds sub id.
Allow Dds switch in iwlan, only if dds flag is set.

Change-Id: I39695cf11b27fcffe222620ce0ea0ac046bc9683
CRs-Fixed: 998685
---
 .../internal/telephony/dataconnection/DcSwitchStateMachine.java        | 3 ++-
 .../com/android/internal/telephony/dataconnection/DctController.java   | 3 +++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
index 6caf20d928..12d2c03232 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcSwitchStateMachine.java
@@ -454,7 +454,8 @@ public boolean processMessage(Message msg) {
                     if (DBG) log("AttachedState: REQ_CONNECT, apnRequest=" + apnRequest);
 
                     int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
-                    if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+                    if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN &&
+                             DctController.getInstance().isDdsSwitchNeeded()) {
                         SubscriptionController subController = SubscriptionController.getInstance();
                         int ddsSubId = subController.getDefaultDataSubId();
                         int ddsPhoneId = subController.getPhoneId(ddsSubId);
diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index fdc5145a00..6d86afe890 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -585,6 +585,9 @@ protected int getTopPriorityRequestPhoneId() {
                     PhoneConstants.APN_TYPE_IMS) && mNeedsDdsSwitch.get()) {
                 logd("getTopPriorityRequestPhoneId: ims request, use dds phone id");
                 subId = mSubController.getDefaultDataSubId();
+            } else if (subId != mSubController.getDefaultDataSubId()) {
+                logd("getTopPriorityRequestPhoneId: Request needs Dds switch");
+                mNeedsDdsSwitch.set(true);
             }
         }
         final int phoneId = mSubController.getPhoneId(subId);

From 4cc7ede0602603151de740ba042f91cb0923f6b5 Mon Sep 17 00:00:00 2001
From: Susheel nyamala <snyamala@codeaurora.org>
Date: Mon, 1 Feb 2016 19:09:08 +0530
Subject: [PATCH 84/92] Fix emergency ims pdn setup issue

Add network capability EIMS for emergency apn type

Change-Id: I6ddc23c656fb2fc8e208f093879a2b5b1bc9f701
CRs-Fixed: 984318
---
 .../com/android/internal/telephony/dataconnection/DataConnection.java | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
index 2e7288418c..edc58afc26 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
@@ -990,6 +990,10 @@ private NetworkCapabilities makeNetworkCapabilities() {
                         result.addCapability(NetworkCapabilities.NET_CAPABILITY_IA);
                         break;
                     }
+                    case PhoneConstants.APN_TYPE_EMERGENCY: {
+                        result.addCapability(NetworkCapabilities.NET_CAPABILITY_EIMS);
+                        break;
+                    }
                     default:
                 }
             }

From 83ffc486fd82310e0f010c873951a8192dd653b8 Mon Sep 17 00:00:00 2001
From: Yashdev Singh <yashdevs@codeaurora.org>
Date: Wed, 27 Apr 2016 14:56:11 -0700
Subject: [PATCH 85/92] Telephony: Reduce back to back same APN activation
 delay.

- The default delay to activate same APN in quick succession is
  20 seconds.
- Some application like embms may want to activate APN quickly
  in short burst. Current 20 seconds would result in artificial
  delays in such applications.
- Hence changing the default delay value to be equivalent of
  fail-fast delay which is 3 seconds.

Change-Id: I792c9697e8ff2d90ec0e9bf2fda8ccf1b3dd9074
---
 .../com/android/internal/telephony/dataconnection/DcTrackerBase.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index 67d3a18cb0..febed595f8 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -97,7 +97,7 @@
 
     /** Delay between APN attempts.
         Note the property override mechanism is there just for testing purpose only. */
-    protected static final int APN_DELAY_DEFAULT_MILLIS = 20000;
+    protected static final int APN_DELAY_DEFAULT_MILLIS = 3000;
 
     /** Delay between APN attempts when in fail fast mode */
     protected static final int APN_FAIL_FAST_DELAY_DEFAULT_MILLIS = 3000;

From 3e12eb4dbb2323bb50ca9c6595b2520e16598e1e Mon Sep 17 00:00:00 2001
From: Umashankar Godachi <umasha@codeaurora.org>
Date: Mon, 18 Apr 2016 19:58:07 +0530
Subject: [PATCH 86/92] Set additional info for LaunchBrowser error case.

A recent change in 3GPP TS 31.124 27.22.4.26 spec for
LAUNCH BROWSER SEQ 1.6. expects an additional info
'Default URL unavailable' incase where default url
is not set.

Fix: In CatService, while handling the Launch Browser
error response include the additonal info 'Default
URL unavailable'.

3GPP Ref link:
http://www.etsi.org/deliver/etsi_ts/131100_131199/131124/
13.02.00_60/ts_131124v130200p.pdf

Change-Id: Idb80c1b8f36749a0ad6e5d53c7a4ac693917d884
CRs-Fixed: 1002699
---
 src/java/com/android/internal/telephony/cat/CatService.java | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index 917da5b75c..ec23bd9c44 100755
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -1130,6 +1130,13 @@ private void handleCmdResponse(CatResponseMessage resMsg) {
                 }
                 break;
             case LAUNCH_BROWSER:
+                if (resMsg.mResCode == ResultCode.LAUNCH_BROWSER_ERROR) {
+                    // Additional info for Default URL unavailable.
+                    resMsg.setAdditionalInfo(0x04);
+                } else {
+                    resMsg.mIncludeAdditionalInfo = false;
+                    resMsg.mAdditionalInfo = 0;
+                }
                 break;
             // 3GPP TS.102.223: Open Channel alpha confirmation should not send TR
             case OPEN_CHANNEL:

From 8ea51be3ad25c0b507db031db0147155272130ce Mon Sep 17 00:00:00 2001
From: Sandeep Gutta <sangutta@codeaurora.org>
Date: Mon, 4 Apr 2016 12:23:57 +0530
Subject: [PATCH 87/92] MSIM: Send FINISH request on flex map START fail

When flex map START request fails
send FINISH with failure status.

- While sending FINISH pass new RAF/modem Uuid
 if overall request is success.

- Treat null radio capability response received for
 phase finish due to SSR as valid.

Change-Id: Iad23b8a0d72430bc22e3b7f8c576370cbb4eae5f
CRs-Fixed: 1001601
---
 .../com/android/internal/telephony/ProxyController.java     | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/ProxyController.java b/src/java/com/android/internal/telephony/ProxyController.java
index b39c37d246..5c1823ab15 100644
--- a/src/java/com/android/internal/telephony/ProxyController.java
+++ b/src/java/com/android/internal/telephony/ProxyController.java
@@ -361,7 +361,10 @@ public void handleMessage(Message msg) {
     private void onStartRadioCapabilityResponse(Message msg) {
         synchronized (mSetRadioAccessFamilyStatus) {
             AsyncResult ar = (AsyncResult)msg.obj;
-            if (ar.exception != null) {
+            // Abort here only in Single SIM case, in Multi SIM cases
+            // send FINISH with failure so that below layers can do
+            // fall back to proper states.
+            if ((TelephonyManager.getDefault().getPhoneCount() == 1) && (ar.exception != null)) {
                 // just abort now.  They didn't take our start so we don't have to revert
                 logd("onStartRadioCapabilityResponse got exception=" + ar.exception);
                 mRadioCapabilitySessionId = mUniqueIdGenerator.getAndIncrement();
@@ -496,7 +499,7 @@ private void onNotificationRadioCapabilityChanged(Message msg) {
      */
     void onFinishRadioCapabilityResponse(Message msg) {
         RadioCapability rc = (RadioCapability) ((AsyncResult) msg.obj).result;
-        if ((rc == null) || (rc.getSession() != mRadioCapabilitySessionId)) {
+        if ((rc != null) && (rc.getSession() != mRadioCapabilitySessionId)) {
             logd("onFinishRadioCapabilityResponse: Ignore session=" + mRadioCapabilitySessionId
                     + " rc=" + rc);
             return;
@@ -545,8 +548,10 @@ private void issueFinish(int sessionId) {
                         i,
                         sessionId,
                         RadioCapability.RC_PHASE_FINISH,
-                        mOldRadioAccessFamily[i],
-                        mCurrentLogicalModemIds[i],
+                        (mTransactionFailed ? mOldRadioAccessFamily[i] :
+                        mNewRadioAccessFamily[i]),
+                        (mTransactionFailed ? mCurrentLogicalModemIds[i] :
+                        mNewLogicalModemIds[i]),
                         (mTransactionFailed ? RadioCapability.RC_STATUS_FAIL :
                         RadioCapability.RC_STATUS_SUCCESS),
                         EVENT_FINISH_RC_RESPONSE);

From c49c7446bcc3a074851862fc017de61931131739 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Fri, 1 Jul 2016 04:52:40 -0700
Subject: [PATCH 88/92] dct: Sync with upstream

Change-Id: I3193a98e61e3bef2e496b4caba476a219cbdf3d2
---
 .../telephony/dataconnection/DctController.java    | 72 +++++++++++-----------
 1 file changed, 35 insertions(+), 37 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index 6d86afe890..1a6024a2e0 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -406,7 +406,12 @@ protected void onProcessRequest() {
                 + ", activePhoneId=" + activePhoneId);
 
         if (requestedPhoneId == INVALID_PHONE_INDEX) {
-            // we have no network request - don't bother with this
+            // either we have no network request
+            // or there is no valid subscription at the moment
+            if (activePhoneId != INVALID_PHONE_INDEX) {
+                // detatch so we can try connecting later
+                mDcSwitchAsyncChannel[activePhoneId].disconnectAll();
+            }
             return;
         }
 
@@ -418,23 +423,6 @@ protected void onProcessRequest() {
                 if (requestInfo.executedPhoneId != INVALID_PHONE_INDEX) continue;
                 if (getRequestPhoneId(requestInfo.request) == requestedPhoneId) {
                     mDcSwitchAsyncChannel[requestedPhoneId].connect(requestInfo);
-                    Phone phone = mPhones[requestedPhoneId].getActivePhone();
-                    if ((phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA)
-                            && (activePhoneId == -1)) {
-                        /* Traditionally modem reports data registered on CDMA sub even when it is
-                         * non-dds because CDMA network does not have PS ATTACH/DETACH concept.
-                         *
-                         * So when CDMA sub becomes DDS from non-dds the state-machine is expacting
-                         * onDataConnectionAttach() call from serviceStateTracker. It would never
-                         * happen since cdma SST did not notice change in registration during DDS
-                         * switch.
-                         *
-                         * Hence we need to fake the ATTACH to move/progress DcSwitchStateMachine.
-                         */
-                        logd("Active phone is CDMA, fake ATTACH");
-                        mDcSwitchAsyncChannel[requestedPhoneId].notifyDataAttached();
-                    }
-
                 }
             }
         } else {
@@ -498,8 +486,7 @@ protected void onReleaseAllRequests(int phoneId) {
         Iterator<Integer> iterator = mRequestInfos.keySet().iterator();
         while (iterator.hasNext()) {
             RequestInfo requestInfo = mRequestInfos.get(iterator.next());
-            if ((requestInfo.executedPhoneId == phoneId)
-                || isWithOutSpecifier(requestInfo)) {
+            if (requestInfo.executedPhoneId == phoneId) {
                 onReleaseRequest(requestInfo);
             }
         }
@@ -509,7 +496,7 @@ private void onRetryAttach(int phoneId) {
         final int topPriPhone = getTopPriorityRequestPhoneId();
         logd("onRetryAttach phoneId=" + phoneId + " topPri phone = " + topPriPhone);
 
-        if (phoneId != INVALID_PHONE_INDEX && phoneId == topPriPhone) {
+        if (phoneId != -1 && phoneId == topPriPhone) {
             mDcSwitchAsyncChannel[phoneId].retryConnect();
         }
     }
@@ -520,10 +507,25 @@ private void deactivateDdsRequests() {
         Iterator<Integer> iterator = mRequestInfos.keySet().iterator();
         while (iterator.hasNext()) {
             RequestInfo requestInfo = mRequestInfos.get(iterator.next());
-            String specifier = requestInfo.request.networkCapabilities
-                .getNetworkSpecifier();
-            if (specifier == null || specifier.equals("")) {
-                onReleaseRequest(requestInfo);
+            if (requestInfo != null) {
+                String specifier = requestInfo.request.networkCapabilities
+                    .getNetworkSpecifier();
+                if (specifier == null || specifier.equals("")) {
+                    if (requestInfo.executedPhoneId != INVALID_PHONE_INDEX) {
+                        String apn = apnForNetworkRequest(requestInfo.request);
+                        int phoneId = requestInfo.executedPhoneId;
+                        requestInfo.executedPhoneId = INVALID_PHONE_INDEX;
+                        logd("[setDataSubId] subId =" + dataSubId);
+                        requestInfo.log(
+                                "DctController.onSettingsChange releasing request");
+                        for (int i = 0; i < mPhoneNum; i++) {
+                            PhoneBase phoneBase =
+                                (PhoneBase)mPhones[i].getActivePhone();
+                            DcTrackerBase dcTracker = phoneBase.mDcTracker;
+                            dcTracker.decApnRefCount(apn, requestInfo.getLog());
+                        }
+                    }
+                }
             }
         }
     }
@@ -553,28 +555,17 @@ protected void onSettingsChanged() {
     }
 
     protected int getTopPriorityRequestPhoneId() {
+        RequestInfo retRequestInfo = null;
         String topSubId = null;
         int priority = -1;
         int subId;
 
-        int activePhoneId = -1;
-        for (int i = 0; i < mDcSwitchStateMachine.length; i++) {
-            if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
-                activePhoneId = i;
-                break;
-            }
-        }
-
         for (RequestInfo requestInfo : mRequestInfos.values()) {
             logd("getTopPriorityRequestPhoneId requestInfo=" + requestInfo);
             if (requestInfo.priority > priority) {
                 priority = requestInfo.priority;
                 topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
                 retRequestInfo = requestInfo;
-            } else if (priority == requestInfo.priority) {
-                if (requestInfo.executedPhoneId == activePhoneId) {
-                    topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
-                }
             }
         }
         if (TextUtils.isEmpty(topSubId)) {
@@ -595,6 +586,7 @@ protected int getTopPriorityRequestPhoneId() {
             // that means there isn't a phone for the default sub
             return INVALID_PHONE_INDEX;
         }
+
         return phoneId;
     }
 
@@ -713,6 +705,12 @@ protected int getRequestPhoneId(NetworkRequest networkRequest) {
             subId = Integer.parseInt(specifier);
         }
         int phoneId = mSubController.getPhoneId(subId);
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            phoneId = 0;
+            if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+                throw new RuntimeException("Should not happen, no valid phoneId");
+            }
+        }
         return phoneId;
     }
 

From 3b24907c2bb11199c3a9bb3d1f9b74ae8629428b Mon Sep 17 00:00:00 2001
From: kaiyiz <kaiyiz@codeaurora.org>
Date: Mon, 10 Nov 2014 16:32:27 +0800
Subject: [PATCH 89/92] TelephonyProvider: Add CDMA call forwarding/waiting
 function

There isn't CDMA call forwarding and waiting function.

Add CDMA call forwarding/waiting function.

CRs-Fixed: 748144

Change-Id: Ic817678c6973ba6bdf8378481e6e71b3ed23af23
---
 src/java/android/provider/Telephony.java | 33 +++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/src/java/android/provider/Telephony.java b/src/java/android/provider/Telephony.java
index 0fc49a11b8..6a5bc8294b 100644
--- a/src/java/android/provider/Telephony.java
+++ b/src/java/android/provider/Telephony.java
@@ -3102,7 +3102,6 @@ private CellBroadcasts() {}
          * The content:// style URL for this table
          */
         public static final Uri CONTENT_URI =
-
                 Uri.parse("content://blacklist");
 
         /**
@@ -3163,4 +3162,36 @@ private CellBroadcasts() {}
          */
         public static final String MESSAGE_MODE = "message";
     }
+
+    /**
+     * @hide
+     */
+    public static final class CdmaCallOptions implements BaseColumns {
+        /**
+         * The content:// style URL for this table
+         */
+        public static final Uri CONTENT_URI =
+                Uri.parse("content://cdma/calloption");
+
+        /**
+         * The default sort order for this table
+         */
+        public static final String DEFAULT_SORT_ORDER = "name ASC";
+
+        public static final String NAME = "name";
+
+        public static final String MCC = "mcc";
+
+        public static final String MNC = "mnc";
+
+        public static final String NUMERIC = "numeric";
+
+        public static final String NUMBER = "number";
+
+        public static final String TYPE = "type";
+
+        public static final String CATEGORY = "category";
+
+        public static final String STATE = "state";
+    }
 }

From 9f4f4beef60b29a7611688bda81c78119ddedde3 Mon Sep 17 00:00:00 2001
From: Altaf-Mahdi <altaf.mahdi@gmail.com>
Date: Sun, 26 Jun 2016 23:40:17 +0100
Subject: [PATCH 90/92] Subscription updater: don't post messages on events in
 BroadcastReceiver

* for dual sim devices with 2 sims inserted, this fixes sims not
  being detected on boot when QTI telephony extension is present.

Change-Id: I478b150055f21d210ccba7459f55ff75786e4723
---
 .../internal/telephony/SubscriptionInfoUpdater.java      | 16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 0b489a94f1..e4987c7f3e 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -231,13 +231,15 @@ public void onReceive(Context context, Intent intent) {
                 }
             }
 
-            if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(simStatus)) {
-                mLockedSims.set(slotId);
-                update(slotId);
-            } else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simStatus)
-                    || IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(simStatus)) {
-                mLockedSims.clear(slotId);
-                update(slotId);
+            if (isAllIccIdQueryDone()) {
+                if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(simStatus)) {
+                    mLockedSims.set(slotId);
+                    update(slotId);
+                } else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simStatus)
+                        || IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(simStatus)) {
+                    mLockedSims.clear(slotId);
+                    update(slotId);
+                }
             }
 
             logd("[Receiver]-");

From 658eea80130de80e74dee4a8a608ce419258ff5b Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <ricardo@cyngn.com>
Date: Tue, 19 Apr 2016 20:57:53 +0100
Subject: [PATCH 91/92] GsmSS: Use per-slot resources for carrier-bound options

The decision of whether an MVNO operator is roaming or not comes from
an mcc/mnc-specific resource. Relying on the global system resources
to provide the appropriate result for each of the slots on a multi-SIM
device is just wrong, since each SIM will have (and need) its own
separate preferences and arrays of compatible/blocked carriers.

Ref CYNGNOS-2534, CYNGNOS-3190

Change-Id: If3b45a4a4702cf45bc1d965e26c8df7ef3ff783b
---
 .../telephony/gsm/GsmServiceStateTracker.java         | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 531f393dd5..995c64bb5f 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -1663,8 +1663,15 @@ private boolean currentMccEqualsSimMcc(ServiceState s) {
      */
     private boolean isOperatorConsideredNonRoaming(ServiceState s) {
         String operatorNumeric = s.getOperatorNumeric();
-        String[] numericArray = mPhone.getContext().getResources().getStringArray(
+        String[] numericArray;
+        int subId = mPhone.getSubId();
+        if (subId >= 0) {
+            numericArray = SubscriptionManager.getResourcesForSubId(mPhone.getContext(),subId)
+                 .getStringArray(com.android.internal.R.array.config_operatorConsideredNonRoaming);
+        } else {
+            numericArray = mPhone.getContext().getResources().getStringArray(
                     com.android.internal.R.array.config_operatorConsideredNonRoaming);
+        }
 
         if (numericArray.length == 0 || operatorNumeric == null) {
             return false;
@@ -1680,8 +1687,16 @@ private boolean isOperatorConsideredNonRoaming(ServiceState s) {
 
     private boolean isOperatorConsideredRoaming(ServiceState s) {
         String operatorNumeric = s.getOperatorNumeric();
-        String[] numericArray = mPhone.getContext().getResources().getStringArray(
+        String[] numericArray;
+        int subId = mPhone.getSubId();
+        if (subId >= 0) {
+            numericArray = SubscriptionManager.getResourcesForSubId(mPhone.getContext(),subId)
+                .getStringArray(
                     com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
+        } else {
+            numericArray = mPhone.getContext().getResources().getStringArray(
+                    com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
+        }
 
         if (numericArray.length == 0 || operatorNumeric == null) {
             return false;

From 4b479deb9b4a8673bc34424f532628ebf39d0eb9 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Wed, 13 Jul 2016 19:28:51 -0700
Subject: [PATCH 92/92] DctController: fix mismerge with
 getTopPriorityRequestPhoneId()

Add back logic from change-id
I57fee028d9ac0e91d94eb70f8ea75c7fcb5f7087

Change-Id: Ice8026fa75126903bdb756c663008b68fafef60b
Signed-off-by: Roman Birg <roman@cyngn.com>
---
 .../internal/telephony/dataconnection/DctController.java     | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index 1a6024a2e0..c630cb68e5 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -560,12 +560,24 @@ protected int getTopPriorityRequestPhoneId() {
         int priority = -1;
         int subId;
 
+        int activePhoneId = -1;
+        for (int i=0; i<mDcSwitchStateMachine.length; i++) {
+            if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
+                activePhoneId = i;
+                break;
+            }
+        }
+
         for (RequestInfo requestInfo : mRequestInfos.values()) {
             logd("getTopPriorityRequestPhoneId requestInfo=" + requestInfo);
             if (requestInfo.priority > priority) {
                 priority = requestInfo.priority;
                 topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
                 retRequestInfo = requestInfo;
+            } else if (priority == requestInfo.priority) {
+                if (requestInfo.executedPhoneId == activePhoneId) {
+                   topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
+               }
             }
         }
         if (TextUtils.isEmpty(topSubId)) { 
		 
From 13a46c9ae6febee32134edb64e0a89f2f9997436 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sun, 31 Jul 2016 20:20:20 +0200
Subject: [PATCH] Use display name instead of numeric carrier Thanks to
 @DerTeufel

---
 .../android/internal/telephony/SubscriptionController.java   | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 2979a760ef..87e43a4881 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -265,6 +265,13 @@ public void notifySubscriptionInfoChanged() {
          broadcastSimInfoContentChanged();
      }
 
+     private boolean isNumeric(String str) {
+         for (char c : str.toCharArray()) {
+             if (!Character.isDigit(c)) return false;
+         }
+         return true;
+     }
+
     /**
      * New SubInfoRecord instance and fill in detail info
      * @param cursor
@@ -309,6 +316,11 @@ private SubscriptionInfo getSubInfoRecord(Cursor cursor) {
                 + " mcc:" + mcc + " mnc:" + mnc + " countIso:" + countryIso + " userNwMode:" + userNwMode);
         }
 
+        if (isNumeric(carrierName)) {
+            carrierName = displayName;
+            logd("[getSubInfoRecord] carrierName changed to: " + displayName);
+        }
+
         // If line1number has been set to a different number, use it instead.
         String line1Number = mTelephonyManager.getLine1NumberForSubscriber(id);
         if (!TextUtils.isEmpty(line1Number) && !line1Number.equals(number)) {		 
		 
		 
From 563afbc51baa47e2bd5aece37641f611f477676b Mon Sep 17 00:00:00 2001
From: Aniruddha Adhikary <aniruddha@adhikary.net>
Date: Sun, 20 Dec 2015 14:54:55 +0600
Subject: [PATCH] mtk: inputless ussd support

Generic MediaTek chips handle USSD weirdly.
---
 src/java/com/android/internal/telephony/gsm/GSMPhone.java | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 82ae9f49d4..0ba62bb333 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -1475,7 +1475,12 @@ private void updateCallForwardStatus() {
             // Complete pending USSD
 
             if (isUssdRelease) {
-                found.onUssdRelease();
+                // MTK weirdness
+                if(ussdMessage != null) {
+                    found.onUssdFinished(ussdMessage, isUssdRequest);
+                } else {
+                    found.onUssdRelease();
+                }
             } else if (isUssdError) {
                 found.onUssdFinishedError();
             } else {		 
			 
From 880b07f5abc0957d8de9839416ce99375e9b1187 Mon Sep 17 00:00:00 2001
From: LineageOS-MTK <luzejij@binka.me>
Date: Mon, 22 May 2017 23:10:22 +0300
Subject: [PATCH] Fix 2g/3g switch

---
 src/java/com/android/internal/telephony/PhoneBase.java | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index dc790d798..07b36c362 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -1750,7 +1750,7 @@ public void setPreferredNetworkType(int networkType, Message response) {
         // Only set preferred network types to that which the modem supports
         int modemRaf = getRadioAccessFamily();
         int rafFromType = RadioAccessFamily.getRafFromNetworkType(networkType);
-
+/*
         if (modemRaf == RadioAccessFamily.RAF_UNKNOWN
                 || rafFromType == RadioAccessFamily.RAF_UNKNOWN) {
             Rlog.d(LOG_TAG, "setPreferredNetworkType: Abort, unknown RAF: "
@@ -1764,8 +1764,8 @@ public void setPreferredNetworkType(int networkType, Message response) {
             }
             return;
         }
-
-        int filteredRaf = (rafFromType & modemRaf);
+*/
+        int filteredRaf = (rafFromType);
         int filteredType = RadioAccessFamily.getNetworkTypeFromRaf(filteredRaf);
 
         // The getNetworkTypeFromRaf, has no way to differentiate between MODE_GSM_UMTS

From d3f5b5bfcb9544d320b7be9f7f3ef2c3b816997e Mon Sep 17 00:00:00 2001
From: LineageOS-MTK <luzejij@binka.me>
Date: Tue, 23 May 2017 13:45:12 +0300
Subject: [PATCH] Correct data transfer after device reboot

---
 .../internal/telephony/dataconnection/DataConnection.java   | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
index edc58afc2..093389fbf 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
@@ -1503,13 +1503,12 @@ public boolean processMessage(Message msg) {
                                     + " rat=" + rat + " ignoring");
                         }
                     } else {
-                        if (drs == ServiceState.STATE_IN_SERVICE) {
-                            // have to retry connecting since no attach event will come
-                            if (mConnectionParams.mRetryWhenSSChange) {
-                                retVal = NOT_HANDLED;
-                                break;
-                            }
-                        } else {
+                        // have to retry connecting since no attach event will come
+                        if (mConnectionParams.mRetryWhenSSChange) {
+                            retVal = NOT_HANDLED;
+                            break;
+                        }
+                        if (drs != ServiceState.STATE_IN_SERVICE) {
                             // We've lost the connection and we're retrying but DRS or RAT changed
                             // so we may never succeed, might as well give up.
                             mInactiveState.setEnterNotificationParams(DcFailCause.LOST_CONNECTION);		 