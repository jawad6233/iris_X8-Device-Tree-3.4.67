From 28b35547e2aaa5227446260932ef66102ac4e870 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Tue, 19 Apr 2016 20:42:01 +0200
Subject: [PATCH] Remove rild service & fix led permissions

Change-Id: I2ee1406de35983d2f23fb660eb3581e415768d17
---
 rootdir/init.rc | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 78adacc9df..8397d9f5a0 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -492,6 +492,9 @@ on boot
     chown system system /sys/class/leds/red/device/grpfreq
     chown system system /sys/class/leds/red/device/grppwm
     chown system system /sys/class/leds/red/device/blink
+    chown system system /sys/class/leds/red/trigger
+    chown system system /sys/class/leds/green/trigger
+    chown system system /sys/class/leds/blue/trigger
     chown system system /sys/class/timed_output/vibrator/enable
     chown system system /sys/module/sco/parameters/disable_esco
     chown system system /sys/kernel/ipv4/tcp_wmem_min
@@ -648,14 +651,6 @@ service debuggerd64 /system/bin/debuggerd64
     class main
     writepid /dev/cpuset/system-background/tasks
 
-service ril-daemon /system/bin/rild
-    class main
-    socket rild stream 660 root radio
-    socket sap_uim_socket1 stream 660 bluetooth bluetooth
-    socket rild-debug stream 660 radio system
-    user root
-    group radio cache inet misc audio log qcom_diag
-
 service surfaceflinger /system/bin/surfaceflinger
     class core
     user system
	 

From 91253788d52ff419387b77bc6d8fea0bbfbabb1b Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Tue, 19 Apr 2016 20:46:09 +0200
Subject: [PATCH] Add depreciated symbols needed by old mali blobs

Change-Id: I8efb49e36eb364f347c4c98ce1a0ccc0f7864656
---
 libutils/Android.mk        |  2 ++
 libutils/MediatekHacks.cpp | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+)
 create mode 100644 libutils/MediatekHacks.cpp

diff --git a/libutils/Android.mk b/libutils/Android.mk
index 23a5c598fd..c2b1df5829 100644
--- a/libutils/Android.mk
+++ b/libutils/Android.mk
@@ -83,6 +83,8 @@ LOCAL_CFLAGS += -DALIGN_DOUBLE
 endif
 LOCAL_CFLAGS += -Werror
 
+LOCAL_SRC_FILES += MediatekHacks.cpp
+
 LOCAL_STATIC_LIBRARIES := \
 	libcutils \
 	libc
diff --git a/libutils/MediatekHacks.cpp b/libutils/MediatekHacks.cpp
new file mode 100644
index 0000000000..0404a32cb7
--- /dev/null
+++ b/libutils/MediatekHacks.cpp
@@ -0,0 +1,18 @@
+extern "C" {
+ void _ZN7android11IDumpTunnel11asInterfaceERKNS_2spINS_7IBinderEEE(){}
+ void _ZN7android9CallStackC1EPKci(char const*, int);
+ void _ZN7android9CallStack6updateEii(int, int);
+
+ void _ZN7android9CallStackC1EPKcii(char const* logtag, int ignoreDepth, int maxDepth){
+  maxDepth = maxDepth-1;
+  maxDepth = maxDepth+1;
+  _ZN7android9CallStackC1EPKci(logtag, ignoreDepth);
+  
+ }
+
+ void _ZN7android9CallStack6updateEiii(int ignoreDepth, int maxDepth, int tid){
+  maxDepth = maxDepth-1;
+  maxDepth = maxDepth+1; 
+  _ZN7android9CallStack6updateEii(ignoreDepth, tid);
+ }
+}


From 16f5c062979958073b33ea687bd2a58d51b44b1a Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Tue, 19 Apr 2016 20:46:19 +0200
Subject: [PATCH] Add missing functions for thermal

Change-Id: I27b22cf1527b9aa93d4554cca4fcc877ee4c2a64
---
 include/netutils/ifc.h  |  2 ++
 libnetutils/ifc_utils.c | 75 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 77 insertions(+)

diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index 3b272343d6..b7d681a819 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,6 +61,8 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
+
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index 3bd59c7896..ec2db53029 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -36,6 +36,7 @@
 #include <linux/ipv6_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
+#include <linux/un.h>
 
 #include "netutils/ifc.h"
 
@@ -703,3 +704,77 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+
+static int ifc_netd_sock_init(void)
+{
+    int ifc_netd_sock;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+  
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+  
+        setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, fd=%d, err: %d(%s)", 
+                ifc_netd_sock, errno, strerror(errno));
+            close(ifc_netd_sock);
+            return -1;
+        }
+  
+    if (DBG) printerr("ifc_netd_sock_init fd=%d", ifc_netd_sock);
+    return ifc_netd_sock;
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+	int nread = 0;
+	int netd_sock = 0;
+	
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+    
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+	if(fnetd == NULL){
+		ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+		goto exit;
+	}
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+	//Todo: read the whole response from netd
+	nread = fread(rcv_buf, 1, 20, fnetd);
+	rcv_buf[23] = 0;
+	ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+  
+    return ret;
+}


From e58c35b3b0556d2f7cfbfa1254ed4dd2a0ee05e6 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sat, 23 Apr 2016 14:03:00 +0200
Subject: [PATCH] Fix service permissions

Change-Id: I87c866a83083c901586b4ab9fefde36717661e18
---
 rootdir/init.rc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 8397d9f5a0..bba74b492a 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -653,7 +653,7 @@ service debuggerd64 /system/bin/debuggerd64
 
 service surfaceflinger /system/bin/surfaceflinger
     class core
-    user system
+    user root
     group graphics drmrpc
     onrestart restart zygote
 
@@ -664,7 +664,7 @@ service drm /system/bin/drmserver
 
 service media /system/bin/mediaserver
     class main
-    user media
+    user root
     group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm qcom_diag
     ioprio rt 4
 
 
From b9768520db2504c022646a98eb2467fcda595c21 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sat, 23 Apr 2016 14:06:16 +0200
Subject: [PATCH] Force selinux permissive

Change-Id: Ib619af330b5dc872cf06752a7e5aa7095bd60f87
---
 init/init.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/init/init.cpp b/init/init.cpp
index 58d7d34042..030c7bf7df 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -929,10 +929,11 @@ static bool selinux_is_disabled(void)
 
 static bool selinux_is_enforcing(void)
 {
-    if (ALLOW_DISABLE_SELINUX) {
+    return false;
+    /*if (ALLOW_DISABLE_SELINUX) {
         return selinux_status_from_cmdline() == SELINUX_ENFORCING;
     }
-    return true;
+    return true;*/
 }
 
 int selinux_reload_policy(void)
 
 
From b3b8554c12acb85b98e5257478868421ffdfd356 Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sat, 23 Apr 2016 14:06:29 +0200
Subject: [PATCH] Set hardware to mt6592

Change-Id: Ibe5995afe330baf0999ae819f153710b7eb42815
---
 init/init.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/init/init.cpp b/init/init.cpp
index 030c7bf7df..487d580b8b 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -817,7 +817,7 @@ static void export_kernel_boot_props() {
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+        { "ro.boot.hardware",   "ro.hardware",   "mt6592", },
 #ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
 #endif
 
 
From f0b3162d1928364d01787884b3fa415adc3a72ac Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sun, 24 Apr 2016 03:33:53 +0200
Subject: [PATCH] Fix offline charging (boot mode = 8)

Change-Id: Ie2ed87ecf1ca125dcad373e00ffb3d159eb08c36
---
 init/init.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/init/init.cpp b/init/init.cpp
index 487d580b8b..da5d44d36d 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -1017,7 +1017,7 @@ static int charging_mode_booting(void) {
         return 0;
 
     close(f);
-    return ('1' == cmb);
+    return ('8' == cmb);
 #endif
 }
 
 
From e2965141716530898964afcc0cc03d72be190b21 Mon Sep 17 00:00:00 2001
From: Jeff Sharkey <jsharkey@android.com>
Date: Wed, 16 Dec 2015 13:20:37 -0700
Subject: [PATCH 1/6] Re-derive permissions after package changes.

When packages change, existing package-specific directories may have
gained/lost a UID mapping, so we need to update the permissions for
any in-memory nodes.

This allows an app to deliver data for another package before that
package is installed, which is the typical pattern of how OBB files
are delivered.

Also fix bug by re-deriving permissions when files are moved.

Bug: 25399427
Change-Id: I06f38a24ad7dee5f5099ba81429aef03208e5683
(cherry picked from commit f7aad11c1cc133e352333f83e3abbf323cd41ead)
---
 sdcard/sdcard.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index a79e2ddce5..06452aa475 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -507,6 +507,16 @@ static void derive_permissions_locked(struct fuse* fuse, struct node *parent,
     }
 }
 
+static void derive_permissions_recursive_locked(struct fuse* fuse, struct node *parent) {
+    struct node *node;
+    for (node = parent->child; node; node = node->next) {
+        derive_permissions_locked(fuse, parent, node);
+        if (node->child) {
+            derive_permissions_recursive_locked(fuse, node);
+        }
+    }
+}
+
 /* Kernel has already enforced everything we returned through
  * derive_permissions_locked(), so this is used to lock down access
  * even further, such as enforcing that apps hold sdcard_rw. */
@@ -1145,6 +1155,8 @@ static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
     res = rename_node_locked(child_node, new_name, new_actual_name);
     if (!res) {
         remove_node_from_parent_locked(child_node);
+        derive_permissions_locked(fuse, new_parent_node, child_node);
+        derive_permissions_recursive_locked(fuse, child_node);
         add_node_to_parent_locked(child_node, new_parent_node);
     }
     goto done;
@@ -1663,6 +1675,10 @@ static int read_package_list(struct fuse_global* global) {
     TRACE("read_package_list: found %zu packages\n",
             hashmapSize(global->package_to_appid));
     fclose(file);
+
+    /* Regenerate ownership details using newly loaded mapping */
+    derive_permissions_recursive_locked(global->fuse_default, &global->root);
+
     pthread_mutex_unlock(&global->lock);
     return 0;
 }

From e1d784619a3c5de9073465645eb98ea6595a4507 Mon Sep 17 00:00:00 2001
From: Josh Gao <jmgao@google.com>
Date: Tue, 16 Feb 2016 15:01:43 -0800
Subject: [PATCH 2/6] Don't create tombstone directory.

Partial backport of cf79748.

Bug: http://b/26403620
Change-Id: Ib877ab6cfab6aef079830c5a50ba81141ead35ee
---
 debuggerd/tombstone.cpp | 15 +--------------
 1 file changed, 1 insertion(+), 14 deletions(-)

diff --git a/debuggerd/tombstone.cpp b/debuggerd/tombstone.cpp
index b0ad27402c..aeffc660a8 100644
--- a/debuggerd/tombstone.cpp
+++ b/debuggerd/tombstone.cpp
@@ -788,21 +788,8 @@ char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
   log.current_tid = tid;
   log.crashed_tid = tid;
 
-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
-    _LOG(&log, logtype::ERROR, "failed to create %s: %s\n", TOMBSTONE_DIR, strerror(errno));
-  }
-
-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
-    _LOG(&log, logtype::ERROR, "failed to change ownership of %s: %s\n", TOMBSTONE_DIR, strerror(errno));
-  }
-
   int fd = -1;
-  char* path = NULL;
-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
-    path = find_and_open_tombstone(&fd);
-  } else {
-    _LOG(&log, logtype::ERROR, "Failed to restore security context, not writing tombstone.\n");
-  }
+  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, "Skipping tombstone write, nothing to do.\n");

From 05a3648f9529cffecb24f939768868380de307d9 Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Thu, 14 Apr 2016 16:53:23 -0700
Subject: [PATCH 3/6] healthd: Rename default QCOM libhealthd library

* Avoid possible module name conflicts

Change-Id: I4a804a4d1e7266e8918b5a5b50adaffe219ff226
---
 healthd/Android.mk | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/healthd/Android.mk b/healthd/Android.mk
index d1e005ef65..5345338d7b 100644
--- a/healthd/Android.mk
+++ b/healthd/Android.mk
@@ -10,7 +10,7 @@ include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := healthd_board_msm.cpp
-LOCAL_MODULE := libhealthd.msm
+LOCAL_MODULE := libhealthd.qcom
 LOCAL_CFLAGS := -Werror
 include $(BUILD_STATIC_LIBRARY)
 
@@ -62,7 +62,7 @@ endif
 LOCAL_HAL_STATIC_LIBRARIES := libhealthd
 
 ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
-BOARD_HAL_STATIC_LIBRARIES ?= libhealthd.msm
+BOARD_HAL_STATIC_LIBRARIES ?= libhealthd.qcom
 endif
 
 # Symlink /charger to /sbin/healthd

From 74f658f70599c283a5dd559343756565d562bf22 Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Thu, 14 Apr 2016 16:49:56 -0700
Subject: [PATCH 4/6] healthd: Allow devices to opt-out of enabling charger LED

* Not all devices will want to enable this, and it may also cause symbol
  conflicts with static HAL libraries.

Change-Id: I0a2a082f9bf84b6ecfecf3de88c6d494d5e2cf44
---
 healthd/Android.mk               | 4 ++++
 healthd/healthd_mode_charger.cpp | 8 ++++++++
 2 files changed, 12 insertions(+)

diff --git a/healthd/Android.mk b/healthd/Android.mk
index 5345338d7b..7db4ad5f95 100644
--- a/healthd/Android.mk
+++ b/healthd/Android.mk
@@ -51,6 +51,10 @@ ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
 LOCAL_CFLAGS += -DCHARGER_ENABLE_SUSPEND
 endif
 
+ifeq ($(strip $(BOARD_NO_CHARGER_LED)),true)
+LOCAL_CFLAGS += -DNO_CHARGER_LED
+endif
+
 LOCAL_C_INCLUDES := bootable/recovery
 
 LOCAL_STATIC_LIBRARIES := libbatteryservice libbinder libminui libpng libz libutils libstdc++ libcutils liblog libm libc
diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index eb93d6a42a..5dd666df8c 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -183,6 +183,7 @@ enum {
     BLUE_LED = 0x01 << 2,
 };
 
+#ifdef NO_CHARGER_LED
 struct led_ctl {
     int color;
     const char *path;
@@ -203,6 +204,7 @@ struct soc_led_color_mapping soc_leds[3] = {
     {90, RED_LED | GREEN_LED},
     {100, GREEN_LED},
 };
+#endif
 
 static struct charger charger_state;
 static struct healthd_config *healthd_config;
@@ -211,6 +213,7 @@ static int char_width;
 static int char_height;
 static bool minui_inited;
 
+#ifdef NO_CHARGER_LED
 static int set_tricolor_led(int on, int color)
 {
     int fd, i;
@@ -257,6 +260,7 @@ static int set_battery_soc_leds(int soc)
 
     return 0;
 }
+#endif
 
 /* current time in milliseconds */
 static int64_t curr_time_ms(void)
@@ -667,14 +671,17 @@ static void handle_input_state(struct charger *charger, int64_t now)
 
 static void handle_power_supply_state(struct charger *charger, int64_t now)
 {
+#ifndef NO_CHARGER_LED
     static int old_soc = 0;
     int soc = 0;
+#endif
 
     if (!charger->have_battery_state)
         return;
 
     healthd_board_mode_charger_battery_update(batt_prop);
 
+#ifndef NO_CHARGER_LED
     if (batt_prop && batt_prop->batteryLevel >= 0) {
         soc = batt_prop->batteryLevel;
     }
@@ -683,6 +690,7 @@ static void handle_power_supply_state(struct charger *charger, int64_t now)
         old_soc = soc;
         set_battery_soc_leds(soc);
     }
+#endif
 
     if (!charger->charger_connected) {
 

From f5eb7307401b7b8e1f05c509adb64970997ee1aa Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Fri, 15 Apr 2016 19:44:38 -0400
Subject: [PATCH 5/6] healthd: Fix NO_CHARGER_LED

Change-Id: Iaae43e2a236318011b7aefb59250c19dd954521e
---
 healthd/healthd_mode_charger.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index 5dd666df8c..d6c31cf6a6 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -183,7 +183,7 @@ enum {
     BLUE_LED = 0x01 << 2,
 };
 
-#ifdef NO_CHARGER_LED
+#ifndef NO_CHARGER_LED
 struct led_ctl {
     int color;
     const char *path;
@@ -213,7 +213,7 @@ static int char_width;
 static int char_height;
 static bool minui_inited;
 
-#ifdef NO_CHARGER_LED
+#ifndef NO_CHARGER_LED
 static int set_tricolor_led(int on, int color)
 {
     int fd, i;

From 408bb87b6951267a96a25830da7a7621266858dd Mon Sep 17 00:00:00 2001
From: sndnvaps <sndnvaps@gmail.com>
Date: Thu, 21 Apr 2016 19:44:20 +0800
Subject: [PATCH 6/6] fastboot: add ZTE to the list of known vendors

Change-Id: I741d0e4068d948fb7b4036d7f02e68b896863795
Signed-off-by: sndnvaps <sndnvaps@gmail.com>
---
 fastboot/fastboot.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/fastboot/fastboot.cpp b/fastboot/fastboot.cpp
index 5112c1599d..a3fa115266 100644
--- a/fastboot/fastboot.cpp
+++ b/fastboot/fastboot.cpp
@@ -207,7 +207,8 @@ int match_fastboot_with_serial(usb_ifc_info *info, const char *local_serial)
        (info->dev_vendor != 0x0421) &&  // Nokia
        (info->dev_vendor != 0x1ebf) &&  // Coolpad
        (info->dev_vendor != 0x2b4c) &&  // Zuk
-       (info->dev_vendor != 0x2a96))    // MMX
+       (info->dev_vendor != 0x2a96) &&  // MMX
+       (info->dev_vendor != 0x19d2))    // ZTE
             return -1;
     if(info->ifc_class != 0xff) return -1;
     if(info->ifc_subclass != 0x42) return -1;
	 
	 
From ad54cfed4516292654c997910839153264ae00a0 Mon Sep 17 00:00:00 2001
From: Josh Gao <jmgao@google.com>
Date: Wed, 23 Mar 2016 11:42:53 -0700
Subject: [PATCH 01/21] Don't demangle symbol names.

Bug: http://b/27299236
Change-Id: I26ef47f80d4d6048a316ba51e83365ff65d70439
---
 libbacktrace/Backtrace.cpp | 16 ----------------
 1 file changed, 16 deletions(-)

diff --git a/libbacktrace/Backtrace.cpp b/libbacktrace/Backtrace.cpp
index 97f0ef4455..42769ed902 100644
--- a/libbacktrace/Backtrace.cpp
+++ b/libbacktrace/Backtrace.cpp
@@ -54,24 +54,8 @@ Backtrace::~Backtrace() {
   }
 }
 
-extern "C" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,
-                                int* status);
-
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
-  if (!func_name.empty()) {
-#if defined(__APPLE__)
-    // Mac OS' __cxa_demangle demangles "f" as "float"; last tested on 10.7.
-    if (func_name[0] != '_') {
-      return func_name;
-    }
-#endif
-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
-    if (name) {
-      func_name = name;
-      free(name);
-    }
-  }
   return func_name;
 }
 

From 864e2e22fcd0cba3f5e67680ccabd0302dfda45d Mon Sep 17 00:00:00 2001
From: Daniel Rosenberg <drosen@google.com>
Date: Tue, 12 Apr 2016 16:30:28 -0700
Subject: [PATCH 02/21] Fix overflow in path building

An incorrect size was causing an unsigned value
to wrap, causing it to write past the end of
the buffer.

Bug: 28085658
Change-Id: Ie9625c729cca024d514ba2880ff97209d435a165
---
 sdcard/sdcard.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index 06452aa475..123fce6a9d 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -337,7 +337,7 @@ static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize
 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }

From acd185636cbe809bea218aec834d215162b73681 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 26 Apr 2016 15:01:35 -0700
Subject: [PATCH 03/21] fastboot: Add Nextbit's USB vendor id

Change-Id: I400611a6f256cd6c2a721b9ad8496fd60d257f3f
---
 fastboot/fastboot.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/fastboot/fastboot.cpp b/fastboot/fastboot.cpp
index a3fa115266..6a2f10d0c8 100644
--- a/fastboot/fastboot.cpp
+++ b/fastboot/fastboot.cpp
@@ -208,7 +208,8 @@ int match_fastboot_with_serial(usb_ifc_info *info, const char *local_serial)
        (info->dev_vendor != 0x1ebf) &&  // Coolpad
        (info->dev_vendor != 0x2b4c) &&  // Zuk
        (info->dev_vendor != 0x2a96) &&  // MMX
-       (info->dev_vendor != 0x19d2))    // ZTE
+       (info->dev_vendor != 0x19d2) &&  // ZTE
+       (info->dev_vendor != 0x2c3f))    // Nextbit
             return -1;
     if(info->ifc_class != 0xff) return -1;
     if(info->ifc_subclass != 0x42) return -1;

From bbc34f83fcb8511c2f2eb575882b0670793342a8 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 30 Apr 2016 14:09:48 -0700
Subject: [PATCH 04/21] rootdir: Remove cpufreq mode settings

 * AFAIK we no longer should have anything which depends on system
   server or settings writing to the cpufreq controls. Since new
   devices have their cpufreq config nodes nested per-cpu, this
   configuration is no longer valid. It also depends on sketchy
   kernel patches which only work when the moon is in the correct
   phase. Additionally, I see a lot of random logspam when
   devices are hotplugged.
 * If a device needs this functionality, a better way to do it
   is via a userspace daemon which is dedicated to the task since
   it can poll() on the various states and get notified in realtime.

Change-Id: Ib526663d760d6cb758e13f1fa29e7d6229de3daa
---
 rootdir/ueventd.rc | 39 ---------------------------------------
 1 file changed, 39 deletions(-)

diff --git a/rootdir/ueventd.rc b/rootdir/ueventd.rc
index f82d8994d3..67eaabc8fe 100644
--- a/rootdir/ueventd.rc
+++ b/rootdir/ueventd.rc
@@ -99,42 +99,3 @@ subsystem adf
 # DVB API device nodes
 /dev/dvb*                 0660   root       system
 
-# Governor permissions
-/sys/devices/system/cpu/cpu*   cpufreq/scaling_governor   0664  system system
-
-/sys/devices/system/cpu/cpufreq ondemand/boostfreq   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/boostpulse  0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/boosttime   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/down_differential   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/down_differential_multi_core   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/ignore_nice_load   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/input_boost   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/io_is_busy      0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/optimal_freq   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/powersave_bias  0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/sampling_down_factor    0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/sampling_rate   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/sampling_rate_min   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/sync_freq   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/up_threshold   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/up_threshold_any_cpu_load   0664    system  system
-/sys/devices/system/cpu/cpufreq ondemand/up_threshold_multi_core   0664    system  system
-
-/sys/devices/system/cpu/cpufreq interactive/above_hispeed_delay 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/align_windows 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/boost  0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/boostpulse  0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/boostpulse_duration  0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/go_hispeed_load 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/hispeed_freq    0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/io_is_busy      0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/max_freq_hysteresis 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/min_sample_rate 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/min_sample_time 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/sampling_down_factor 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/sync_freq 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/target_loads 0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/timer_rate  0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/timer_slack      0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/up_threshold_any_cpu_freq      0664    system  system
-/sys/devices/system/cpu/cpufreq interactive/up_threshold_any_cpu_load      0664    system  system

From 0d6557ec30fc8c3e06badcae93efff1ee5f6b6a1 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 24 Dec 2015 21:21:04 -0800
Subject: [PATCH 05/21] Revert "Revert "fs_mgr: let fsck.f2fs actually attempt
 a fix""

This reverts commit 33ecd3756347ef2663e500949ab4b33392086fbc.

Change-Id: Ifa430fca72eee3e6f49d5a259c1058f5c3829960
---
 fs_mgr/fs_mgr.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/fs_mgr/fs_mgr.c b/fs_mgr/fs_mgr.c
index c80e53130a..6e20560783 100644
--- a/fs_mgr/fs_mgr.c
+++ b/fs_mgr/fs_mgr.c
@@ -161,12 +161,12 @@ static void check_fs(char *blk_device, char *fs_type, char *target)
             }
         }
     } else if (!strcmp(fs_type, "f2fs")) {
-        char *f2fs_fsck_argv[] = {
-            F2FS_FSCK_BIN,
-            "-a",
-            blk_device
-        };
-        INFO("Running %s on %s\n", F2FS_FSCK_BIN, blk_device);
+            char *f2fs_fsck_argv[] = {
+                    F2FS_FSCK_BIN,
+                    "-f",
+                    blk_device
+            };
+        INFO("Running %s -f %s\n", F2FS_FSCK_BIN, blk_device);
 
         ret = android_fork_execvp_ext(ARRAY_SIZE(f2fs_fsck_argv), f2fs_fsck_argv,
                                       &status, true, LOG_KLOG | LOG_FILE,

From 784c22c8388e50db243ac4ca3871747cd3eefadc Mon Sep 17 00:00:00 2001
From: Yusuke Sato <yusukes@google.com>
Date: Wed, 8 Jul 2015 14:57:07 -0700
Subject: [PATCH 06/21] Use fsck.f2fs -a instead of -f for faster boot

and run fsck with -f on clean shutdown instead.

With -f, fsck.f2fs always performs a full scan of the /data
partition regardless of whether the partition is clean or not.
The full scan takes more than 2 seconds on volantis-userdebug
and delays the OS boot.

With -a, the command does almost nothing when the partition
is clean and finishes within 20-30ms on volantis-userdebug.
When the partition has an error or its check point has
CP_FSCK_FLAG (aka "need_fsck"), the command does exactly the
same full scan as -f to fix it.

Bug: 21853106
Change-Id: I126263caf34c0f5bb8f5e6794454d4e72526ce38
---
 fs_mgr/fs_mgr.c                 |   4 +-
 include/cutils/android_reboot.h |   5 ++
 init/builtins.cpp               |  71 ++++++++++++++-
 libcutils/android_reboot.c      | 187 +++++++++++++++++++++++++++++++++-------
 logwrapper/logwrap.c            |   7 +-
 5 files changed, 236 insertions(+), 38 deletions(-)

diff --git a/fs_mgr/fs_mgr.c b/fs_mgr/fs_mgr.c
index 6e20560783..e78b5815fa 100644
--- a/fs_mgr/fs_mgr.c
+++ b/fs_mgr/fs_mgr.c
@@ -163,10 +163,10 @@ static void check_fs(char *blk_device, char *fs_type, char *target)
     } else if (!strcmp(fs_type, "f2fs")) {
             char *f2fs_fsck_argv[] = {
                     F2FS_FSCK_BIN,
-                    "-f",
+                    "-a",
                     blk_device
             };
-        INFO("Running %s -f %s\n", F2FS_FSCK_BIN, blk_device);
+        INFO("Running %s -a %s\n", F2FS_FSCK_BIN, blk_device);
 
         ret = android_fork_execvp_ext(ARRAY_SIZE(f2fs_fsck_argv), f2fs_fsck_argv,
                                       &status, true, LOG_KLOG | LOG_FILE,
diff --git a/include/cutils/android_reboot.h b/include/cutils/android_reboot.h
index 85e1b7e5b1..a3861a02dc 100644
--- a/include/cutils/android_reboot.h
+++ b/include/cutils/android_reboot.h
@@ -17,6 +17,8 @@
 #ifndef __CUTILS_ANDROID_REBOOT_H__
 #define __CUTILS_ANDROID_REBOOT_H__
 
+#include <mntent.h>
+
 __BEGIN_DECLS
 
 /* Commands */
@@ -28,6 +30,9 @@ __BEGIN_DECLS
 #define ANDROID_RB_PROPERTY "sys.powerctl"
 
 int android_reboot(int cmd, int flags, const char *arg);
+int android_reboot_with_callback(
+    int cmd, int flags, const char *arg,
+    void (*cb_on_remount)(const struct mntent*));
 
 __END_DECLS
 
diff --git a/init/builtins.cpp b/init/builtins.cpp
index b290ce3a28..d0dbecc012 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -16,7 +16,9 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <mntent.h>
 #include <net/if.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,6 +40,7 @@
 #include <base/stringprintf.h>
 #include <cutils/partition_utils.h>
 #include <cutils/android_reboot.h>
+#include <logwrap/logwrap.h>
 #include <private/android_filesystem_config.h>
 
 #include "init.h"
@@ -49,6 +52,8 @@
 #include "log.h"
 
 #define chmod DO_NOT_USE_CHMOD_USE_FCHMODAT_SYMLINK_NOFOLLOW
+#define UNMOUNT_CHECK_MS 5000
+#define UNMOUNT_CHECK_TIMES 10
 
 int add_environment(const char *name, const char *value);
 
@@ -109,6 +114,67 @@ static void service_start_if_not_disabled(struct service *svc)
     }
 }
 
+static void unmount_and_fsck(const struct mntent *entry)
+{
+    if (strcmp(entry->mnt_type, "f2fs") && strcmp(entry->mnt_type, "ext4"))
+        return;
+
+    /* First, lazily unmount the directory. This unmount request finishes when
+     * all processes that open a file or directory in |entry->mnt_dir| exit.
+     */
+    TEMP_FAILURE_RETRY(umount2(entry->mnt_dir, MNT_DETACH));
+
+    /* Next, kill all processes except init, kthreadd, and kthreadd's
+     * children to finish the lazy unmount. Killing all processes here is okay
+     * because this callback function is only called right before reboot().
+     * It might be cleaner to selectively kill processes that actually use
+     * |entry->mnt_dir| rather than killing all, probably by reusing a function
+     * like killProcessesWithOpenFiles() in vold/, but the selinux policy does
+     * not allow init to scan /proc/<pid> files which the utility function
+     * heavily relies on. The policy does not allow the process to execute
+     * killall/pkill binaries either. Note that some processes might
+     * automatically restart after kill(), but that is not really a problem
+     * because |entry->mnt_dir| is no longer visible to such new processes.
+     */
+    service_for_each(service_stop);
+    TEMP_FAILURE_RETRY(kill(-1, SIGKILL));
+
+    int count = 0;
+    while (count++ < UNMOUNT_CHECK_TIMES) {
+        int fd = TEMP_FAILURE_RETRY(open(entry->mnt_fsname, O_RDONLY | O_EXCL));
+        if (fd >= 0) {
+            /* |entry->mnt_dir| has sucessfully been unmounted. */
+            close(fd);
+            break;
+        } else if (errno == EBUSY) {
+            /* Some processes using |entry->mnt_dir| are still alive. Wait for a
+             * while then retry.
+             */
+            TEMP_FAILURE_RETRY(
+                usleep(UNMOUNT_CHECK_MS * 1000 / UNMOUNT_CHECK_TIMES));
+            continue;
+        } else {
+            /* Cannot open the device. Give up. */
+            return;
+        }
+    }
+
+    int st;
+    if (!strcmp(entry->mnt_type, "f2fs")) {
+        const char *f2fs_argv[] = {
+            "/system/bin/fsck.f2fs", "-f", entry->mnt_fsname,
+        };
+        android_fork_execvp_ext(ARRAY_SIZE(f2fs_argv), (char **)f2fs_argv,
+                                &st, true, LOG_KLOG, true, NULL);
+    } else if (!strcmp(entry->mnt_type, "ext4")) {
+        const char *ext4_argv[] = {
+            "/system/bin/e2fsck", "-f", "-y", entry->mnt_fsname,
+        };
+        android_fork_execvp_ext(ARRAY_SIZE(ext4_argv), (char **)ext4_argv,
+                                &st, true, LOG_KLOG, true, NULL);
+    }
+}
+
 int do_class_start(int nargs, char **args)
 {
     char prop[PROP_NAME_MAX];
@@ -577,6 +643,7 @@ int do_powerctl(int nargs, char **args)
     int len = 0;
     int cmd = 0;
     const char *reboot_target;
+    void (*callback_on_ro_remount)(const struct mntent*) = NULL;
 
     res = expand_props(command, args[1], sizeof(command));
     if (res) {
@@ -590,6 +657,7 @@ int do_powerctl(int nargs, char **args)
         }
         cmd = ANDROID_RB_POWEROFF;
         len = 8;
+        callback_on_ro_remount = unmount_and_fsck;
     } else if (strncmp(command, "reboot", 6) == 0) {
         cmd = ANDROID_RB_RESTART2;
         len = 6;
@@ -614,7 +682,8 @@ int do_powerctl(int nargs, char **args)
         return -EINVAL;
     }
 
-    return android_reboot(cmd, 0, reboot_target);
+    return android_reboot_with_callback(cmd, 0, reboot_target,
+                                        callback_on_ro_remount);
 }
 
 int do_trigger(int nargs, char **args)
diff --git a/libcutils/android_reboot.c b/libcutils/android_reboot.c
index 6ae23c1f00..af7e1892ed 100644
--- a/libcutils/android_reboot.c
+++ b/libcutils/android_reboot.c
@@ -14,43 +14,108 @@
  * limitations under the License.
  */
 
-#include <unistd.h>
-#include <sys/reboot.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <mntent.h>
+#include <stdbool.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
+#include <sys/cdefs.h>
+#include <sys/mount.h>
+#include <sys/reboot.h>
+#include <sys/stat.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include <cutils/android_reboot.h>
+#include <cutils/klog.h>
+#include <cutils/list.h>
 
-#define UNUSED __attribute__((unused))
+#define TAG "android_reboot"
+#define READONLY_CHECK_MS 5000
+#define READONLY_CHECK_TIMES 50
 
-/* Check to see if /proc/mounts contains any writeable filesystems
- * backed by a block device.
- * Return true if none found, else return false.
+typedef struct {
+    struct listnode list;
+    struct mntent entry;
+} mntent_list;
+
+static bool has_mount_option(const char* opts, const char* opt_to_find)
+{
+  bool ret = false;
+  char* copy = NULL;
+  char* opt;
+  char* rem;
+
+  while ((opt = strtok_r(copy ? NULL : (copy = strdup(opts)), ",", &rem))) {
+      if (!strcmp(opt, opt_to_find)) {
+          ret = true;
+          break;
+      }
+  }
+
+  free(copy);
+  return ret;
+}
+
+static bool is_block_device(const char* fsname)
+{
+    return !strncmp(fsname, "/dev/block", 10);
+}
+
+/* Find all read+write block devices in /proc/mounts and add them to
+ * |rw_entries|.
  */
-static int remount_ro_done(void)
+static void find_rw(struct listnode* rw_entries)
 {
     FILE* fp;
     struct mntent* mentry;
-    int found_rw_fs = 0;
 
     if ((fp = setmntent("/proc/mounts", "r")) == NULL) {
-        /* If we can't read /proc/mounts, just give up. */
-        return 1;
+        KLOG_WARNING(TAG, "Failed to open /proc/mounts.\n");
+        return;
     }
     while ((mentry = getmntent(fp)) != NULL) {
-        if (!strncmp(mentry->mnt_fsname, "/dev/block", 10) && strstr(mentry->mnt_opts, "rw,")) {
-            found_rw_fs = 1;
-            break;
+        if (is_block_device(mentry->mnt_fsname) &&
+            has_mount_option(mentry->mnt_opts, "rw")) {
+            mntent_list* item = (mntent_list*)calloc(1, sizeof(mntent_list));
+            item->entry = *mentry;
+            item->entry.mnt_fsname = strdup(mentry->mnt_fsname);
+            item->entry.mnt_dir = strdup(mentry->mnt_dir);
+            item->entry.mnt_type = strdup(mentry->mnt_type);
+            item->entry.mnt_opts = strdup(mentry->mnt_opts);
+            list_add_tail(rw_entries, &item->list);
         }
     }
     endmntent(fp);
+}
+
+static void free_entries(struct listnode* entries)
+{
+    struct listnode* node;
+    struct listnode* n;
+    list_for_each_safe(node, n, entries) {
+        mntent_list* item = node_to_item(node, mntent_list, list);
+        free(item->entry.mnt_fsname);
+        free(item->entry.mnt_dir);
+        free(item->entry.mnt_type);
+        free(item->entry.mnt_opts);
+        free(item);
+    }
+}
 
-    return !found_rw_fs;
+static mntent_list* find_item(struct listnode* rw_entries, const char* fsname_to_find)
+{
+    struct listnode* node;
+    list_for_each(node, rw_entries) {
+        mntent_list* item = node_to_item(node, mntent_list, list);
+        if (!strcmp(item->entry.mnt_fsname, fsname_to_find)) {
+            return item;
+        }
+    }
+    return NULL;
 }
 
 /* Remounting filesystems read-only is difficult when there are files
@@ -64,38 +129,92 @@ static int remount_ro_done(void)
  * repeatedly until there are no more writable filesystems mounted on
  * block devices.
  */
-static void remount_ro(void)
+static void remount_ro(void (*cb_on_remount)(const struct mntent*))
 {
-    int fd, cnt = 0;
+    int fd, cnt;
+    FILE* fp;
+    struct mntent* mentry;
+    struct listnode* node;
+
+    list_declare(rw_entries);
+    list_declare(ro_entries);
+
+    sync();
+    find_rw(&rw_entries);
 
     /* Trigger the remount of the filesystems as read-only,
      * which also marks them clean.
      */
-    fd = open("/proc/sysrq-trigger", O_WRONLY);
+    fd = TEMP_FAILURE_RETRY(open("/proc/sysrq-trigger", O_WRONLY));
     if (fd < 0) {
-        return;
+        KLOG_WARNING(TAG, "Failed to open sysrq-trigger.\n");
+        /* TODO: Try to remount each rw parition manually in readonly mode.
+         * This may succeed if no process is using the partition.
+         */
+        goto out;
+    }
+    if (TEMP_FAILURE_RETRY(write(fd, "u", 1)) != 1) {
+        close(fd);
+        KLOG_WARNING(TAG, "Failed to write to sysrq-trigger.\n");
+        /* TODO: The same. Manually remount the paritions. */
+        goto out;
     }
-    write(fd, "u", 1);
     close(fd);
 
-
     /* Now poll /proc/mounts till it's done */
-    while (!remount_ro_done() && (cnt < 50)) {
-        usleep(100000);
+    cnt = 0;
+    while (cnt < READONLY_CHECK_TIMES) {
+        if ((fp = setmntent("/proc/mounts", "r")) == NULL) {
+            /* If we can't read /proc/mounts, just give up. */
+            KLOG_WARNING(TAG, "Failed to open /proc/mounts.\n");
+            goto out;
+        }
+        while ((mentry = getmntent(fp)) != NULL) {
+            if (!is_block_device(mentry->mnt_fsname) ||
+                !has_mount_option(mentry->mnt_opts, "ro")) {
+                continue;
+            }
+            mntent_list* item = find_item(&rw_entries, mentry->mnt_fsname);
+            if (item) {
+                /* |item| has now been ro remounted. */
+                list_remove(&item->list);
+                list_add_tail(&ro_entries, &item->list);
+            }
+        }
+        endmntent(fp);
+        if (list_empty(&rw_entries)) {
+            /* All rw block devices are now readonly. */
+            break;
+        }
+        TEMP_FAILURE_RETRY(
+            usleep(READONLY_CHECK_MS * 1000 / READONLY_CHECK_TIMES));
         cnt++;
     }
 
-    return;
-}
+    list_for_each(node, &rw_entries) {
+        mntent_list* item = node_to_item(node, mntent_list, list);
+        KLOG_WARNING(TAG, "Failed to remount %s in readonly mode.\n",
+                     item->entry.mnt_fsname);
+    }
+
+    if (cb_on_remount) {
+        list_for_each(node, &ro_entries) {
+            mntent_list* item = node_to_item(node, mntent_list, list);
+            cb_on_remount(&item->entry);
+        }
+    }
 
+out:
+    free_entries(&rw_entries);
+    free_entries(&ro_entries);
+}
 
-int android_reboot(int cmd, int flags UNUSED, const char *arg)
+int android_reboot_with_callback(
+    int cmd, int flags __unused, const char *arg,
+    void (*cb_on_remount)(const struct mntent*))
 {
     int ret;
-
-    sync();
-    remount_ro();
-
+    remount_ro(cb_on_remount);
     switch (cmd) {
         case ANDROID_RB_RESTART:
             ret = reboot(RB_AUTOBOOT);
@@ -117,3 +236,7 @@ int android_reboot(int cmd, int flags UNUSED, const char *arg)
     return ret;
 }
 
+int android_reboot(int cmd, int flags, const char *arg)
+{
+    return android_reboot_with_callback(cmd, flags, arg, NULL);
+}
diff --git a/logwrapper/logwrap.c b/logwrapper/logwrap.c
index 83576fb8f8..44455d1576 100644
--- a/logwrapper/logwrap.c
+++ b/logwrapper/logwrap.c
@@ -355,7 +355,8 @@ static int parent(const char *tag, int parent_read, pid_t pid,
         }
 
         if (poll_fds[0].revents & POLLIN) {
-            sz = read(parent_read, &buffer[b], sizeof(buffer) - 1 - b);
+            sz = TEMP_FAILURE_RETRY(
+                read(parent_read, &buffer[b], sizeof(buffer) - 1 - b));
 
             sz += b;
             // Log one line at a time
@@ -490,7 +491,7 @@ int android_fork_execvp_ext(int argc, char* argv[], int *status, bool ignore_int
     }
 
     /* Use ptty instead of socketpair so that STDOUT is not buffered */
-    parent_ptty = open("/dev/ptmx", O_RDWR);
+    parent_ptty = TEMP_FAILURE_RETRY(open("/dev/ptmx", O_RDWR));
     if (parent_ptty < 0) {
         ERROR("Cannot create parent ptty\n");
         rc = -1;
@@ -505,7 +506,7 @@ int android_fork_execvp_ext(int argc, char* argv[], int *status, bool ignore_int
         goto err_ptty;
     }
 
-    child_ptty = open(child_devname, O_RDWR);
+    child_ptty = TEMP_FAILURE_RETRY(open(child_devname, O_RDWR));
     if (child_ptty < 0) {
         ERROR("Cannot open child_ptty\n");
         rc = -1;

From 8284bce0e87d18e0779b12b63797515406c2d553 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 16 May 2016 00:42:37 -0700
Subject: [PATCH 07/21] rootdir: Put bootanimation service in system-background
 group

 * This keeps it from hogging the big cores and heating up the
   device.

Change-Id: I0ba6abef537ad65978dd77ec706f6e3777cac804
---
 rootdir/init.rc | 1 +
 1 file changed, 1 insertion(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 78adacc9df..ec5a2f6388 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -693,6 +693,7 @@ service bootanim /system/bin/bootanimation
     group graphics audio
     disabled
     oneshot
+    writepid /dev/cpuset/system-background/tasks
 
 service gatekeeperd /system/bin/gatekeeperd /data/misc/gatekeeper
     class late_start

From 516d6913dc5acd695581b3999fab0b5192353022 Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Mon, 16 May 2016 05:21:28 -0400
Subject: [PATCH 08/21] init: Allow devices to opt-out of fsck'ing on power off

On the zenfone2 the fsck code patch kills alls processes.  This causes
watchdogd to get killed which then causes the system to emergency reboot
instead of powering off.

Change-Id: Ibcc74825df6571caa70e2dde7766a72b7749581b
---
 init/Android.mk   | 4 ++++
 init/builtins.cpp | 2 ++
 2 files changed, 6 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index aa322361cd..85dfbfc9f6 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -68,6 +68,10 @@ ifneq ($(TARGET_IGNORE_RO_BOOT_REVISION),)
 LOCAL_CFLAGS += -DIGNORE_RO_BOOT_REVISION
 endif
 
+ifneq ($(TARGET_INIT_UMOUNT_AND_FSCK_IS_UNSAFE),)
+LOCAL_CFLAGS += -DUMOUNT_AND_FSCK_IS_UNSAFE
+endif
+
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     external/zlib \
diff --git a/init/builtins.cpp b/init/builtins.cpp
index d0dbecc012..1681d1707f 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -116,6 +116,7 @@ static void service_start_if_not_disabled(struct service *svc)
 
 static void unmount_and_fsck(const struct mntent *entry)
 {
+#ifndef UMOUNT_AND_FSCK_IS_UNSAFE
     if (strcmp(entry->mnt_type, "f2fs") && strcmp(entry->mnt_type, "ext4"))
         return;
 
@@ -173,6 +174,7 @@ static void unmount_and_fsck(const struct mntent *entry)
         android_fork_execvp_ext(ARRAY_SIZE(ext4_argv), (char **)ext4_argv,
                                 &st, true, LOG_KLOG, true, NULL);
     }
+#endif
 }
 
 int do_class_start(int nargs, char **args)

From 2a0279924b973308cb2a95cc92ab62b09b54cb3f Mon Sep 17 00:00:00 2001
From: Scott Mertz <scott@cyngn.com>
Date: Wed, 25 May 2016 15:47:42 -0700
Subject: [PATCH 09/21] debuggerd: add CM version to tombstones

Change-Id: I7822a2e133a2f326ad2d8da8f79b0064344d59bf
---
 debuggerd/tombstone.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/debuggerd/tombstone.cpp b/debuggerd/tombstone.cpp
index aeffc660a8..0c9fc49cde 100644
--- a/debuggerd/tombstone.cpp
+++ b/debuggerd/tombstone.cpp
@@ -167,10 +167,13 @@ static const char* get_sigcode(int signo, int code) {
 static void dump_header_info(log_t* log) {
   char fingerprint[PROPERTY_VALUE_MAX];
   char revision[PROPERTY_VALUE_MAX];
+  char cm_version[PROPERTY_VALUE_MAX];
 
+  property_get("ro.cm.version", cm_version, "unknown");
   property_get("ro.build.fingerprint", fingerprint, "unknown");
   property_get("ro.revision", revision, "unknown");
 
+  _LOG(log, logtype::HEADER, "CM Version: '%s'\n", cm_version);
   _LOG(log, logtype::HEADER, "Build fingerprint: '%s'\n", fingerprint);
   _LOG(log, logtype::HEADER, "Revision: '%s'\n", revision);
   _LOG(log, logtype::HEADER, "ABI: '%s'\n", ABI_STRING);

From 00c551e284b61d458f05759a489d615933e3667b Mon Sep 17 00:00:00 2001
From: sanketk <sanketk@codeaurora.org>
Date: Fri, 12 Jun 2015 16:38:56 +0800
Subject: [PATCH 10/21] Don't use global variable in libnetutils.

In netd, both CommandListener and NetlinkHandler thread will use
libnetutils' function. Original implementation will use a global
file descriptor in mutiple functions. It will cause problems when
these functions are invoked from different thread.

This change will make NetlinkHandler thread use local file
descriptor instead of global one.

CRs-fixed: 853158
Change-Id: I66458e99e48197e7a56cbb212344423290db12bd
---
 libnetutils/ifc_utils.c | 37 ++++++++++++++++++++++---------------
 1 file changed, 22 insertions(+), 15 deletions(-)

diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index 3bd59c7896..0bd76286b9 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -597,23 +597,26 @@ int ifc_disable(const char *ifname)
 int ifc_reset_connections(const char *ifname, const int reset_mask)
 {
 #ifdef HAVE_ANDROID_OS
-    int result, success;
+    int result = 0, success;
     in_addr_t myaddr = 0;
     struct ifreq ifr;
     struct in6_ifreq ifr6;
+    int ctl_sock = -1;
 
     if (reset_mask & RESET_IPV4_ADDRESSES) {
         /* IPv4. Clear connections on the IP address. */
-        ifc_init();
-        if (!(reset_mask & RESET_IGNORE_INTERFACE_ADDRESS)) {
-            ifc_get_info(ifname, &myaddr, NULL, NULL);
+        ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+        if (ctl_sock >= 0) {
+            if (!(reset_mask & RESET_IGNORE_INTERFACE_ADDRESS)) {
+                ifc_get_info(ifname, &myaddr, NULL, NULL);
+            }
+            ifc_init_ifr(ifname, &ifr);
+            init_sockaddr_in(&ifr.ifr_addr, myaddr);
+            result = ioctl(ctl_sock, SIOCKILLADDR,  &ifr);
+            close(ctl_sock);
+        } else {
+            result = -1;
         }
-        ifc_init_ifr(ifname, &ifr);
-        init_sockaddr_in(&ifr.ifr_addr, myaddr);
-        result = ioctl(ifc_ctl_sock, SIOCKILLADDR,  &ifr);
-        ifc_close();
-    } else {
-        result = 0;
     }
 
     if (reset_mask & RESET_IPV6_ADDRESSES) {
@@ -623,14 +626,18 @@ int ifc_reset_connections(const char *ifname, const int reset_mask)
          * So we clear all unused IPv6 connections on the device by specifying an
          * empty IPv6 address.
          */
-        ifc_init6();
+        ctl_sock = socket(AF_INET6, SOCK_DGRAM, 0);
         // This implicitly specifies an address of ::, i.e., kill all IPv6 sockets.
         memset(&ifr6, 0, sizeof(ifr6));
-        success = ioctl(ifc_ctl_sock6, SIOCKILLADDR,  &ifr6);
-        if (result == 0) {
-            result = success;
+        if (ctl_sock >= 0) {
+            success = ioctl(ctl_sock, SIOCKILLADDR,  &ifr6);
+            if (result == 0) {
+                result = success;
+            }
+            close(ctl_sock);
+        } else {
+            result = -1;
         }
-        ifc_close6();
     }
 
     return result;

From d68de66ea754d8b49815d20b10e69d162ca0a7e1 Mon Sep 17 00:00:00 2001
From: Maunik Shah <mshah@codeaurora.org>
Date: Tue, 22 Sep 2015 16:15:39 +0530
Subject: [PATCH 11/21] Copy the ETB dumps and maps file to /data/core

On enabling the persist.debug.trace, ETB maps and dumps will be
copied to /data/core only for the first crash.

Change-Id: I521ee02e30ce1b4ebaca2c6b398c828286a5115d
---
 debuggerd/debuggerd.cpp | 80 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 80 insertions(+)

diff --git a/debuggerd/debuggerd.cpp b/debuggerd/debuggerd.cpp
index 984b931606..4e1f53efa7 100644
--- a/debuggerd/debuggerd.cpp
+++ b/debuggerd/debuggerd.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright 2006, The Android Open Source Project
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -138,6 +139,84 @@ static int get_process_info(pid_t tid, pid_t* out_pid, uid_t* out_uid, uid_t* ou
   return fields == 7 ? 0 : -1;
 }
 
+static bool copy_file(const char* src, char* dest)
+{
+   #define BUF_SIZE 64
+   ssize_t bytes;
+   int  source_fh, dest_fh;
+   int  total_size = 0;
+   char buffer[BUF_SIZE];
+
+   if ((source_fh = open(src, O_RDONLY, O_NOFOLLOW)) == -1) {
+        ALOGE("Unable to open source file %s\n", src);
+   } else {
+        if((dest_fh = open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW, 0640)) == -1) {
+            ALOGE("Unable to write destination file %s\n", dest);
+        } else {
+            while ((bytes = read(source_fh, buffer, BUF_SIZE)) > 0) {
+                if (write(dest_fh, buffer, bytes) < 0) {
+                    ALOGE("Write failed for destination file %s. Copied %d bytes\n",
+                            dest, total_size);
+                    break;
+                }
+                total_size += bytes;
+            }
+            ALOGI("Copied %s to %s - size: %d\n", src, dest, total_size);
+            fsync(dest_fh);
+            close(dest_fh);
+        }
+        close(source_fh);
+        if (total_size > 0) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static void collect_etb_map(int cr_pid)
+{
+    struct stat s;
+    char   src_buf[64];
+    char   dest_buf[64];
+
+    snprintf(dest_buf, sizeof dest_buf, "/data/core/etb.%d", cr_pid);
+    if (!copy_file("/dev/coresight-tmc-etf", dest_buf)) {
+        ALOGE("Unable to copy ETB buffer file /dev/coresight-tmc-etf\n");
+    } else {
+        memset(src_buf, 0, sizeof(src_buf));
+        snprintf(src_buf, sizeof(src_buf), "/proc/%d/maps", cr_pid);
+        if(stat(src_buf, &s)) {
+            ALOGE("map file /proc/%d/maps does not exist for pid %d\n",
+                cr_pid, cr_pid);
+        } else {
+            snprintf(dest_buf, sizeof dest_buf, "/data/core/maps.%d", cr_pid);
+            if (!copy_file(src_buf, dest_buf)) {
+                ALOGE("Unable to copy map file /proc/%d/maps", cr_pid);
+            }
+        }
+    }
+}
+
+static void enable_etb_trace(struct ucred cr) {
+    char value[PROPERTY_VALUE_MAX];
+    property_get("persist.debug.trace", value, "");
+    if ((strcmp(value,"1") == 0)) {
+        /* Allow ETB collection only once; Note: in future this behavior can be changed
+        * To allow this, use a property to indicate whether the ETB has been collected */
+        property_get("debug.etb.collected", value, "");
+        if(strcmp(value,"1")) {
+            ALOGI("Collecting ETB dumps (from pid=%d uid=%d)\n",
+                     cr.pid, cr.uid);
+            property_set("debug.etb.collected", "1");
+            collect_etb_map(cr.pid);
+        }
+        else {
+            ALOGI("ETB already collected once, skipping (from pid=%d uid=%d)\n",
+                     cr.pid, cr.uid);
+        }
+    }
+}
+
 static int selinux_enabled;
 
 /*
@@ -231,6 +310,7 @@ static int read_request(int fd, debugger_request_t* out_request) {
     // Ensure that the tid reported by the crashing process is valid.
     char buf[64];
     struct stat s;
+    enable_etb_trace(cr);
     snprintf(buf, sizeof buf, "/proc/%d/task/%d", out_request->pid, out_request->tid);
     if (stat(buf, &s)) {
       ALOGE("tid %d does not exist in pid %d. ignoring debug request\n",

From dd0866421e41fb2a38e22c8a94ee93e199599ec1 Mon Sep 17 00:00:00 2001
From: Benson Leung <bleung@google.com>
Date: Wed, 7 Oct 2015 16:12:04 -0700
Subject: [PATCH 12/21] healthd: Support new PD and USB Type C types

See the new types added here :
https://chromium-review.googlesource.com/304660
Add support for these.

Signed-off-by: Benson Leung <bleung@google.com>

Change-Id: I12c51e0611692a763a7f1cda57c77ad83d7aa7ea
---
 healthd/BatteryMonitor.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index 67a8ad0c3d..dfa59b8918 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -140,6 +140,9 @@ BatteryMonitor::PowerSupplyType BatteryMonitor::readPowerSupplyType(const String
             { "USB_ACA", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_HVDCP", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_HVDCP_3", ANDROID_POWER_SUPPLY_TYPE_AC },
+            { "USB_C", ANDROID_POWER_SUPPLY_TYPE_AC },
+            { "USB_PD", ANDROID_POWER_SUPPLY_TYPE_AC },
+            { "USB_PD_DRP", ANDROID_POWER_SUPPLY_TYPE_USB },
             { "Wireless", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
             { "Wipower", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
             { "DockBattery", ANDROID_POWER_SUPPLY_TYPE_DOCK_BATTERY },

From 5d90c85e977df6dd34443b6050db5c994570f410 Mon Sep 17 00:00:00 2001
From: Tom Marshall <tdm@cyngn.com>
Date: Tue, 5 Jul 2016 13:33:47 -0700
Subject: [PATCH 13/21] healthd: Write to blink file to fix LED

Many devices (such as bacon) require touching a blink file before
changes to the LED are committed to hardware.

Jira: CYAN-7689

Change-Id: Ia18a62134d196a636352bcd1af924c407c19d5b4
---
 healthd/Android.mk               |  1 +
 healthd/healthd_mode_charger.cpp | 27 +++++++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/healthd/Android.mk b/healthd/Android.mk
index 7db4ad5f95..f509aceed2 100644
--- a/healthd/Android.mk
+++ b/healthd/Android.mk
@@ -34,6 +34,7 @@ LOCAL_CFLAGS := -D__STDC_LIMIT_MACROS -Werror
 HEALTHD_CHARGER_DEFINES := RED_LED_PATH \
     GREEN_LED_PATH \
     BLUE_LED_PATH \
+    BLINK_PATH \
     BACKLIGHT_PATH \
     CHARGING_ENABLED_PATH
 
diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index d6c31cf6a6..6df9f125e4 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -82,6 +82,10 @@ char *locale;
 #define BLUE_LED_PATH           "/sys/class/leds/blue/brightness"
 #endif
 
+#ifndef BLINK_PATH
+#define BLINK_PATH              "/sys/class/leds/red/device/blink"
+#endif
+
 #define LOGE(x...) do { KLOG_ERROR("charger", x); } while (0)
 #define LOGW(x...) do { KLOG_WARNING("charger", x); } while (0)
 #define LOGV(x...) do { KLOG_DEBUG("charger", x); } while (0)
@@ -214,6 +218,26 @@ static int char_height;
 static bool minui_inited;
 
 #ifndef NO_CHARGER_LED
+static int set_blink(int val)
+{
+    int fd;
+    char buffer[10];
+
+    fd = open(BLINK_PATH, O_RDWR);
+    if (fd < 0) {
+        LOGE("Could not open blink file\n");
+        return -1;
+    }
+    snprintf(buffer, sizeof(buffer), "%d\n", val);
+    if (write(fd, buffer, strlen(buffer)) < 0) {
+        LOGE("Could not write to blink file\n");
+        close(fd);
+        return -1;
+    }
+    close(fd);
+    return 0;
+}
+
 static int set_tricolor_led(int on, int color)
 {
     int fd, i;
@@ -258,6 +282,9 @@ static int set_battery_soc_leds(int soc)
         LOGV("soc = %d, set led color 0x%x\n", soc, soc_leds[i].color);
     }
 
+    /* This is required to commit the changes to hardware */
+    set_blink(0);
+
     return 0;
 }
 #endif

From 5b537bbac12ada45240f441d830bb94c42696230 Mon Sep 17 00:00:00 2001
From: Ruchi Kandoi <kandoiruchi@google.com>
Date: Mon, 29 Feb 2016 13:13:39 -0800
Subject: [PATCH 14/21] healthd: Check if battery device exists instead of
 charger drivers before setting fake properties.

healthd used to check for registered charger drivers to determine if the
device is an always-plugged device with no battery. This patch changes
it to check for battery instead.

Change-Id: Ie4ff5d3f21dc1a83a780a41eb0c929f66b86d631
Signed-off-by: Ruchi Kandoi <kandoiruchi@google.com>
---
 healthd/BatteryMonitor.cpp | 10 +++-------
 1 file changed, 3 insertions(+), 7 deletions(-)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index dfa59b8918..a59c779a98 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -835,19 +835,15 @@ void BatteryMonitor::init(struct healthd_config *hc) {
         closedir(dir);
     }
 
-    // This indicates that there is no charger driver registered.
     // Typically the case for devices which do not have a battery and
     // and are always plugged into AC mains.
-    if (!mChargerNames.size()) {
-        KLOG_ERROR(LOG_TAG, "No charger supplies found\n");
-        mBatteryFixedCapacity = ALWAYS_PLUGGED_CAPACITY;
-        mBatteryFixedTemperature = FAKE_BATTERY_TEMPERATURE;
-        mAlwaysPluggedDevice = true;
-    }
     if (!mBatteryDevicePresent && !mDockBatteryDevicePresent) {
         KLOG_WARNING(LOG_TAG, "No battery devices found\n");
         hc->periodic_chores_interval_fast = -1;
         hc->periodic_chores_interval_slow = -1;
+        mBatteryFixedCapacity = ALWAYS_PLUGGED_CAPACITY;
+        mBatteryFixedTemperature = FAKE_BATTERY_TEMPERATURE;
+        mAlwaysPluggedDevice = true;
     } else {
         if (mHealthdConfig->batteryStatusPath.isEmpty())
             KLOG_WARNING(LOG_TAG, "BatteryStatusPath not found\n");

From b619152148dadeda1acef702420f43c30e7d6d30 Mon Sep 17 00:00:00 2001
From: Mark Salyzyn <salyzyn@google.com>
Date: Tue, 2 Feb 2016 08:05:54 -0800
Subject: [PATCH 15/21] libcutils: ashmem fortify and comply with Android
 coding standard

- sort header order and in groups
- remove all tabs, use only spaces
- use TEMP_FAILURE_RETRY in system calls
- preserve errno for -1 return

Bug: 26871259
Change-Id: I94fffbcaeba01fcc18a3ed07c02389c06c54d3b7
---
 libcutils/ashmem-dev.c  | 63 +++++++++++++++++++++++++++----------------------
 libcutils/ashmem-host.c |  7 ++++--
 2 files changed, 40 insertions(+), 30 deletions(-)

diff --git a/libcutils/ashmem-dev.c b/libcutils/ashmem-dev.c
index 3089a942d0..a5203e13fa 100644
--- a/libcutils/ashmem-dev.c
+++ b/libcutils/ashmem-dev.c
@@ -20,17 +20,19 @@
  * used by the simulator.
  */
 
-#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include <linux/ashmem.h>
+
 #include <cutils/ashmem.h>
 
-#define ASHMEM_DEVICE	"/dev/ashmem"
+#define ASHMEM_DEVICE "/dev/ashmem"
 
 /*
  * ashmem_create_region - creates a new ashmem region and returns the file
@@ -41,50 +43,55 @@
  */
 int ashmem_create_region(const char *name, size_t size)
 {
-	int fd, ret;
+    int ret, save_errno;
 
-	fd = open(ASHMEM_DEVICE, O_RDWR);
-	if (fd < 0)
-		return fd;
+    int fd = TEMP_FAILURE_RETRY(open(ASHMEM_DEVICE, O_RDWR));
+    if (fd < 0) {
+        return fd;
+    }
 
-	if (name) {
-		char buf[ASHMEM_NAME_LEN] = {0};
+    if (name) {
+        char buf[ASHMEM_NAME_LEN] = {0};
 
-		strlcpy(buf, name, sizeof(buf));
-		ret = ioctl(fd, ASHMEM_SET_NAME, buf);
-		if (ret < 0)
-			goto error;
-	}
+        strlcpy(buf, name, sizeof(buf));
+        ret = TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_NAME, buf));
+        if (ret < 0) {
+            goto error;
+        }
+    }
 
-	ret = ioctl(fd, ASHMEM_SET_SIZE, size);
-	if (ret < 0)
-		goto error;
+    ret = TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_SIZE, size));
+    if (ret < 0) {
+        goto error;
+    }
 
-	return fd;
+    return fd;
 
 error:
-	close(fd);
-	return ret;
+    save_errno = errno;
+    close(fd);
+    errno = save_errno;
+    return ret;
 }
 
 int ashmem_set_prot_region(int fd, int prot)
 {
-	return ioctl(fd, ASHMEM_SET_PROT_MASK, prot);
+    return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_PROT_MASK, prot));
 }
 
 int ashmem_pin_region(int fd, size_t offset, size_t len)
 {
-	struct ashmem_pin pin = { offset, len };
-	return ioctl(fd, ASHMEM_PIN, &pin);
+    struct ashmem_pin pin = { offset, len };
+    return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_PIN, &pin));
 }
 
 int ashmem_unpin_region(int fd, size_t offset, size_t len)
 {
-	struct ashmem_pin pin = { offset, len };
-	return ioctl(fd, ASHMEM_UNPIN, &pin);
+    struct ashmem_pin pin = { offset, len };
+    return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_UNPIN, &pin));
 }
 
 int ashmem_get_size_region(int fd)
 {
-  return ioctl(fd, ASHMEM_GET_SIZE, NULL);
+    return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_GET_SIZE, NULL));
 }
diff --git a/libcutils/ashmem-host.c b/libcutils/ashmem-host.c
index abc4f94741..99a2759c06 100644
--- a/libcutils/ashmem-host.c
+++ b/libcutils/ashmem-host.c
@@ -73,8 +73,11 @@ int ashmem_get_size_region(int fd)
         return -1;
     }
 
-    // Check if this is an "ashmem" region.
-    // TODO: This is very hacky, and can easily break. We need some reliable indicator.
+    /*
+     * Check if this is an "ashmem" region.
+     * TODO: This is very hacky, and can easily break.
+     * We need some reliable indicator.
+     */
     if (!(buf.st_nlink == 0 && S_ISREG(buf.st_mode))) {
         errno = ENOTTY;
         return -1;

From 2895e11453da7afc326864a097ff59833a0bffea Mon Sep 17 00:00:00 2001
From: Mark Salyzyn <salyzyn@google.com>
Date: Tue, 2 Feb 2016 08:21:32 -0800
Subject: [PATCH 16/21] libcutils: ashmem check fd validity

- collect st_rdev on open, or when required, for /dev/ashmem.
- check in all cases if fd is a character device and matches rdev.
- requires that we have open, read and write access to /dev/ashmem
  to check, assumption being that if we can not, then we have no
  right playing with the associated misdirected file descriptor.

NB: ashmem libcutil library entry points can no longer be called in
    signal context.

Bug: 26871259
Change-Id: I9a17e33317a9be795131473a51c16f761b5f7407
---
 libcutils/ashmem-dev.c | 108 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 107 insertions(+), 1 deletion(-)

diff --git a/libcutils/ashmem-dev.c b/libcutils/ashmem-dev.c
index a5203e13fa..77e4d0d97d 100644
--- a/libcutils/ashmem-dev.c
+++ b/libcutils/ashmem-dev.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <pthread.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
@@ -34,6 +35,89 @@
 
 #define ASHMEM_DEVICE "/dev/ashmem"
 
+/* ashmem identity */
+static dev_t __ashmem_rdev;
+/*
+ * If we trigger a signal handler in the middle of locked activity and the
+ * signal handler calls ashmem, we could get into a deadlock state.
+ */
+static pthread_mutex_t __ashmem_lock = PTHREAD_MUTEX_INITIALIZER;
+
+/* logistics of getting file descriptor for ashmem */
+static int __ashmem_open_locked()
+{
+    int ret;
+    struct stat st;
+
+    int fd = TEMP_FAILURE_RETRY(open(ASHMEM_DEVICE, O_RDWR));
+    if (fd < 0) {
+        return fd;
+    }
+
+    ret = TEMP_FAILURE_RETRY(fstat(fd, &st));
+    if (ret < 0) {
+        int save_errno = errno;
+        close(fd);
+        errno = save_errno;
+        return ret;
+    }
+    if (!S_ISCHR(st.st_mode) || !st.st_rdev) {
+        close(fd);
+        errno = ENOTTY;
+        return -1;
+    }
+
+    __ashmem_rdev = st.st_rdev;
+    return fd;
+}
+
+static int __ashmem_open()
+{
+    int fd;
+
+    pthread_mutex_lock(&__ashmem_lock);
+    fd = __ashmem_open_locked();
+    pthread_mutex_unlock(&__ashmem_lock);
+
+    return fd;
+}
+
+/* Make sure file descriptor references ashmem, negative number means false */
+static int __ashmem_is_ashmem(int fd)
+{
+    dev_t rdev;
+    struct stat st;
+
+    if (TEMP_FAILURE_RETRY(fstat(fd, &st)) < 0) {
+        return -1;
+    }
+
+    if (S_ISCHR(st.st_mode) && st.st_rdev) {
+        pthread_mutex_lock(&__ashmem_lock);
+        rdev = __ashmem_rdev;
+        if (rdev) {
+            pthread_mutex_unlock(&__ashmem_lock);
+        } else {
+            int fd = __ashmem_open_locked();
+            if (fd < 0) {
+                pthread_mutex_unlock(&__ashmem_lock);
+                return -1;
+            }
+            rdev = __ashmem_rdev;
+            pthread_mutex_unlock(&__ashmem_lock);
+
+            close(fd);
+        }
+
+        if (st.st_rdev == rdev) {
+            return 0;
+        }
+    }
+
+    errno = ENOTTY;
+    return -1;
+}
+
 /*
  * ashmem_create_region - creates a new ashmem region and returns the file
  * descriptor, or <0 on error
@@ -45,7 +129,7 @@ int ashmem_create_region(const char *name, size_t size)
 {
     int ret, save_errno;
 
-    int fd = TEMP_FAILURE_RETRY(open(ASHMEM_DEVICE, O_RDWR));
+    int fd = __ashmem_open();
     if (fd < 0) {
         return fd;
     }
@@ -76,22 +160,44 @@ int ashmem_create_region(const char *name, size_t size)
 
 int ashmem_set_prot_region(int fd, int prot)
 {
+    int ret = __ashmem_is_ashmem(fd);
+    if (ret < 0) {
+        return ret;
+    }
+
     return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_SET_PROT_MASK, prot));
 }
 
 int ashmem_pin_region(int fd, size_t offset, size_t len)
 {
     struct ashmem_pin pin = { offset, len };
+
+    int ret = __ashmem_is_ashmem(fd);
+    if (ret < 0) {
+        return ret;
+    }
+
     return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_PIN, &pin));
 }
 
 int ashmem_unpin_region(int fd, size_t offset, size_t len)
 {
     struct ashmem_pin pin = { offset, len };
+
+    int ret = __ashmem_is_ashmem(fd);
+    if (ret < 0) {
+        return ret;
+    }
+
     return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_UNPIN, &pin));
 }
 
 int ashmem_get_size_region(int fd)
 {
+    int ret = __ashmem_is_ashmem(fd);
+    if (ret < 0) {
+        return ret;
+    }
+
     return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_GET_SIZE, NULL));
 }

From 70a8c7aef01d843eb390e744243667e1af6c5615 Mon Sep 17 00:00:00 2001
From: Mark Salyzyn <salyzyn@google.com>
Date: Tue, 2 Feb 2016 09:19:39 -0800
Subject: [PATCH 17/21] libcutils: ashmem print error message for invalid fd

NB: We decided to not sniff for the constant saved __ashmem_rdev in
the early error path; requiring either the use of atomic operations,
or acquiring a lock to do it correctly. The heroics are not worth it.

Bug: 26871259
Change-Id: I46249838850ae32063eb5b7d08c731c5bb0fbf6b
---
 libcutils/ashmem-dev.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/libcutils/ashmem-dev.c b/libcutils/ashmem-dev.c
index 77e4d0d97d..d6a48c9539 100644
--- a/libcutils/ashmem-dev.c
+++ b/libcutils/ashmem-dev.c
@@ -19,6 +19,7 @@
  * ashmem-enabled kernel. See ashmem-sim.c for the "fake" tmp-based version,
  * used by the simulator.
  */
+#define LOG_TAG "ashmem"
 
 #include <errno.h>
 #include <fcntl.h>
@@ -32,6 +33,7 @@
 #include <linux/ashmem.h>
 
 #include <cutils/ashmem.h>
+#include <log/log.h>
 
 #define ASHMEM_DEVICE "/dev/ashmem"
 
@@ -92,6 +94,7 @@ static int __ashmem_is_ashmem(int fd)
         return -1;
     }
 
+    rdev = 0; /* Too much complexity to sniff __ashmem_rdev */
     if (S_ISCHR(st.st_mode) && st.st_rdev) {
         pthread_mutex_lock(&__ashmem_lock);
         rdev = __ashmem_rdev;
@@ -114,6 +117,17 @@ static int __ashmem_is_ashmem(int fd)
         }
     }
 
+    if (rdev) {
+        ALOGE("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o %d:%d",
+          fd, st.st_mode, major(st.st_rdev), minor(st.st_rdev),
+          S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IRGRP,
+          major(rdev), minor(rdev));
+    } else {
+        ALOGE("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o",
+          fd, st.st_mode, major(st.st_rdev), minor(st.st_rdev),
+          S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IRGRP);
+    }
+
     errno = ENOTTY;
     return -1;
 }

From 53bf23431d5e9f5b320d9e2adb7b10f650178dc9 Mon Sep 17 00:00:00 2001
From: Mark Salyzyn <salyzyn@google.com>
Date: Tue, 2 Feb 2016 09:20:31 -0800
Subject: [PATCH 18/21] libcutils: abort for invalid fd

If ashmem accessors are being called with a file descriptor that
belongs to anything other than ashmem, we need to stop it right
now so that they can fix the caller.

Bug: 26871259
Change-Id: Icf9aafc3631a80b9af6fe0fea03599d61e285d21
---
 libcutils/ashmem-dev.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libcutils/ashmem-dev.c b/libcutils/ashmem-dev.c
index d6a48c9539..4a07d66bb0 100644
--- a/libcutils/ashmem-dev.c
+++ b/libcutils/ashmem-dev.c
@@ -118,15 +118,16 @@ static int __ashmem_is_ashmem(int fd)
     }
 
     if (rdev) {
-        ALOGE("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o %d:%d",
+        LOG_ALWAYS_FATAL("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o %d:%d",
           fd, st.st_mode, major(st.st_rdev), minor(st.st_rdev),
           S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IRGRP,
           major(rdev), minor(rdev));
     } else {
-        ALOGE("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o",
+        LOG_ALWAYS_FATAL("illegal fd=%d mode=0%o rdev=%d:%d expected 0%o",
           fd, st.st_mode, major(st.st_rdev), minor(st.st_rdev),
           S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IRGRP);
     }
+    /* NOTREACHED */
 
     errno = ENOTTY;
     return -1;

From d63e6757fa22fcb58653233fce035deed8036a1b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 23 Jul 2016 20:16:24 -0700
Subject: [PATCH 19/21] sdcard: Add support for sdcardfs!

 * sdcardfs is a kernel filesystem developed by Samsung and recently
   seen in AOSP's common kernel branches. It entirely eliminates
   the need to use FUSE for sdcard emulation and moves all the
   wrapping logic to kernel. This vastly improves performance for
   use cases which read/write to emulated as well as removable
   cards.

Change-Id: I3e394a99e0a4b5beacaeddc0d4dd4855ff0cf082
---
 sdcard/sdcard.c | 63 +++++++++++++++++++++++++++++++++++++++------------------
 1 file changed, 43 insertions(+), 20 deletions(-)

diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index 98af250e06..c0f60edc1c 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -41,6 +41,7 @@
 #include <cutils/hashmap.h>
 #include <cutils/log.h>
 #include <cutils/multiuser.h>
+#include <cutils/properties.h>
 
 #include <private/android_filesystem_config.h>
 
@@ -1776,24 +1777,39 @@ static int usage() {
     return 1;
 }
 
-static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask) {
+static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask, bool use_sdcardfs) {
     char opts[256];
 
-    fuse->fd = open("/dev/fuse", O_RDWR);
-    if (fuse->fd == -1) {
-        ERROR("failed to open fuse device: %s\n", strerror(errno));
-        return -1;
+    if (use_sdcardfs) {
+        fuse->fd = open("/dev/fuse", O_RDWR);
+        if (fuse->fd == -1) {
+            ERROR("failed to open fuse device: %s\n", strerror(errno));
+            return -1;
+        }
     }
 
     umount2(fuse->dest_path, MNT_DETACH);
 
-    snprintf(opts, sizeof(opts),
-            "fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
-            fuse->fd, fuse->global->uid, fuse->global->gid);
-    if (mount("/dev/fuse", fuse->dest_path, "fuse", MS_NOSUID | MS_NODEV | MS_NOEXEC |
-            MS_NOATIME, opts) != 0) {
-        ERROR("failed to mount fuse filesystem: %s\n", strerror(errno));
-        return -1;
+    if (use_sdcardfs) {
+        snprintf(opts, sizeof(opts),
+                "%sfsuid=%d,fsgid=%d,userid=%d,gid=%d,mask=%04o,reserved_mb=20",
+                (fuse->global->multi_user ? "multiuser," : ""),
+                fuse->global->uid, fuse->global->gid,
+                fuse->global->root.userid, gid, mask);
+        if (mount(fuse->global->source_path, fuse->dest_path, "sdcardfs",
+                    MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts) != 0) {
+            ERROR("failed to mount sdcardfs filesystem: %s\n",  strerror(errno));
+            return -1;
+        }
+    } else {
+        snprintf(opts, sizeof(opts),
+                "fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
+                fuse->fd, fuse->global->uid, fuse->global->gid);
+        if (mount("/dev/fuse", fuse->dest_path, "fuse", MS_NOSUID | MS_NODEV | MS_NOEXEC |
+                MS_NOATIME, opts) != 0) {
+            ERROR("failed to mount fuse filesystem: %s\n", strerror(errno));
+            return -1;
+        }
     }
 
     fuse->gid = gid;
@@ -1803,7 +1819,7 @@ static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask) {
 }
 
 static void run(const char* source_path, const char* label, uid_t uid,
-        gid_t gid, userid_t userid, bool multi_user, bool full_write) {
+        gid_t gid, userid_t userid, bool multi_user, bool full_write, bool use_sdcardfs) {
     struct fuse_global global;
     struct fuse fuse_default;
     struct fuse fuse_read;
@@ -1875,9 +1891,9 @@ static void run(const char* source_path, const char* label, uid_t uid,
     if (multi_user) {
         /* Multi-user storage is fully isolated per user, so "other"
          * permissions are completely masked off. */
-        if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
-                || fuse_setup(&fuse_read, AID_EVERYBODY, 0027)
-                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0027)) {
+        if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006, use_sdcardfs)
+                || fuse_setup(&fuse_read, AID_EVERYBODY, 0027, use_sdcardfs)
+                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0027, use_sdcardfs)) {
             ERROR("failed to fuse_setup\n");
             exit(1);
         }
@@ -1885,14 +1901,19 @@ static void run(const char* source_path, const char* label, uid_t uid,
         /* Physical storage is readable by all users on device, but
          * the Android directories are masked off to a single user
          * deep inside attr_from_stat(). */
-        if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
-                || fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022)
-                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022)) {
+        if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006, use_sdcardfs)
+                || fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022, use_sdcardfs)
+                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022, use_sdcardfs)) {
             ERROR("failed to fuse_setup\n");
             exit(1);
         }
     }
 
+    // Nothing else for us to do if sdcardfs is in use!
+    if (use_sdcardfs) {
+        exit(0);
+    }
+
     /* Drop privs */
     if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
         ERROR("cannot setgroups: %s\n", strerror(errno));
@@ -1995,6 +2016,8 @@ int sdcard_main(int argc, char **argv) {
         sleep(1);
     }
 
-    run(source_path, label, uid, gid, userid, multi_user, full_write);
+    bool use_sdcardfs = property_get_bool("ro.sdcardfs.enable", false);
+
+    run(source_path, label, uid, gid, userid, multi_user, full_write, use_sdcardfs);
     return 1;
 }

From 7f9b2ce419e8d9abfff61bca852c5cb652ee2361 Mon Sep 17 00:00:00 2001
From: Zhao Wei Liew <zhaoweiliew@gmail.com>
Date: Sun, 24 Jul 2016 15:45:31 +0800
Subject: [PATCH 20/21] sdcard: Fix sdcardFS check

This check is inverted, breaking FUSE.

Change-Id: I81a710f464bce73f49fb1af6050a198b5f443f52
---
 sdcard/sdcard.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index c0f60edc1c..5309bbd51b 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -1780,7 +1780,7 @@ static int usage() {
 static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask, bool use_sdcardfs) {
     char opts[256];
 
-    if (use_sdcardfs) {
+    if (!use_sdcardfs) {
         fuse->fd = open("/dev/fuse", O_RDWR);
         if (fuse->fd == -1) {
             ERROR("failed to open fuse device: %s\n", strerror(errno));

From 1576854573b0ee5525f4a3476d0f58d2f45eeae1 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 26 Jul 2016 03:03:06 -0700
Subject: [PATCH 21/21] sdcard: Pass the umask to sdcardfs correctly

 * Google version of the kernel code expects unsigned int rather than
   octal. Don't confuse it.

Change-Id: I40f060dc5212ec587e612dc275001e1a660cce67
---
 sdcard/sdcard.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index 5309bbd51b..227982c05f 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -1792,7 +1792,7 @@ static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask, bool use_sdcard
 
     if (use_sdcardfs) {
         snprintf(opts, sizeof(opts),
-                "%sfsuid=%d,fsgid=%d,userid=%d,gid=%d,mask=%04o,reserved_mb=20",
+                "%sfsuid=%u,fsgid=%u,userid=%d,gid=%u,mask=%u,reserved_mb=20",
                 (fuse->global->multi_user ? "multiuser," : ""),
                 fuse->global->uid, fuse->global->gid,
                 fuse->global->root.userid, gid, mask);
@@ -1909,11 +1909,6 @@ static void run(const char* source_path, const char* label, uid_t uid,
         }
     }
 
-    // Nothing else for us to do if sdcardfs is in use!
-    if (use_sdcardfs) {
-        exit(0);
-    }
-
     /* Drop privs */
     if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
         ERROR("cannot setgroups: %s\n", strerror(errno));
@@ -1932,6 +1927,11 @@ static void run(const char* source_path, const char* label, uid_t uid,
         fs_prepare_dir(global.obb_path, 0775, uid, gid);
     }
 
+    // Nothing else for us to do if sdcardfs is in use!
+    if (use_sdcardfs) {
+        exit(0);
+    }
+
     if (pthread_create(&thread_default, NULL, start_handler, &handler_default)
             || pthread_create(&thread_read, NULL, start_handler, &handler_read)
             || pthread_create(&thread_write, NULL, start_handler, &handler_write)) {	 
			 
			 
From ac3ba32634bf2ddbc4efb7d60709ec10f69bceef Mon Sep 17 00:00:00 2001
From: fire855 <thefire855@gmail.com>
Date: Sat, 30 Jul 2016 14:24:03 +0200
Subject: [PATCH] Revert "Fix service permissions"

This reverts commit e58c35b3b0556d2f7cfbfa1254ed4dd2a0ee05e6.
---
 rootdir/init.rc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 4c81acccbf..9b07e6a65e 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -653,7 +653,7 @@ service debuggerd64 /system/bin/debuggerd64
 
 service surfaceflinger /system/bin/surfaceflinger
     class core
-    user root
+    user system
     group graphics drmrpc
     onrestart restart zygote
 
@@ -664,7 +664,7 @@ service drm /system/bin/drmserver
 
 service media /system/bin/mediaserver
     class main
-    user root
+    user media
     group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm qcom_diag
     ioprio rt 4
 		 